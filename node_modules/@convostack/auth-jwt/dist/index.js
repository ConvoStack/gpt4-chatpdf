"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../convostack-shared/dist/index.js
var require_dist = __commonJS({
  "../convostack-shared/dist/index.js"(exports, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports2 = {};
    __export2(src_exports2, {
      AI_ROLE: () => AI_ROLE,
      CONVERSATION_EVENT_KIND_CONVERSATION_METADATA: () => CONVERSATION_EVENT_KIND_CONVERSATION_METADATA,
      CONVERSATION_EVENT_KIND_MESSAGE: () => CONVERSATION_EVENT_KIND_MESSAGE,
      CONVERSATION_EVENT_KIND_MESSAGE_PART: () => CONVERSATION_EVENT_KIND_MESSAGE_PART,
      HUMAN_ROLE: () => HUMAN_ROLE,
      addSecondsToDate: () => addSecondsToDate2,
      generateRandomID: () => generateRandomID2,
      unixTimestamp: () => unixTimestamp2
    });
    module2.exports = __toCommonJS2(src_exports2);
    var CONVERSATION_EVENT_KIND_MESSAGE = "message";
    var CONVERSATION_EVENT_KIND_MESSAGE_PART = "message_part";
    var CONVERSATION_EVENT_KIND_CONVERSATION_METADATA = "conversation_metadata";
    var AI_ROLE = "AI";
    var HUMAN_ROLE = "Human";
    var import_crypto = __toESM2(require("crypto"));
    var generateRandomID2 = (length) => {
      return import_crypto.default.randomBytes(length).toString("hex");
    };
    var unixTimestamp2 = (date) => {
      if (!date) {
        date = /* @__PURE__ */ new Date();
      }
      return Math.floor(date.getTime() / 1e3);
    };
    var addSecondsToDate2 = (date, seconds) => {
      const newUnixTimestamp = unixTimestamp2(date) + seconds;
      return new Date(newUnixTimestamp * 1e3);
    };
  }
});

// ../../node_modules/validator/lib/util/assertString.js
var require_assertString = __commonJS({
  "../../node_modules/validator/lib/util/assertString.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assertString;
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function assertString(input) {
      var isString = typeof input === "string" || input instanceof String;
      if (!isString) {
        var invalidType = _typeof(input);
        if (input === null)
          invalidType = "null";
        else if (invalidType === "object")
          invalidType = input.constructor.name;
        throw new TypeError("Expected a string but received a ".concat(invalidType));
      }
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  }
});

// ../../node_modules/validator/lib/util/merge.js
var require_merge = __commonJS({
  "../../node_modules/validator/lib/util/merge.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = merge;
    function merge() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults = arguments.length > 1 ? arguments[1] : void 0;
      for (var key in defaults) {
        if (typeof obj[key] === "undefined") {
          obj[key] = defaults[key];
        }
      }
      return obj;
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  }
});

// ../../node_modules/validator/lib/isByteLength.js
var require_isByteLength = __commonJS({
  "../../node_modules/validator/lib/isByteLength.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isByteLength;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function isByteLength(str, options) {
      (0, _assertString.default)(str);
      var min;
      var max;
      if (_typeof(options) === "object") {
        min = options.min || 0;
        max = options.max;
      } else {
        min = arguments[1];
        max = arguments[2];
      }
      var len = encodeURI(str).split(/%..|./).length - 1;
      return len >= min && (typeof max === "undefined" || len <= max);
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  }
});

// ../../node_modules/validator/lib/isFQDN.js
var require_isFQDN = __commonJS({
  "../../node_modules/validator/lib/isFQDN.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isFQDN;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_fqdn_options = {
      require_tld: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_numeric_tld: false,
      allow_wildcard: false,
      ignore_max_length: false
    };
    function isFQDN(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_fqdn_options);
      if (options.allow_trailing_dot && str[str.length - 1] === ".") {
        str = str.substring(0, str.length - 1);
      }
      if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
        str = str.substring(2);
      }
      var parts = str.split(".");
      var tld = parts[parts.length - 1];
      if (options.require_tld) {
        if (parts.length < 2) {
          return false;
        }
        if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
          return false;
        }
        if (/\s/.test(tld)) {
          return false;
        }
      }
      if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
        return false;
      }
      return parts.every(function(part) {
        if (part.length > 63 && !options.ignore_max_length) {
          return false;
        }
        if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
          return false;
        }
        if (/[\uff01-\uff5e]/.test(part)) {
          return false;
        }
        if (/^-|-$/.test(part)) {
          return false;
        }
        if (!options.allow_underscores && /_/.test(part)) {
          return false;
        }
        return true;
      });
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  }
});

// ../../node_modules/validator/lib/isIP.js
var require_isIP = __commonJS({
  "../../node_modules/validator/lib/isIP.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIP;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
    var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
    var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
    var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
    function isIP(str) {
      var version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      (0, _assertString.default)(str);
      version = String(version);
      if (!version) {
        return isIP(str, 4) || isIP(str, 6);
      }
      if (version === "4") {
        return IPv4AddressRegExp.test(str);
      }
      if (version === "6") {
        return IPv6AddressRegExp.test(str);
      }
      return false;
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  }
});

// ../../node_modules/validator/lib/isEmail.js
var require_isEmail = __commonJS({
  "../../node_modules/validator/lib/isEmail.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isEmail2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    var _isByteLength = _interopRequireDefault(require_isByteLength());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isIP = _interopRequireDefault(require_isIP());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_email_options = {
      allow_display_name: false,
      require_display_name: false,
      allow_utf8_local_part: true,
      require_tld: true,
      blacklisted_chars: "",
      ignore_max_length: false,
      host_blacklist: [],
      host_whitelist: []
    };
    var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var gmailUserPart = /^[a-z\d]+$/;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    var defaultMaxEmailLength = 254;
    function validateDisplayName(display_name) {
      var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
      if (!display_name_without_quotes.trim()) {
        return false;
      }
      var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
      if (contains_illegal) {
        if (display_name_without_quotes === display_name) {
          return false;
        }
        var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
        if (!all_start_with_back_slash) {
          return false;
        }
      }
      return true;
    }
    function isEmail2(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_email_options);
      if (options.require_display_name || options.allow_display_name) {
        var display_email = str.match(splitNameAddress);
        if (display_email) {
          var display_name = display_email[1];
          str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
          if (display_name.endsWith(" ")) {
            display_name = display_name.slice(0, -1);
          }
          if (!validateDisplayName(display_name)) {
            return false;
          }
        } else if (options.require_display_name) {
          return false;
        }
      }
      if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
        return false;
      }
      var parts = str.split("@");
      var domain = parts.pop();
      var lower_domain = domain.toLowerCase();
      if (options.host_blacklist.includes(lower_domain)) {
        return false;
      }
      if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
        return false;
      }
      var user = parts.join("@");
      if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
        user = user.toLowerCase();
        var username = user.split("+")[0];
        if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
          min: 6,
          max: 30
        })) {
          return false;
        }
        var _user_parts = username.split(".");
        for (var i = 0; i < _user_parts.length; i++) {
          if (!gmailUserPart.test(_user_parts[i])) {
            return false;
          }
        }
      }
      if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
        max: 64
      }) || !(0, _isByteLength.default)(domain, {
        max: 254
      }))) {
        return false;
      }
      if (!(0, _isFQDN.default)(domain, {
        require_tld: options.require_tld,
        ignore_max_length: options.ignore_max_length
      })) {
        if (!options.allow_ip_domain) {
          return false;
        }
        if (!(0, _isIP.default)(domain)) {
          if (!domain.startsWith("[") || !domain.endsWith("]")) {
            return false;
          }
          var noBracketdomain = domain.slice(1, -1);
          if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
            return false;
          }
        }
      }
      if (user[0] === '"') {
        user = user.slice(1, user.length - 1);
        return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
      }
      var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
      var user_parts = user.split(".");
      for (var _i = 0; _i < user_parts.length; _i++) {
        if (!pattern.test(user_parts[_i])) {
          return false;
        }
      }
      if (options.blacklisted_chars) {
        if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1)
          return false;
      }
      return true;
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AuthJWT: () => AuthJWT
});
module.exports = __toCommonJS(src_exports);
var crypto = __toESM(require("crypto"));
var import_shared = __toESM(require_dist());
var import_jsonwebtoken = require("jsonwebtoken");
var import_isEmail = __toESM(require_isEmail());
var AuthJWT = class {
  constructor(storage, options) {
    this.storage = storage;
    this.options = options;
    if (!this.options.jwtSecret || this.options.jwtSecret.length < 32) {
      throw new Error("AuthJWT 'jwtSecret' option must be at least 32 characters in length");
    }
    if (this.options.requireUserVerificationHash && (!this.options.userDataVerificationSecret || this.options.userDataVerificationSecret.length < 32)) {
      throw new Error("AuthJWT 'userDataVerificationSecret' option must be at least 32 characters in length");
    }
    if (!this.options.accessTokenTTL || this.options.accessTokenTTL < 1) {
      this.options.accessTokenTTL = 60 * 15;
    }
    if (!this.options.refreshTokenTTL || this.options.refreshTokenTTL < 1) {
      this.options.refreshTokenTTL = 60 * 60 * 24 * 7;
    }
  }
  async validateTokenFromAuthorizationValueIfProvided(authHeaderValue) {
    if (!authHeaderValue) {
      return {
        user: null
      };
    }
    let token = "";
    if (authHeaderValue.startsWith("Bearer ")) {
      token = authHeaderValue.substring(7, authHeaderValue.length);
    } else {
      throw new Error("Access denied. Invalid Authorization header.");
    }
    try {
      const decoded = await this.validateAccessToken(token);
      const user = await this.storage.findUser({ id: decoded.userId });
      if (!user || user.id != decoded.userId) {
        throw new Error("Access denied. Invalid token.");
      }
      return {
        user
      };
    } catch (err) {
      throw new Error("Access denied. Invalid token.");
    }
  }
  async getGQLAuthContextHTTP(req) {
    return await this.validateTokenFromAuthorizationValueIfProvided(req.headers["authorization"]);
  }
  async getGQLAuthContextWS(connectionParams) {
    return await this.validateTokenFromAuthorizationValueIfProvided(connectionParams["Authorization"]);
  }
  async login(req, {
    email,
    externalId,
    name,
    anonymousId,
    hash
  }) {
    let user;
    if (typeof email === "string") {
      email = email.trim();
    }
    if (typeof name === "string") {
      name = name.trim();
    }
    if (typeof externalId === "string") {
      externalId = externalId.trim();
    }
    if (!email) {
      email = null;
    }
    if (!name) {
      name = null;
    }
    if (!externalId) {
      externalId = null;
    }
    if (!anonymousId) {
      anonymousId = null;
    }
    if ((email || externalId) && anonymousId) {
      throw new Error("anonymous users cannot have email or external id");
    }
    if (email && !this.isValidEmail(email)) {
      throw new Error("provided email is not a valid email");
    }
    const isAnon = !email && !externalId || anonymousId;
    if (!this.options.allowAnonUsers && isAnon) {
      throw new Error("anonymous users are not allowed");
    }
    if (!isAnon && this.options.requireUserVerificationHash) {
      const correctHash = this.generateVerificationHash(this.options.userDataVerificationSecret, externalId, email, name);
      if (correctHash !== hash) {
        throw new Error("user data verification hash is invalid");
      }
    }
    if (anonymousId) {
      user = await this.storage.findUser({
        anonymousId
      });
    } else if (externalId) {
      user = await this.storage.findUser({
        externalId
      });
      if (!user) {
        user = await this.storage.createUser({
          name,
          email,
          externalId
        });
      } else {
        if (user.name != name || user.email != email) {
          user = await this.storage.updateUser(
            user.id,
            {
              name,
              email
            }
          );
        }
      }
    } else if (email) {
      user = await this.storage.findUser({
        email
      });
      if (!user) {
        user = await this.storage.createUser({
          name,
          email
        });
      } else {
        if (user.name != name) {
          user = await this.storage.updateUser(
            user.id,
            {
              name
            }
          );
        }
      }
    } else {
      user = await this.storage.createUser({
        anonymousId: (0, import_shared.generateRandomID)(64)
      });
    }
    if (!user) {
      throw new Error("Login failed");
    }
    const accessToken = this.generateAccessToken(user);
    const refreshToken = this.generateRefreshToken(user);
    return {
      accessToken,
      anonymousId: user.anonymousId,
      refreshToken,
      anonymous: !!user.anonymousId,
      email: user.email,
      name: user.name,
      userId: user.id
    };
  }
  async refresh(req, params) {
    const tknPayload = await this.validateRefreshToken(params.refreshToken);
    const user = await this.storage.findUser({
      id: tknPayload.userId
    });
    if (!user) {
      throw new Error("Login failed");
    }
    const accessToken = this.generateAccessToken(user);
    const refreshToken = this.generateRefreshToken(user);
    return {
      accessToken,
      anonymousId: user.anonymousId,
      refreshToken,
      anonymous: !!user.anonymousId,
      email: user.email,
      name: user.name,
      userId: user.id
    };
  }
  sign(secret, ttlSecs, payload) {
    const signOptions = {
      algorithm: "HS256",
      expiresIn: ttlSecs
    };
    return (0, import_jsonwebtoken.sign)(payload, secret, signOptions);
  }
  validate(secret, token, kind) {
    const verifyOptions = {
      algorithms: ["HS256"]
    };
    return new Promise((resolve, reject) => {
      (0, import_jsonwebtoken.verify)(token, secret, verifyOptions, (error, decoded) => {
        if (error) {
          return reject(error);
        }
        if (!decoded) {
          return reject(new Error("invalid jwt payload on validation"));
        }
        if (decoded["kind"] !== kind) {
          return reject(new Error("invalid token kind"));
        }
        resolve(decoded);
      });
    });
  }
  generateAccessToken(user) {
    const payload = {
      userId: user.id,
      email: user.email,
      kind: "access"
    };
    const tkn = this.sign(this.options.jwtSecret, this.options.accessTokenTTL, payload);
    return {
      token: tkn,
      expAt: (0, import_shared.unixTimestamp)(
        (0, import_shared.addSecondsToDate)(
          /* @__PURE__ */ new Date(),
          this.options.accessTokenTTL
        )
      )
    };
  }
  generateRefreshToken(user) {
    const payload = {
      userId: user.id,
      email: user.email,
      kind: "refresh"
    };
    const tkn = this.sign(this.options.jwtSecret, this.options.refreshTokenTTL, payload);
    return {
      token: tkn,
      expAt: (0, import_shared.unixTimestamp)(
        (0, import_shared.addSecondsToDate)(
          /* @__PURE__ */ new Date(),
          this.options.refreshTokenTTL
        )
      )
    };
  }
  validateRefreshToken(token) {
    try {
      return this.validate(this.options.jwtSecret, token, "refresh");
    } catch (err) {
      throw new Error("Invalid refresh token");
    }
  }
  validateAccessToken(token) {
    try {
      return this.validate(this.options.jwtSecret, token, "access");
    } catch (err) {
      throw new Error("Invalid access token");
    }
  }
  /***
   * Returns a string hash of the user data for verifying ConvoStack users. Ensure that you trim all of the strings that you send as leading/trailing spaces will cause issues with uniqueness.
   * @param hashSecret This is the 'secret' used for generating and verifying the hashes
   * @param userId This is the user ID of the user in the host platform. This is the ID that you give to your own users, not the ID that ConvoStack uses internally. Set to null if not available or used with ConvoStack. You must provide at least an email or userId when using user verification. We recommend providing a user ID in case you allow users to change/update their email addresses.
   * @param email User email address. Set to null if not available or used with ConvoStack. You must provide at least an email or userId when using user verification
   * @param name User's name. Set to null if not available or used with ConvoStack
   */
  generateVerificationHash(hashSecret, userId, email, name) {
    if (!hashSecret) {
      throw new Error("user data hash verification failed because no secret was provided");
    }
    const hmac = crypto.createHmac("sha256", hashSecret);
    const payload = `userId:${userId ? userId : "null"}
email:${email ? email : "null"}
${name ? name : "null"}`;
    hmac.update(payload);
    return hmac.digest("hex");
  }
  isValidEmail(email) {
    return (0, import_isEmail.default)(email);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthJWT
});
