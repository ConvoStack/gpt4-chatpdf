"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ConvoStackBackendExpress: () => ConvoStackBackendExpress
});
module.exports = __toCommonJS(src_exports);

// src/backend.ts
var import_reflect_metadata = require("reflect-metadata");
var import_apollo_server_express = require("apollo-server-express");
var import_ws = require("graphql-ws/lib/use/ws");
var import_fs = require("fs");
var import_path = require("path");
var import_schema = require("@graphql-tools/schema");

// src/resolvers/auth.ts
var authResolvers = {
  Mutation: {
    async login(_, args, ctx) {
      return await ctx.services.auth.login(ctx.req, args);
    },
    async refreshAuth(_, args, ctx) {
      return await ctx.services.auth.refresh(ctx.req, args);
    }
  }
};

// src/guards/index.ts
var mustUser = (ctx) => {
  if (!ctx || !ctx.user || !ctx.user.id) {
    throw new Error("Access denied. This route requires authentication.");
  }
};

// src/resolvers/conversations.ts
var conversationResolvers = {
  Mutation: {
    async sendMessage(_, { message, conversationId, agent, context }, ctx) {
      mustUser(ctx);
      let convo = await ctx.services.conversationService.findOrCreateConversation(
        ctx.user,
        conversationId,
        agent
      );
      if (context) {
        convo = await ctx.services.storage.updateConversation(convo.id, {
          context: JSON.stringify(context)
        });
      }
      const msg = await ctx.services.agentService.sendMessage(ctx.user, convo, message);
      return {
        conversationId: convo.id,
        messageId: msg.id
      };
    },
    async updateConversationContext(_, { conversationId, context }, ctx) {
      mustUser(ctx);
      let convo = await ctx.services.conversationService.mustFindConversation(
        ctx.user,
        conversationId
      );
      convo = await ctx.services.storage.updateConversation(convo.id, {
        context: JSON.stringify(context)
      });
      return {
        ...convo,
        createdAt: convo.createdAt.toISOString(),
        updatedAt: convo.updatedAt.toISOString()
      };
    }
  },
  Query: {
    async getConversations(_, __, ctx) {
      mustUser(ctx);
      const convos = await ctx.services.storage.findConversations(
        {
          userId: ctx.user.id
        },
        {
          updatedAt: "desc"
        }
      );
      return await Promise.all(convos.map(async (convo) => {
        const lastMessages = await ctx.services.storage.findMessages(
          {
            conversationId: convo.id
          },
          {
            turn: "desc"
          },
          0,
          1
        );
        let lastMessage = null;
        if (lastMessages && lastMessages.length > 0) {
          lastMessage = {
            ...lastMessages[0],
            createdAt: lastMessages[0].createdAt.toISOString(),
            updatedAt: lastMessages[0].updatedAt.toISOString()
          };
        }
        return {
          ...convo,
          agent: {
            key: convo.agent,
            displayName: ctx.services.agents.getAgentDisplayName(convo.agent),
            avatarUrl: ctx.services.agents.getAgentAvatarUrl(convo.agent)
          },
          createdAt: convo.createdAt.toISOString(),
          updatedAt: convo.updatedAt.toISOString(),
          lastMessage
        };
      })).then((conversations) => {
        return conversations.sort((a, b) => {
          const aLastMessageTime = a.lastMessage ? new Date(a.lastMessage.updatedAt).getTime() : new Date(a.updatedAt).getTime();
          const bLastMessageTime = b.lastMessage ? new Date(b.lastMessage.updatedAt).getTime() : new Date(b.updatedAt).getTime();
          return bLastMessageTime - aLastMessageTime;
        });
      });
    }
  },
  Subscription: {
    subscribeConversationEvents: {
      subscribe: async function* (_, { conversationId, agent, context }, ctx) {
        mustUser(ctx);
        let convo = await ctx.services.conversationService.findOrCreateConversation(
          ctx.user,
          conversationId,
          agent
        );
        if (context) {
          convo = await ctx.services.storage.updateConversation(convo.id, {
            context: JSON.stringify(context)
          });
        }
        let iterator = await ctx.services.agentService.subscribeConversationEvents(convo);
        while (true) {
          const { value, done } = await iterator.next();
          if (!done) {
            yield value;
          } else {
            break;
          }
        }
      }
    }
  }
};

// src/resolvers/index.ts
var resolvers = {
  Mutation: {
    ...authResolvers.Mutation,
    ...conversationResolvers.Mutation
  },
  Query: {
    ...authResolvers.Query,
    ...conversationResolvers.Query
  },
  Subscription: {
    ...authResolvers.Subscription,
    ...conversationResolvers.Subscription
  }
};
var resolvers_default = resolvers;

// src/backend.ts
var import_ws2 = require("ws");

// src/services/agent.service.ts
var import_shared = require("@convostack/shared");
var AgentService = class {
  constructor(storage, agents, conversationEventService) {
    this.storage = storage;
    this.agents = agents;
    this.conversationEventService = conversationEventService;
  }
  async subscribeConversationEvents(conversation) {
    return this.conversationEventService.subscribeToConversation(conversation);
  }
  async sendMessage(user, conversation, message) {
    const msg = await this.storage.createMessage({
      turn: await this.getNextTurnNumber(conversation.id),
      role: this.agents.getAgentHumanRole(conversation.agent),
      pending: false,
      content: message.content,
      userId: user.id,
      conversationId: conversation.id
    });
    await this.conversationEventService.publishMessage(msg);
    const history = await this.getHistory(msg.conversationId);
    this.queryAgent(conversation.agent, conversation, history, user, msg);
    return msg;
  }
  async getNextTurnNumber(conversationId) {
    const lastMessage = await this.storage.findMessages({
      conversationId
    }, {
      turn: "desc"
    }, 0, 1);
    if (!lastMessage || lastMessage.length < 1) {
      return 1;
    }
    return lastMessage[0].turn + 1;
  }
  async getHistory(conversationId, mostRecentFirst = false, skip = 0, take = 1e3) {
    const msgs = await this.storage.findMessages({
      conversationId
    }, {
      turn: mostRecentFirst ? "desc" : "asc"
    }, skip, take);
    if (!msgs) {
      return [];
    }
    return msgs;
  }
  async queryAgent(agentKey, conversation, history, user, message) {
    try {
      const ces = this.conversationEventService;
      const agentResponse = await this.agents.getAgent(agentKey).reply({
        getContextArgs() {
          return conversation.context ? JSON.parse(conversation.context) : {};
        },
        getHistory() {
          return history;
        },
        getUser() {
          return user;
        },
        getHumanMessage() {
          return message;
        }
      }, {
        onMessagePart(data) {
          ces.publishConversationEvent(
            message.conversationId,
            {
              kind: import_shared.CONVERSATION_EVENT_KIND_MESSAGE_PART,
              payload: {
                chunk: data.contentChunk
              }
            },
            true
          );
        }
      });
      const respMessage = await this.storage.createMessage({
        content: agentResponse.content,
        conversationId: message.conversationId,
        pending: false,
        role: this.agents.getAgentAIRole(agentKey),
        turn: await this.getNextTurnNumber(message.conversationId)
      });
      await this.conversationEventService.publishConversationEvent(
        message.conversationId,
        {
          kind: import_shared.CONVERSATION_EVENT_KIND_MESSAGE,
          payload: respMessage
        },
        false
      );
    } catch (error) {
      console.log("agent llm error", error);
      throw new Error(error);
    }
  }
};

// src/services/conversation.service.ts
var ConversationService = class {
  constructor(storage, agents) {
    this.storage = storage;
    this.agents = agents;
  }
  async mustFindConversation(user, conversationId) {
    let convo;
    if (conversationId) {
      convo = await this.storage.findConversation({
        id: conversationId
      });
      if (!convo) {
        throw new Error("Conversation not found");
      }
      if (convo.userId !== user.id) {
        throw new Error("Conversation access forbidden");
      }
    }
    return convo;
  }
  async findOrCreateConversation(user, conversationId, agentKey) {
    let convo;
    if (conversationId) {
      convo = await this.storage.findConversation({
        id: conversationId
      });
      if (!convo) {
        throw new Error("Conversation not found");
      }
      if (convo.userId !== user.id) {
        throw new Error("Conversation access forbidden");
      }
    } else {
      let primer = "";
      if (!agentKey) {
        agentKey = this.agents.getDefaultAgentKey();
      }
      primer = this.agents.getAgentPrimer(agentKey);
      if (!primer) {
        primer = null;
      }
      convo = await this.storage.createConversation({
        title: this.agents.getAgentDisplayName(agentKey),
        agent: agentKey,
        primer,
        userId: user.id
      });
    }
    return convo;
  }
};

// src/services/conversation-event.service.ts
var import_graphql_subscriptions = require("graphql-subscriptions");
var LRU = __toESM(require("lru-cache"));
var import_shared2 = require("@convostack/shared");
var ConversationEventService = class {
  constructor(storage, opts) {
    this.storage = storage;
    if (opts == null ? void 0 : opts.cachePrefix) {
      this.cachePrefix = opts.cachePrefix;
    } else {
      this.cachePrefix = "c_conv_events_";
    }
    if (opts == null ? void 0 : opts.pubSubChannelPrefix) {
      this.pubSubChannelPrefix = opts.pubSubChannelPrefix;
    } else {
      this.pubSubChannelPrefix = "ps_conv_events_";
    }
    if (opts == null ? void 0 : opts.pubSubEngine) {
      this.pubSub = opts.pubSubEngine;
    } else {
      this.pubSub = new import_graphql_subscriptions.PubSub();
    }
    if (opts == null ? void 0 : opts.cache) {
      this.cache = opts.cache;
    } else {
      const lru = new LRU.LRUCache({
        max: 1e3
      });
      this.cache = {
        get: async (key) => {
          return lru.get(key);
        },
        set: async (key, value) => {
          lru.set(key, value);
        }
      };
    }
  }
  async getConversationEvents(conversationId) {
    const conversationEventsJson = await this.cache.get(
      `${this.cachePrefix}${conversationId}`
    );
    if (conversationEventsJson) {
      return JSON.parse(conversationEventsJson);
    }
    return null;
  }
  async setConversationEvents(conversationId, conversationEvents) {
    await this.cache.set(
      `${this.cachePrefix}${conversationId}`,
      JSON.stringify(conversationEvents)
    );
  }
  async loadConversationMessages(conversation) {
    const messages = await this.storage.findMessages({ conversationId: conversation.id }, { turn: "asc" });
    const conversationEvents = messages.map(
      (message) => this.messageToConversationEvent(message)
    );
    conversationEvents.unshift({
      kind: import_shared2.CONVERSATION_EVENT_KIND_CONVERSATION_METADATA,
      payload: conversation
    });
    await this.setConversationEvents(conversation.id, conversationEvents);
    return conversationEvents;
  }
  messageToConversationEvent(message) {
    return {
      kind: import_shared2.CONVERSATION_EVENT_KIND_MESSAGE,
      payload: message
    };
  }
  async publishMessage(message) {
    const conversationEvent = this.messageToConversationEvent(message);
    await this.publishConversationEvent(
      message.conversationId,
      conversationEvent,
      false
    );
  }
  async publishConversationEvent(conversationId, conversationEvent, ephemeral) {
    await this.pubSub.publish(`${this.pubSubChannelPrefix}${conversationId}`, {
      conversationEvent
    });
    if (ephemeral) {
      return;
    }
    const conversationEvents = await this.getConversationEvents(conversationId);
    if (conversationEvents) {
      conversationEvents.push(conversationEvent);
      await this.setConversationEvents(conversationId, conversationEvents);
    }
  }
  async subscribeToConversation(conversation) {
    let conversationEvents = await this.getConversationEvents(conversation.id);
    if (!conversationEvents) {
      conversationEvents = await this.loadConversationMessages(conversation);
    }
    const iterator = this.pubSub.asyncIterator(
      `${this.pubSubChannelPrefix}${conversation.id}`
    );
    return async function* gen() {
      for (const event of conversationEvents) {
        yield { subscribeConversationEvents: event };
      }
      while (true) {
        const { value, done } = await iterator.next();
        if (!done) {
          yield { subscribeConversationEvents: value.conversationEvent };
        } else {
          break;
        }
      }
    }();
  }
};

// src/services/index.ts
var ConvoStackServices = class {
  constructor(config) {
    this.config = config;
    this.auth = config.auth;
    this.storage = config.storage;
    this.agents = config.agents;
    this.conversationEventService = new ConversationEventService(this.storage, this.config.conversationEventServiceOptions);
    this.agentService = new AgentService(this.storage, this.config.agents, this.conversationEventService);
    this.conversationService = new ConversationService(this.storage, this.config.agents);
  }
};

// src/backend.ts
var typeDefs = import_apollo_server_express.gql`
    ${(0, import_fs.readFileSync)((0, import_path.join)(__dirname, "schema.graphql"), "utf8")}
`;
var schema = (0, import_schema.makeExecutableSchema)({
  typeDefs,
  resolvers: resolvers_default
});
var ConvoStackBackendExpress = class {
  constructor(config) {
    this.config = config;
    this.services = new ConvoStackServices(config);
  }
  getCleanBasePath() {
    let basePath = this.config.basePath;
    if (!basePath) {
      basePath = "/";
    }
    if (!basePath.endsWith("/")) {
      basePath += "/";
    }
    if (!basePath.startsWith("/")) {
      basePath = "/" + basePath;
    }
    return basePath;
  }
  async init(app, httpServer, apolloServerOptions = {}) {
    const basePath = this.getCleanBasePath();
    const server = new import_apollo_server_express.ApolloServer({
      ...apolloServerOptions,
      schema,
      cache: "bounded",
      context: async ({ req }) => {
        const authCtx = await this.config.auth.getGQLAuthContextHTTP(req);
        return { ...authCtx, services: this.services, req };
      }
    });
    await server.start();
    server.applyMiddleware({ app, path: basePath + "graphql" });
    (0, import_ws.useServer)({
      schema,
      context: async ({ connectionParams }) => {
        const authCtx = await this.config.auth.getGQLAuthContextWS(connectionParams);
        return { ...authCtx, services: this.services, connectionParams };
      }
    }, new import_ws2.WebSocketServer({
      // This is the `httpServer` we created in a previous step.
      server: httpServer,
      // Pass a different path here if app.use
      // serves expressMiddleware at a different path
      path: basePath + "graphql"
    }));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ConvoStackBackendExpress
});
