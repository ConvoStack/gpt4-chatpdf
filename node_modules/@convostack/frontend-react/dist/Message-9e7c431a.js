import { m as Ge, v as mi, w as or, j as Ee } from "./index-90257461.js";
import je from "react";
import "react-dom";
const it = ["http", "https", "mailto", "tel"];
function gi(e) {
  const n = (e || "").trim(), t = n.charAt(0);
  if (t === "#" || t === "/")
    return n;
  const r = n.indexOf(":");
  if (r === -1)
    return n;
  let i = -1;
  for (; ++i < it.length; ) {
    const l = it[i];
    if (r === l.length && n.slice(0, l.length).toLowerCase() === l)
      return n;
  }
  return i = n.indexOf("?"), i !== -1 && r > i || (i = n.indexOf("#"), i !== -1 && r > i) ? n : "javascript:void(0)";
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var di = function(n) {
  return n != null && n.constructor != null && typeof n.constructor.isBuffer == "function" && n.constructor.isBuffer(n);
};
const ur = /* @__PURE__ */ Ge(di);
function Qe(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? lt(e.position) : "start" in e || "end" in e ? lt(e) : "line" in e || "column" in e ? Ln(e) : "";
}
function Ln(e) {
  return ot(e && e.line) + ":" + ot(e && e.column);
}
function lt(e) {
  return Ln(e && e.start) + "-" + Ln(e && e.end);
}
function ot(e) {
  return e && typeof e == "number" ? e : 1;
}
class ke extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(n, t, r) {
    const i = [null, null];
    let l = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    if (super(), typeof t == "string" && (r = t, t = void 0), typeof r == "string") {
      const o = r.indexOf(":");
      o === -1 ? i[1] = r : (i[0] = r.slice(0, o), i[1] = r.slice(o + 1));
    }
    t && ("type" in t || "position" in t ? t.position && (l = t.position) : "start" in t || "end" in t ? l = t : ("line" in t || "column" in t) && (l.start = t)), this.name = Qe(t) || "1:1", this.message = typeof n == "object" ? n.message : n, this.stack = "", typeof n == "object" && n.stack && (this.stack = n.stack), this.reason = this.message, this.fatal, this.line = l.start.line, this.column = l.start.column, this.position = l, this.source = i[0], this.ruleId = i[1], this.file, this.actual, this.expected, this.url, this.note;
  }
}
ke.prototype.file = "";
ke.prototype.name = "";
ke.prototype.reason = "";
ke.prototype.message = "";
ke.prototype.stack = "";
ke.prototype.fatal = null;
ke.prototype.column = null;
ke.prototype.line = null;
ke.prototype.source = null;
ke.prototype.ruleId = null;
ke.prototype.position = null;
const Ae = { basename: yi, dirname: xi, extname: ki, join: bi, sep: "/" };
function yi(e, n) {
  if (n !== void 0 && typeof n != "string")
    throw new TypeError('"ext" argument must be a string');
  Ke(e);
  let t = 0, r = -1, i = e.length, l;
  if (n === void 0 || n.length === 0 || n.length > e.length) {
    for (; i--; )
      if (e.charCodeAt(i) === 47) {
        if (l) {
          t = i + 1;
          break;
        }
      } else
        r < 0 && (l = !0, r = i + 1);
    return r < 0 ? "" : e.slice(t, r);
  }
  if (n === e)
    return "";
  let o = -1, u = n.length - 1;
  for (; i--; )
    if (e.charCodeAt(i) === 47) {
      if (l) {
        t = i + 1;
        break;
      }
    } else
      o < 0 && (l = !0, o = i + 1), u > -1 && (e.charCodeAt(i) === n.charCodeAt(u--) ? u < 0 && (r = i) : (u = -1, r = o));
  return t === r ? r = o : r < 0 && (r = e.length), e.slice(t, r);
}
function xi(e) {
  if (Ke(e), e.length === 0)
    return ".";
  let n = -1, t = e.length, r;
  for (; --t; )
    if (e.charCodeAt(t) === 47) {
      if (r) {
        n = t;
        break;
      }
    } else
      r || (r = !0);
  return n < 0 ? e.charCodeAt(0) === 47 ? "/" : "." : n === 1 && e.charCodeAt(0) === 47 ? "//" : e.slice(0, n);
}
function ki(e) {
  Ke(e);
  let n = e.length, t = -1, r = 0, i = -1, l = 0, o;
  for (; n--; ) {
    const u = e.charCodeAt(n);
    if (u === 47) {
      if (o) {
        r = n + 1;
        break;
      }
      continue;
    }
    t < 0 && (o = !0, t = n + 1), u === 46 ? i < 0 ? i = n : l !== 1 && (l = 1) : i > -1 && (l = -1);
  }
  return i < 0 || t < 0 || // We saw a non-dot character immediately before the dot.
  l === 0 || // The (right-most) trimmed path component is exactly `..`.
  l === 1 && i === t - 1 && i === r + 1 ? "" : e.slice(i, t);
}
function bi(...e) {
  let n = -1, t;
  for (; ++n < e.length; )
    Ke(e[n]), e[n] && (t = t === void 0 ? e[n] : t + "/" + e[n]);
  return t === void 0 ? "." : wi(t);
}
function wi(e) {
  Ke(e);
  const n = e.charCodeAt(0) === 47;
  let t = Si(e, !n);
  return t.length === 0 && !n && (t = "."), t.length > 0 && e.charCodeAt(e.length - 1) === 47 && (t += "/"), n ? "/" + t : t;
}
function Si(e, n) {
  let t = "", r = 0, i = -1, l = 0, o = -1, u, a;
  for (; ++o <= e.length; ) {
    if (o < e.length)
      u = e.charCodeAt(o);
    else {
      if (u === 47)
        break;
      u = 47;
    }
    if (u === 47) {
      if (!(i === o - 1 || l === 1))
        if (i !== o - 1 && l === 2) {
          if (t.length < 2 || r !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
            if (t.length > 2) {
              if (a = t.lastIndexOf("/"), a !== t.length - 1) {
                a < 0 ? (t = "", r = 0) : (t = t.slice(0, a), r = t.length - 1 - t.lastIndexOf("/")), i = o, l = 0;
                continue;
              }
            } else if (t.length > 0) {
              t = "", r = 0, i = o, l = 0;
              continue;
            }
          }
          n && (t = t.length > 0 ? t + "/.." : "..", r = 2);
        } else
          t.length > 0 ? t += "/" + e.slice(i + 1, o) : t = e.slice(i + 1, o), r = o - i - 1;
      i = o, l = 0;
    } else
      u === 46 && l > -1 ? l++ : l = -1;
  }
  return t;
}
function Ke(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const Ci = { cwd: Ei };
function Ei() {
  return "/";
}
function Rn(e) {
  return e !== null && typeof e == "object" && // @ts-expect-error: indexable.
  e.href && // @ts-expect-error: indexable.
  e.origin;
}
function Ai(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Rn(e)) {
    const n = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw n.code = "ERR_INVALID_ARG_TYPE", n;
  }
  if (e.protocol !== "file:") {
    const n = new TypeError("The URL must be of scheme file");
    throw n.code = "ERR_INVALID_URL_SCHEME", n;
  }
  return vi(e);
}
function vi(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const n = e.pathname;
  let t = -1;
  for (; ++t < n.length; )
    if (n.charCodeAt(t) === 37 && n.charCodeAt(t + 1) === 50) {
      const r = n.charCodeAt(t + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(n);
}
const mn = ["history", "path", "basename", "stem", "extname", "dirname"];
class ar {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(n) {
    let t;
    n ? typeof n == "string" || Ti(n) ? t = { value: n } : Rn(n) ? t = { path: n } : t = n : t = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = Ci.cwd(), this.value, this.stored, this.result, this.map;
    let r = -1;
    for (; ++r < mn.length; ) {
      const l = mn[r];
      l in t && t[l] !== void 0 && t[l] !== null && (this[l] = l === "history" ? [...t[l]] : t[l]);
    }
    let i;
    for (i in t)
      mn.includes(i) || (this[i] = t[i]);
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(n) {
    Rn(n) && (n = Ai(n)), dn(n, "path"), this.path !== n && this.history.push(n);
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path == "string" ? Ae.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(n) {
    ut(this.basename, "dirname"), this.path = Ae.join(n || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path == "string" ? Ae.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(n) {
    dn(n, "basename"), gn(n, "basename"), this.path = Ae.join(this.dirname || "", n);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path == "string" ? Ae.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(n) {
    if (gn(n, "extname"), ut(this.dirname, "extname"), n) {
      if (n.charCodeAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (n.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Ae.join(this.dirname, this.stem + (n || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path == "string" ? Ae.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(n) {
    dn(n, "stem"), gn(n, "stem"), this.path = Ae.join(this.dirname || "", n + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(n) {
    return (this.value || "").toString(n || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(n, t, r) {
    const i = new ke(n, t, r);
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(n, t, r) {
    const i = this.message(n, t, r);
    return i.fatal = null, i;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(n, t, r) {
    const i = this.message(n, t, r);
    throw i.fatal = !0, i;
  }
}
function gn(e, n) {
  if (e && e.includes(Ae.sep))
    throw new Error(
      "`" + n + "` cannot be a path: did not expect `" + Ae.sep + "`"
    );
}
function dn(e, n) {
  if (!e)
    throw new Error("`" + n + "` cannot be empty");
}
function ut(e, n) {
  if (!e)
    throw new Error("Setting `" + n + "` requires `path` to be set too");
}
function Ti(e) {
  return ur(e);
}
function at(e) {
  if (e)
    throw e;
}
var rn = Object.prototype.hasOwnProperty, sr = Object.prototype.toString, st = Object.defineProperty, ct = Object.getOwnPropertyDescriptor, ft = function(n) {
  return typeof Array.isArray == "function" ? Array.isArray(n) : sr.call(n) === "[object Array]";
}, pt = function(n) {
  if (!n || sr.call(n) !== "[object Object]")
    return !1;
  var t = rn.call(n, "constructor"), r = n.constructor && n.constructor.prototype && rn.call(n.constructor.prototype, "isPrototypeOf");
  if (n.constructor && !t && !r)
    return !1;
  var i;
  for (i in n)
    ;
  return typeof i > "u" || rn.call(n, i);
}, ht = function(n, t) {
  st && t.name === "__proto__" ? st(n, t.name, {
    enumerable: !0,
    configurable: !0,
    value: t.newValue,
    writable: !0
  }) : n[t.name] = t.newValue;
}, mt = function(n, t) {
  if (t === "__proto__")
    if (rn.call(n, t)) {
      if (ct)
        return ct(n, t).value;
    } else
      return;
  return n[t];
}, Pi = function e() {
  var n, t, r, i, l, o, u = arguments[0], a = 1, c = arguments.length, s = !1;
  for (typeof u == "boolean" && (s = u, u = arguments[1] || {}, a = 2), (u == null || typeof u != "object" && typeof u != "function") && (u = {}); a < c; ++a)
    if (n = arguments[a], n != null)
      for (t in n)
        r = mt(u, t), i = mt(n, t), u !== i && (s && i && (pt(i) || (l = ft(i))) ? (l ? (l = !1, o = r && ft(r) ? r : []) : o = r && pt(r) ? r : {}, ht(u, { name: t, newValue: e(s, o, i) })) : typeof i < "u" && ht(u, { name: t, newValue: i }));
  return u;
};
const gt = /* @__PURE__ */ Ge(Pi);
function zn(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const n = Object.getPrototypeOf(e);
  return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Fi() {
  const e = [], n = { run: t, use: r };
  return n;
  function t(...i) {
    let l = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    u(null, ...i);
    function u(a, ...c) {
      const s = e[++l];
      let f = -1;
      if (a) {
        o(a);
        return;
      }
      for (; ++f < i.length; )
        (c[f] === null || c[f] === void 0) && (c[f] = i[f]);
      i = c, s ? Ii(s, u)(...c) : o(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), n;
  }
}
function Ii(e, n) {
  let t;
  return r;
  function r(...o) {
    const u = e.length > o.length;
    let a;
    u && o.push(i);
    try {
      a = e.apply(this, o);
    } catch (c) {
      const s = (
        /** @type {Error} */
        c
      );
      if (u && t)
        throw s;
      return i(s);
    }
    u || (a instanceof Promise ? a.then(l, i) : a instanceof Error ? i(a) : l(a));
  }
  function i(o, ...u) {
    t || (t = !0, n(o, ...u));
  }
  function l(o) {
    i(null, o);
  }
}
const Oi = fr().freeze(), cr = {}.hasOwnProperty;
function fr() {
  const e = Fi(), n = [];
  let t = {}, r, i = -1;
  return l.data = o, l.Parser = void 0, l.Compiler = void 0, l.freeze = u, l.attachers = n, l.use = a, l.parse = c, l.stringify = s, l.run = f, l.runSync = x, l.process = d, l.processSync = h, l;
  function l() {
    const g = fr();
    let y = -1;
    for (; ++y < n.length; )
      g.use(...n[y]);
    return g.data(gt(!0, {}, t)), g;
  }
  function o(g, y) {
    return typeof g == "string" ? arguments.length === 2 ? (kn("data", r), t[g] = y, l) : cr.call(t, g) && t[g] || null : g ? (kn("data", r), t = g, l) : t;
  }
  function u() {
    if (r)
      return l;
    for (; ++i < n.length; ) {
      const [g, ...y] = n[i];
      if (y[0] === !1)
        continue;
      y[0] === !0 && (y[0] = void 0);
      const k = g.call(l, ...y);
      typeof k == "function" && e.use(k);
    }
    return r = !0, i = Number.POSITIVE_INFINITY, l;
  }
  function a(g, ...y) {
    let k;
    if (kn("use", r), g != null)
      if (typeof g == "function")
        F(g, ...y);
      else if (typeof g == "object")
        Array.isArray(g) ? O(g) : A(g);
      else
        throw new TypeError("Expected usable value, not `" + g + "`");
    return k && (t.settings = Object.assign(t.settings || {}, k)), l;
    function P(w) {
      if (typeof w == "function")
        F(w);
      else if (typeof w == "object")
        if (Array.isArray(w)) {
          const [I, ...j] = w;
          F(I, ...j);
        } else
          A(w);
      else
        throw new TypeError("Expected usable value, not `" + w + "`");
    }
    function A(w) {
      O(w.plugins), w.settings && (k = Object.assign(k || {}, w.settings));
    }
    function O(w) {
      let I = -1;
      if (w != null)
        if (Array.isArray(w))
          for (; ++I < w.length; ) {
            const j = w[I];
            P(j);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + w + "`");
    }
    function F(w, I) {
      let j = -1, W;
      for (; ++j < n.length; )
        if (n[j][0] === w) {
          W = n[j];
          break;
        }
      W ? (zn(W[1]) && zn(I) && (I = gt(!0, W[1], I)), W[1] = I) : n.push([...arguments]);
    }
  }
  function c(g) {
    l.freeze();
    const y = Ye(g), k = l.Parser;
    return yn("parse", k), dt(k, "parse") ? new k(String(y), y).parse() : k(String(y), y);
  }
  function s(g, y) {
    l.freeze();
    const k = Ye(y), P = l.Compiler;
    return xn("stringify", P), yt(g), dt(P, "compile") ? new P(g, k).compile() : P(g, k);
  }
  function f(g, y, k) {
    if (yt(g), l.freeze(), !k && typeof y == "function" && (k = y, y = void 0), !k)
      return new Promise(P);
    P(null, k);
    function P(A, O) {
      e.run(g, Ye(y), F);
      function F(w, I, j) {
        I = I || g, w ? O(w) : A ? A(I) : k(null, I, j);
      }
    }
  }
  function x(g, y) {
    let k, P;
    return l.run(g, y, A), xt("runSync", "run", P), k;
    function A(O, F) {
      at(O), k = F, P = !0;
    }
  }
  function d(g, y) {
    if (l.freeze(), yn("process", l.Parser), xn("process", l.Compiler), !y)
      return new Promise(k);
    k(null, y);
    function k(P, A) {
      const O = Ye(g);
      l.run(l.parse(O), O, (w, I, j) => {
        if (w || !I || !j)
          F(w);
        else {
          const W = l.stringify(I, j);
          W == null || (Ri(W) ? j.value = W : j.result = W), F(w, j);
        }
      });
      function F(w, I) {
        w || !I ? A(w) : P ? P(I) : y(null, I);
      }
    }
  }
  function h(g) {
    let y;
    l.freeze(), yn("processSync", l.Parser), xn("processSync", l.Compiler);
    const k = Ye(g);
    return l.process(k, P), xt("processSync", "process", y), k;
    function P(A) {
      y = !0, at(A);
    }
  }
}
function dt(e, n) {
  return typeof e == "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  e.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (Di(e.prototype) || n in e.prototype);
}
function Di(e) {
  let n;
  for (n in e)
    if (cr.call(e, n))
      return !0;
  return !1;
}
function yn(e, n) {
  if (typeof n != "function")
    throw new TypeError("Cannot `" + e + "` without `Parser`");
}
function xn(e, n) {
  if (typeof n != "function")
    throw new TypeError("Cannot `" + e + "` without `Compiler`");
}
function kn(e, n) {
  if (n)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function yt(e) {
  if (!zn(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function xt(e, n, t) {
  if (!t)
    throw new Error(
      "`" + e + "` finished async. Use `" + n + "` instead"
    );
}
function Ye(e) {
  return Li(e) ? e : new ar(e);
}
function Li(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function Ri(e) {
  return typeof e == "string" || ur(e);
}
const zi = {};
function _i(e, n) {
  const t = n || zi, r = typeof t.includeImageAlt == "boolean" ? t.includeImageAlt : !0, i = typeof t.includeHtml == "boolean" ? t.includeHtml : !0;
  return pr(e, r, i);
}
function pr(e, n, t) {
  if (Mi(e)) {
    if ("value" in e)
      return e.type === "html" && !t ? "" : e.value;
    if (n && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return kt(e.children, n, t);
  }
  return Array.isArray(e) ? kt(e, n, t) : "";
}
function kt(e, n, t) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = pr(e[i], n, t);
  return r.join("");
}
function Mi(e) {
  return !!(e && typeof e == "object");
}
function ye(e, n, t, r) {
  const i = e.length;
  let l = 0, o;
  if (n < 0 ? n = -n > i ? 0 : i + n : n = n > i ? i : n, t = t > 0 ? t : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(n, t), [].splice.apply(e, o);
  else
    for (t && [].splice.apply(e, [n, t]); l < r.length; )
      o = r.slice(l, l + 1e4), o.unshift(n, 0), [].splice.apply(e, o), l += 1e4, n += 1e4;
}
function xe(e, n) {
  return e.length > 0 ? (ye(e, e.length, 0, n), e) : n;
}
const bt = {}.hasOwnProperty;
function hr(e) {
  const n = {};
  let t = -1;
  for (; ++t < e.length; )
    Bi(n, e[t]);
  return n;
}
function Bi(e, n) {
  let t;
  for (t in n) {
    const i = (bt.call(e, t) ? e[t] : void 0) || (e[t] = {}), l = n[t];
    let o;
    for (o in l) {
      bt.call(i, o) || (i[o] = []);
      const u = l[o];
      ji(
        // @ts-expect-error Looks like a list.
        i[o],
        Array.isArray(u) ? u : u ? [u] : []
      );
    }
  }
}
function ji(e, n) {
  let t = -1;
  const r = [];
  for (; ++t < n.length; )
    (n[t].add === "after" ? e : r).push(n[t]);
  ye(e, 0, 0, r);
}
const Ni = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, me = De(/[A-Za-z]/), _n = De(/\d/), Hi = De(/[\dA-Fa-f]/), pe = De(/[\dA-Za-z]/), Ui = De(/[!-/:-@[-`{-~]/), wt = De(/[#-'*+\--9=?A-Z^-~]/);
function on(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
function re(e) {
  return e !== null && (e < 0 || e === 32);
}
function z(e) {
  return e !== null && e < -2;
}
function ne(e) {
  return e === -2 || e === -1 || e === 32;
}
const _e = De(/\s/), sn = De(Ni);
function De(e) {
  return n;
  function n(t) {
    return t !== null && e.test(String.fromCharCode(t));
  }
}
function X(e, n, t, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let l = 0;
  return o;
  function o(a) {
    return ne(a) ? (e.enter(t), u(a)) : n(a);
  }
  function u(a) {
    return ne(a) && l++ < i ? (e.consume(a), u) : (e.exit(t), n(a));
  }
}
const $i = {
  tokenize: qi
};
function qi(e) {
  const n = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let t;
  return n;
  function r(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), X(e, n, "linePrefix");
  }
  function i(u) {
    return e.enter("paragraph"), l(u);
  }
  function l(u) {
    const a = e.enter("chunkText", {
      contentType: "text",
      previous: t
    });
    return t && (t.next = a), t = a, o(u);
  }
  function o(u) {
    if (u === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(u);
      return;
    }
    return z(u) ? (e.consume(u), e.exit("chunkText"), l) : (e.consume(u), o);
  }
}
const Vi = {
  tokenize: Wi
}, St = {
  tokenize: Yi
};
function Wi(e) {
  const n = this, t = [];
  let r = 0, i, l, o;
  return u;
  function u(A) {
    if (r < t.length) {
      const O = t[r];
      return n.containerState = O[1], e.attempt(
        O[0].continuation,
        a,
        c
      )(A);
    }
    return c(A);
  }
  function a(A) {
    if (r++, n.containerState._closeFlow) {
      n.containerState._closeFlow = void 0, i && P();
      const O = n.events.length;
      let F = O, w;
      for (; F--; )
        if (n.events[F][0] === "exit" && n.events[F][1].type === "chunkFlow") {
          w = n.events[F][1].end;
          break;
        }
      k(r);
      let I = O;
      for (; I < n.events.length; )
        n.events[I][1].end = Object.assign({}, w), I++;
      return ye(
        n.events,
        F + 1,
        0,
        n.events.slice(O)
      ), n.events.length = I, c(A);
    }
    return u(A);
  }
  function c(A) {
    if (r === t.length) {
      if (!i)
        return x(A);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return h(A);
      n.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return n.containerState = {}, e.check(
      St,
      s,
      f
    )(A);
  }
  function s(A) {
    return i && P(), k(r), x(A);
  }
  function f(A) {
    return n.parser.lazy[n.now().line] = r !== t.length, o = n.now().offset, h(A);
  }
  function x(A) {
    return n.containerState = {}, e.attempt(
      St,
      d,
      h
    )(A);
  }
  function d(A) {
    return r++, t.push([n.currentConstruct, n.containerState]), x(A);
  }
  function h(A) {
    if (A === null) {
      i && P(), k(0), e.consume(A);
      return;
    }
    return i = i || n.parser.flow(n.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: l,
      _tokenizer: i
    }), g(A);
  }
  function g(A) {
    if (A === null) {
      y(e.exit("chunkFlow"), !0), k(0), e.consume(A);
      return;
    }
    return z(A) ? (e.consume(A), y(e.exit("chunkFlow")), r = 0, n.interrupt = void 0, u) : (e.consume(A), g);
  }
  function y(A, O) {
    const F = n.sliceStream(A);
    if (O && F.push(null), A.previous = l, l && (l.next = A), l = A, i.defineSkip(A.start), i.write(F), n.parser.lazy[A.start.line]) {
      let w = i.events.length;
      for (; w--; )
        if (
          // The token starts before the line ending…
          i.events[w][1].start.offset < o && // …and either is not ended yet…
          (!i.events[w][1].end || // …or ends after it.
          i.events[w][1].end.offset > o)
        )
          return;
      const I = n.events.length;
      let j = I, W, b;
      for (; j--; )
        if (n.events[j][0] === "exit" && n.events[j][1].type === "chunkFlow") {
          if (W) {
            b = n.events[j][1].end;
            break;
          }
          W = !0;
        }
      for (k(r), w = I; w < n.events.length; )
        n.events[w][1].end = Object.assign({}, b), w++;
      ye(
        n.events,
        j + 1,
        0,
        n.events.slice(I)
      ), n.events.length = w;
    }
  }
  function k(A) {
    let O = t.length;
    for (; O-- > A; ) {
      const F = t[O];
      n.containerState = F[1], F[0].exit.call(n, e);
    }
    t.length = A;
  }
  function P() {
    i.write([null]), l = void 0, i = void 0, n.containerState._closeFlow = void 0;
  }
}
function Yi(e, n, t) {
  return X(
    e,
    e.attempt(this.parser.constructs.document, n, t),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function un(e) {
  if (e === null || re(e) || _e(e))
    return 1;
  if (sn(e))
    return 2;
}
function cn(e, n, t) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const l = e[i].resolveAll;
    l && !r.includes(l) && (n = l(n, t), r.push(l));
  }
  return n;
}
const Mn = {
  name: "attention",
  tokenize: Xi,
  resolveAll: Qi
};
function Qi(e, n) {
  let t = -1, r, i, l, o, u, a, c, s;
  for (; ++t < e.length; )
    if (e[t][0] === "enter" && e[t][1].type === "attentionSequence" && e[t][1]._close) {
      for (r = t; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        n.sliceSerialize(e[r][1]).charCodeAt(0) === n.sliceSerialize(e[t][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[t][1]._open) && (e[t][1].end.offset - e[t][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[t][1].end.offset - e[t][1].start.offset) % 3))
            continue;
          a = e[r][1].end.offset - e[r][1].start.offset > 1 && e[t][1].end.offset - e[t][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, e[r][1].end), x = Object.assign({}, e[t][1].start);
          Ct(f, -a), Ct(x, a), o = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, e[r][1].end)
          }, u = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[t][1].start),
            end: x
          }, l = {
            type: a > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[t][1].start)
          }, i = {
            type: a > 1 ? "strong" : "emphasis",
            start: Object.assign({}, o.start),
            end: Object.assign({}, u.end)
          }, e[r][1].end = Object.assign({}, o.start), e[t][1].start = Object.assign({}, u.end), c = [], e[r][1].end.offset - e[r][1].start.offset && (c = xe(c, [
            ["enter", e[r][1], n],
            ["exit", e[r][1], n]
          ])), c = xe(c, [
            ["enter", i, n],
            ["enter", o, n],
            ["exit", o, n],
            ["enter", l, n]
          ]), c = xe(
            c,
            cn(
              n.parser.constructs.insideSpan.null,
              e.slice(r + 1, t),
              n
            )
          ), c = xe(c, [
            ["exit", l, n],
            ["enter", u, n],
            ["exit", u, n],
            ["exit", i, n]
          ]), e[t][1].end.offset - e[t][1].start.offset ? (s = 2, c = xe(c, [
            ["enter", e[t][1], n],
            ["exit", e[t][1], n]
          ])) : s = 0, ye(e, r - 1, t - r + 3, c), t = r + c.length - s - 2;
          break;
        }
    }
  for (t = -1; ++t < e.length; )
    e[t][1].type === "attentionSequence" && (e[t][1].type = "data");
  return e;
}
function Xi(e, n) {
  const t = this.parser.constructs.attentionMarkers.null, r = this.previous, i = un(r);
  let l;
  return o;
  function o(a) {
    return e.enter("attentionSequence"), l = a, u(a);
  }
  function u(a) {
    if (a === l)
      return e.consume(a), u;
    const c = e.exit("attentionSequence"), s = un(a), f = !s || s === 2 && i || t.includes(a), x = !i || i === 2 && s || t.includes(r);
    return c._open = !!(l === 42 ? f : f && (i || !x)), c._close = !!(l === 42 ? x : x && (s || !f)), n(a);
  }
}
function Ct(e, n) {
  e.column += n, e.offset += n, e._bufferIndex += n;
}
const Gi = {
  name: "autolink",
  tokenize: Ki
};
function Ki(e, n, t) {
  let r = 1;
  return i;
  function i(h) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), l;
  }
  function l(h) {
    return me(h) ? (e.consume(h), o) : wt(h) ? c(h) : t(h);
  }
  function o(h) {
    return h === 43 || h === 45 || h === 46 || pe(h) ? u(h) : c(h);
  }
  function u(h) {
    return h === 58 ? (e.consume(h), a) : (h === 43 || h === 45 || h === 46 || pe(h)) && r++ < 32 ? (e.consume(h), u) : c(h);
  }
  function a(h) {
    return h === 62 ? (e.exit("autolinkProtocol"), d(h)) : h === null || h === 32 || h === 60 || on(h) ? t(h) : (e.consume(h), a);
  }
  function c(h) {
    return h === 64 ? (e.consume(h), r = 0, s) : wt(h) ? (e.consume(h), c) : t(h);
  }
  function s(h) {
    return pe(h) ? f(h) : t(h);
  }
  function f(h) {
    return h === 46 ? (e.consume(h), r = 0, s) : h === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", d(h)) : x(h);
  }
  function x(h) {
    return (h === 45 || pe(h)) && r++ < 63 ? (e.consume(h), h === 45 ? x : f) : t(h);
  }
  function d(h) {
    return e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), n;
  }
}
const Ze = {
  tokenize: Zi,
  partial: !0
};
function Zi(e, n, t) {
  return X(e, r, "linePrefix");
  function r(i) {
    return i === null || z(i) ? n(i) : t(i);
  }
}
const mr = {
  name: "blockQuote",
  tokenize: Ji,
  continuation: {
    tokenize: el
  },
  exit: nl
};
function Ji(e, n, t) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const u = r.containerState;
      return u.open || (e.enter("blockQuote", {
        _container: !0
      }), u.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(o), e.exit("blockQuoteMarker"), l;
    }
    return t(o);
  }
  function l(o) {
    return ne(o) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(o), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), n) : (e.exit("blockQuotePrefix"), n(o));
  }
}
function el(e, n, t) {
  return X(
    e,
    e.attempt(mr, n, t),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function nl(e) {
  e.exit("blockQuote");
}
const gr = {
  name: "characterEscape",
  tokenize: tl
};
function tl(e, n, t) {
  return r;
  function r(l) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(l), e.exit("escapeMarker"), i;
  }
  function i(l) {
    return Ui(l) ? (e.enter("characterEscapeValue"), e.consume(l), e.exit("characterEscapeValue"), e.exit("characterEscape"), n) : t(l);
  }
}
const Et = document.createElement("i");
function qn(e) {
  const n = "&" + e + ";";
  Et.innerHTML = n;
  const t = Et.textContent;
  return t.charCodeAt(t.length - 1) === 59 && e !== "semi" || t === n ? !1 : t;
}
const dr = {
  name: "characterReference",
  tokenize: rl
};
function rl(e, n, t) {
  const r = this;
  let i = 0, l, o;
  return u;
  function u(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), a;
  }
  function a(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), l = 31, o = pe, s(f));
  }
  function c(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), l = 6, o = Hi, s) : (e.enter("characterReferenceValue"), l = 7, o = _n, s(f));
  }
  function s(f) {
    let x;
    return f === 59 && i ? (x = e.exit("characterReferenceValue"), o === pe && !qn(r.sliceSerialize(x)) ? t(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), n)) : o(f) && i++ < l ? (e.consume(f), s) : t(f);
  }
}
const At = {
  name: "codeFenced",
  tokenize: il,
  concrete: !0
};
function il(e, n, t) {
  const r = this, i = {
    tokenize: F,
    partial: !0
  }, l = {
    tokenize: O,
    partial: !0
  }, o = this.events[this.events.length - 1], u = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0;
  let a = 0, c;
  return s;
  function s(w) {
    return e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c = w, f(w);
  }
  function f(w) {
    return w === c ? (e.consume(w), a++, f) : (e.exit("codeFencedFenceSequence"), a < 3 ? t(w) : X(e, x, "whitespace")(w));
  }
  function x(w) {
    return w === null || z(w) ? y(w) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), d(w));
  }
  function d(w) {
    return w === null || re(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), X(e, h, "whitespace")(w)) : w === 96 && w === c ? t(w) : (e.consume(w), d);
  }
  function h(w) {
    return w === null || z(w) ? y(w) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), g(w));
  }
  function g(w) {
    return w === null || z(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), y(w)) : w === 96 && w === c ? t(w) : (e.consume(w), g);
  }
  function y(w) {
    return e.exit("codeFencedFence"), r.interrupt ? n(w) : k(w);
  }
  function k(w) {
    return w === null ? A(w) : z(w) ? e.attempt(
      l,
      e.attempt(
        i,
        A,
        u ? X(
          e,
          k,
          "linePrefix",
          u + 1
        ) : k
      ),
      A
    )(w) : (e.enter("codeFlowValue"), P(w));
  }
  function P(w) {
    return w === null || z(w) ? (e.exit("codeFlowValue"), k(w)) : (e.consume(w), P);
  }
  function A(w) {
    return e.exit("codeFenced"), n(w);
  }
  function O(w, I, j) {
    const W = this;
    return b;
    function b(L) {
      return w.enter("lineEnding"), w.consume(L), w.exit("lineEnding"), v;
    }
    function v(L) {
      return W.parser.lazy[W.now().line] ? j(L) : I(L);
    }
  }
  function F(w, I, j) {
    let W = 0;
    return X(
      w,
      b,
      "linePrefix",
      this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
    function b(Y) {
      return w.enter("codeFencedFence"), w.enter("codeFencedFenceSequence"), v(Y);
    }
    function v(Y) {
      return Y === c ? (w.consume(Y), W++, v) : W < a ? j(Y) : (w.exit("codeFencedFenceSequence"), X(w, L, "whitespace")(Y));
    }
    function L(Y) {
      return Y === null || z(Y) ? (w.exit("codeFencedFence"), I(Y)) : j(Y);
    }
  }
}
const bn = {
  name: "codeIndented",
  tokenize: ol
}, ll = {
  tokenize: ul,
  partial: !0
};
function ol(e, n, t) {
  const r = this;
  return i;
  function i(c) {
    return e.enter("codeIndented"), X(e, l, "linePrefix", 4 + 1)(c);
  }
  function l(c) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? o(c) : t(c);
  }
  function o(c) {
    return c === null ? a(c) : z(c) ? e.attempt(ll, o, a)(c) : (e.enter("codeFlowValue"), u(c));
  }
  function u(c) {
    return c === null || z(c) ? (e.exit("codeFlowValue"), o(c)) : (e.consume(c), u);
  }
  function a(c) {
    return e.exit("codeIndented"), n(c);
  }
}
function ul(e, n, t) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? t(o) : z(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), i) : X(e, l, "linePrefix", 4 + 1)(o);
  }
  function l(o) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? n(o) : z(o) ? i(o) : t(o);
  }
}
const al = {
  name: "codeText",
  tokenize: fl,
  resolve: sl,
  previous: cl
};
function sl(e) {
  let n = e.length - 4, t = 3, r, i;
  if ((e[t][1].type === "lineEnding" || e[t][1].type === "space") && (e[n][1].type === "lineEnding" || e[n][1].type === "space")) {
    for (r = t; ++r < n; )
      if (e[r][1].type === "codeTextData") {
        e[t][1].type = "codeTextPadding", e[n][1].type = "codeTextPadding", t += 2, n -= 2;
        break;
      }
  }
  for (r = t - 1, n++; ++r <= n; )
    i === void 0 ? r !== n && e[r][1].type !== "lineEnding" && (i = r) : (r === n || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), n -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function cl(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function fl(e, n, t) {
  let r = 0, i, l;
  return o;
  function o(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), u(f);
  }
  function u(f) {
    return f === 96 ? (e.consume(f), r++, u) : (e.exit("codeTextSequence"), a(f));
  }
  function a(f) {
    return f === null ? t(f) : f === 96 ? (l = e.enter("codeTextSequence"), i = 0, s(f)) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), a) : z(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), a) : (e.enter("codeTextData"), c(f));
  }
  function c(f) {
    return f === null || f === 32 || f === 96 || z(f) ? (e.exit("codeTextData"), a(f)) : (e.consume(f), c);
  }
  function s(f) {
    return f === 96 ? (e.consume(f), i++, s) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), n(f)) : (l.type = "codeTextData", c(f));
  }
}
function yr(e) {
  const n = {};
  let t = -1, r, i, l, o, u, a, c;
  for (; ++t < e.length; ) {
    for (; t in n; )
      t = n[t];
    if (r = e[t], t && r[1].type === "chunkFlow" && e[t - 1][1].type === "listItemPrefix" && (a = r[1]._tokenizer.events, l = 0, l < a.length && a[l][1].type === "lineEndingBlank" && (l += 2), l < a.length && a[l][1].type === "content"))
      for (; ++l < a.length && a[l][1].type !== "content"; )
        a[l][1].type === "chunkText" && (a[l][1]._isInFirstContentOfListItem = !0, l++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(n, pl(e, t)), t = n[t], c = !0);
    else if (r[1]._container) {
      for (l = t, i = void 0; l-- && (o = e[l], o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
        o[0] === "enter" && (i && (e[i][1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = l);
      i && (r[1].end = Object.assign({}, e[i][1].start), u = e.slice(i, t), u.unshift(r), ye(e, i, t - i + 1, u));
    }
  }
  return !c;
}
function pl(e, n) {
  const t = e[n][1], r = e[n][2];
  let i = n - 1;
  const l = [], o = t._tokenizer || r.parser[t.contentType](t.start), u = o.events, a = [], c = {};
  let s, f, x = -1, d = t, h = 0, g = 0;
  const y = [g];
  for (; d; ) {
    for (; e[++i][1] !== d; )
      ;
    l.push(i), d._tokenizer || (s = r.sliceStream(d), d.next || s.push(null), f && o.defineSkip(d.start), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(s), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), f = d, d = d.next;
  }
  for (d = t; ++x < u.length; )
    // Find a void token that includes a break.
    u[x][0] === "exit" && u[x - 1][0] === "enter" && u[x][1].type === u[x - 1][1].type && u[x][1].start.line !== u[x][1].end.line && (g = x + 1, y.push(g), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (o.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : y.pop(), x = y.length; x--; ) {
    const k = u.slice(y[x], y[x + 1]), P = l.pop();
    a.unshift([P, P + k.length - 1]), ye(e, P, 2, k);
  }
  for (x = -1; ++x < a.length; )
    c[h + a[x][0]] = h + a[x][1], h += a[x][1] - a[x][0] - 1;
  return c;
}
const hl = {
  tokenize: dl,
  resolve: gl
}, ml = {
  tokenize: yl,
  partial: !0
};
function gl(e) {
  return yr(e), e;
}
function dl(e, n) {
  let t;
  return r;
  function r(u) {
    return e.enter("content"), t = e.enter("chunkContent", {
      contentType: "content"
    }), i(u);
  }
  function i(u) {
    return u === null ? l(u) : z(u) ? e.check(
      ml,
      o,
      l
    )(u) : (e.consume(u), i);
  }
  function l(u) {
    return e.exit("chunkContent"), e.exit("content"), n(u);
  }
  function o(u) {
    return e.consume(u), e.exit("chunkContent"), t.next = e.enter("chunkContent", {
      contentType: "content",
      previous: t
    }), t = t.next, i;
  }
}
function yl(e, n, t) {
  const r = this;
  return i;
  function i(o) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), X(e, l, "linePrefix");
  }
  function l(o) {
    if (o === null || z(o))
      return t(o);
    const u = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? n(o) : e.interrupt(r.parser.constructs.flow, t, n)(o);
  }
}
function xr(e, n, t, r, i, l, o, u, a) {
  const c = a || Number.POSITIVE_INFINITY;
  let s = 0;
  return f;
  function f(k) {
    return k === 60 ? (e.enter(r), e.enter(i), e.enter(l), e.consume(k), e.exit(l), x) : k === null || k === 41 || on(k) ? t(k) : (e.enter(r), e.enter(o), e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), g(k));
  }
  function x(k) {
    return k === 62 ? (e.enter(l), e.consume(k), e.exit(l), e.exit(i), e.exit(r), n) : (e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), d(k));
  }
  function d(k) {
    return k === 62 ? (e.exit("chunkString"), e.exit(u), x(k)) : k === null || k === 60 || z(k) ? t(k) : (e.consume(k), k === 92 ? h : d);
  }
  function h(k) {
    return k === 60 || k === 62 || k === 92 ? (e.consume(k), d) : d(k);
  }
  function g(k) {
    return k === 40 ? ++s > c ? t(k) : (e.consume(k), g) : k === 41 ? s-- ? (e.consume(k), g) : (e.exit("chunkString"), e.exit(u), e.exit(o), e.exit(r), n(k)) : k === null || re(k) ? s ? t(k) : (e.exit("chunkString"), e.exit(u), e.exit(o), e.exit(r), n(k)) : on(k) ? t(k) : (e.consume(k), k === 92 ? y : g);
  }
  function y(k) {
    return k === 40 || k === 41 || k === 92 ? (e.consume(k), g) : g(k);
  }
}
function kr(e, n, t, r, i, l) {
  const o = this;
  let u = 0, a;
  return c;
  function c(d) {
    return e.enter(r), e.enter(i), e.consume(d), e.exit(i), e.enter(l), s;
  }
  function s(d) {
    return d === null || d === 91 || d === 93 && !a || /* To do: remove in the future once we’ve switched from
     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
     * which doesn’t need this */
    /* Hidden footnotes hook */
    /* c8 ignore next 3 */
    d === 94 && !u && "_hiddenFootnoteSupport" in o.parser.constructs || u > 999 ? t(d) : d === 93 ? (e.exit(l), e.enter(i), e.consume(d), e.exit(i), e.exit(r), n) : z(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), s) : (e.enter("chunkString", {
      contentType: "string"
    }), f(d));
  }
  function f(d) {
    return d === null || d === 91 || d === 93 || z(d) || u++ > 999 ? (e.exit("chunkString"), s(d)) : (e.consume(d), a = a || !ne(d), d === 92 ? x : f);
  }
  function x(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), u++, f) : f(d);
  }
}
function br(e, n, t, r, i, l) {
  let o;
  return u;
  function u(x) {
    return e.enter(r), e.enter(i), e.consume(x), e.exit(i), o = x === 40 ? 41 : x, a;
  }
  function a(x) {
    return x === o ? (e.enter(i), e.consume(x), e.exit(i), e.exit(r), n) : (e.enter(l), c(x));
  }
  function c(x) {
    return x === o ? (e.exit(l), a(o)) : x === null ? t(x) : z(x) ? (e.enter("lineEnding"), e.consume(x), e.exit("lineEnding"), X(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), s(x));
  }
  function s(x) {
    return x === o || x === null || z(x) ? (e.exit("chunkString"), c(x)) : (e.consume(x), x === 92 ? f : s);
  }
  function f(x) {
    return x === o || x === 92 ? (e.consume(x), s) : s(x);
  }
}
function Xe(e, n) {
  let t;
  return r;
  function r(i) {
    return z(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), t = !0, r) : ne(i) ? X(
      e,
      r,
      t ? "linePrefix" : "lineSuffix"
    )(i) : n(i);
  }
}
function Se(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const xl = {
  name: "definition",
  tokenize: bl
}, kl = {
  tokenize: wl,
  partial: !0
};
function bl(e, n, t) {
  const r = this;
  let i;
  return l;
  function l(a) {
    return e.enter("definition"), kr.call(
      r,
      e,
      o,
      t,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(a);
  }
  function o(a) {
    return i = Se(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), a === 58 ? (e.enter("definitionMarker"), e.consume(a), e.exit("definitionMarker"), Xe(
      e,
      xr(
        e,
        e.attempt(
          kl,
          X(e, u, "whitespace"),
          X(e, u, "whitespace")
        ),
        t,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )
    )) : t(a);
  }
  function u(a) {
    return a === null || z(a) ? (e.exit("definition"), r.parser.defined.includes(i) || r.parser.defined.push(i), n(a)) : t(a);
  }
}
function wl(e, n, t) {
  return r;
  function r(o) {
    return re(o) ? Xe(e, i)(o) : t(o);
  }
  function i(o) {
    return o === 34 || o === 39 || o === 40 ? br(
      e,
      X(e, l, "whitespace"),
      t,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o) : t(o);
  }
  function l(o) {
    return o === null || z(o) ? n(o) : t(o);
  }
}
const Sl = {
  name: "hardBreakEscape",
  tokenize: Cl
};
function Cl(e, n, t) {
  return r;
  function r(l) {
    return e.enter("hardBreakEscape"), e.enter("escapeMarker"), e.consume(l), i;
  }
  function i(l) {
    return z(l) ? (e.exit("escapeMarker"), e.exit("hardBreakEscape"), n(l)) : t(l);
  }
}
const El = {
  name: "headingAtx",
  tokenize: vl,
  resolve: Al
};
function Al(e, n) {
  let t = e.length - 2, r = 3, i, l;
  return e[r][1].type === "whitespace" && (r += 2), t - 2 > r && e[t][1].type === "whitespace" && (t -= 2), e[t][1].type === "atxHeadingSequence" && (r === t - 1 || t - 4 > r && e[t - 2][1].type === "whitespace") && (t -= r + 1 === t ? 2 : 4), t > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[t][1].end
  }, l = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[t][1].end,
    // @ts-expect-error Constants are fine to assign.
    contentType: "text"
  }, ye(e, r, t - r + 1, [
    ["enter", i, n],
    ["enter", l, n],
    ["exit", l, n],
    ["exit", i, n]
  ])), e;
}
function vl(e, n, t) {
  const r = this;
  let i = 0;
  return l;
  function l(s) {
    return e.enter("atxHeading"), e.enter("atxHeadingSequence"), o(s);
  }
  function o(s) {
    return s === 35 && i++ < 6 ? (e.consume(s), o) : s === null || re(s) ? (e.exit("atxHeadingSequence"), r.interrupt ? n(s) : u(s)) : t(s);
  }
  function u(s) {
    return s === 35 ? (e.enter("atxHeadingSequence"), a(s)) : s === null || z(s) ? (e.exit("atxHeading"), n(s)) : ne(s) ? X(e, u, "whitespace")(s) : (e.enter("atxHeadingText"), c(s));
  }
  function a(s) {
    return s === 35 ? (e.consume(s), a) : (e.exit("atxHeadingSequence"), u(s));
  }
  function c(s) {
    return s === null || s === 35 || re(s) ? (e.exit("atxHeadingText"), u(s)) : (e.consume(s), c);
  }
}
const Tl = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], vt = ["pre", "script", "style", "textarea"], Pl = {
  name: "htmlFlow",
  tokenize: Ol,
  resolveTo: Il,
  concrete: !0
}, Fl = {
  tokenize: Dl,
  partial: !0
};
function Il(e) {
  let n = e.length;
  for (; n-- && !(e[n][0] === "enter" && e[n][1].type === "htmlFlow"); )
    ;
  return n > 1 && e[n - 2][1].type === "linePrefix" && (e[n][1].start = e[n - 2][1].start, e[n + 1][1].start = e[n - 2][1].start, e.splice(n - 2, 2)), e;
}
function Ol(e, n, t) {
  const r = this;
  let i, l, o, u, a;
  return c;
  function c(m) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(m), s;
  }
  function s(m) {
    return m === 33 ? (e.consume(m), f) : m === 47 ? (e.consume(m), h) : m === 63 ? (e.consume(m), i = 3, r.interrupt ? n : se) : me(m) ? (e.consume(m), o = String.fromCharCode(m), l = !0, g) : t(m);
  }
  function f(m) {
    return m === 45 ? (e.consume(m), i = 2, x) : m === 91 ? (e.consume(m), i = 5, o = "CDATA[", u = 0, d) : me(m) ? (e.consume(m), i = 4, r.interrupt ? n : se) : t(m);
  }
  function x(m) {
    return m === 45 ? (e.consume(m), r.interrupt ? n : se) : t(m);
  }
  function d(m) {
    return m === o.charCodeAt(u++) ? (e.consume(m), u === o.length ? r.interrupt ? n : v : d) : t(m);
  }
  function h(m) {
    return me(m) ? (e.consume(m), o = String.fromCharCode(m), g) : t(m);
  }
  function g(m) {
    return m === null || m === 47 || m === 62 || re(m) ? m !== 47 && l && vt.includes(o.toLowerCase()) ? (i = 1, r.interrupt ? n(m) : v(m)) : Tl.includes(o.toLowerCase()) ? (i = 6, m === 47 ? (e.consume(m), y) : r.interrupt ? n(m) : v(m)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? t(m) : l ? P(m) : k(m)) : m === 45 || pe(m) ? (e.consume(m), o += String.fromCharCode(m), g) : t(m);
  }
  function y(m) {
    return m === 62 ? (e.consume(m), r.interrupt ? n : v) : t(m);
  }
  function k(m) {
    return ne(m) ? (e.consume(m), k) : W(m);
  }
  function P(m) {
    return m === 47 ? (e.consume(m), W) : m === 58 || m === 95 || me(m) ? (e.consume(m), A) : ne(m) ? (e.consume(m), P) : W(m);
  }
  function A(m) {
    return m === 45 || m === 46 || m === 58 || m === 95 || pe(m) ? (e.consume(m), A) : O(m);
  }
  function O(m) {
    return m === 61 ? (e.consume(m), F) : ne(m) ? (e.consume(m), O) : P(m);
  }
  function F(m) {
    return m === null || m === 60 || m === 61 || m === 62 || m === 96 ? t(m) : m === 34 || m === 39 ? (e.consume(m), a = m, w) : ne(m) ? (e.consume(m), F) : (a = null, I(m));
  }
  function w(m) {
    return m === null || z(m) ? t(m) : m === a ? (e.consume(m), j) : (e.consume(m), w);
  }
  function I(m) {
    return m === null || m === 34 || m === 39 || m === 60 || m === 61 || m === 62 || m === 96 || re(m) ? O(m) : (e.consume(m), I);
  }
  function j(m) {
    return m === 47 || m === 62 || ne(m) ? P(m) : t(m);
  }
  function W(m) {
    return m === 62 ? (e.consume(m), b) : t(m);
  }
  function b(m) {
    return ne(m) ? (e.consume(m), b) : m === null || z(m) ? v(m) : t(m);
  }
  function v(m) {
    return m === 45 && i === 2 ? (e.consume(m), he) : m === 60 && i === 1 ? (e.consume(m), le) : m === 62 && i === 4 ? (e.consume(m), C) : m === 63 && i === 3 ? (e.consume(m), se) : m === 93 && i === 5 ? (e.consume(m), ie) : z(m) && (i === 6 || i === 7) ? e.check(
      Fl,
      C,
      L
    )(m) : m === null || z(m) ? L(m) : (e.consume(m), v);
  }
  function L(m) {
    return e.exit("htmlFlowData"), Y(m);
  }
  function Y(m) {
    return m === null ? p(m) : z(m) ? e.attempt(
      {
        tokenize: J,
        partial: !0
      },
      Y,
      p
    )(m) : (e.enter("htmlFlowData"), v(m));
  }
  function J(m, H, B) {
    return q;
    function q(_) {
      return m.enter("lineEnding"), m.consume(_), m.exit("lineEnding"), D;
    }
    function D(_) {
      return r.parser.lazy[r.now().line] ? B(_) : H(_);
    }
  }
  function he(m) {
    return m === 45 ? (e.consume(m), se) : v(m);
  }
  function le(m) {
    return m === 47 ? (e.consume(m), o = "", ae) : v(m);
  }
  function ae(m) {
    return m === 62 && vt.includes(o.toLowerCase()) ? (e.consume(m), C) : me(m) && o.length < 8 ? (e.consume(m), o += String.fromCharCode(m), ae) : v(m);
  }
  function ie(m) {
    return m === 93 ? (e.consume(m), se) : v(m);
  }
  function se(m) {
    return m === 62 ? (e.consume(m), C) : m === 45 && i === 2 ? (e.consume(m), se) : v(m);
  }
  function C(m) {
    return m === null || z(m) ? (e.exit("htmlFlowData"), p(m)) : (e.consume(m), C);
  }
  function p(m) {
    return e.exit("htmlFlow"), n(m);
  }
}
function Dl(e, n, t) {
  return r;
  function r(i) {
    return e.exit("htmlFlowData"), e.enter("lineEndingBlank"), e.consume(i), e.exit("lineEndingBlank"), e.attempt(Ze, n, t);
  }
}
const Ll = {
  name: "htmlText",
  tokenize: Rl
};
function Rl(e, n, t) {
  const r = this;
  let i, l, o, u;
  return a;
  function a(p) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(p), c;
  }
  function c(p) {
    return p === 33 ? (e.consume(p), s) : p === 47 ? (e.consume(p), I) : p === 63 ? (e.consume(p), F) : me(p) ? (e.consume(p), b) : t(p);
  }
  function s(p) {
    return p === 45 ? (e.consume(p), f) : p === 91 ? (e.consume(p), l = "CDATA[", o = 0, y) : me(p) ? (e.consume(p), O) : t(p);
  }
  function f(p) {
    return p === 45 ? (e.consume(p), x) : t(p);
  }
  function x(p) {
    return p === null || p === 62 ? t(p) : p === 45 ? (e.consume(p), d) : h(p);
  }
  function d(p) {
    return p === null || p === 62 ? t(p) : h(p);
  }
  function h(p) {
    return p === null ? t(p) : p === 45 ? (e.consume(p), g) : z(p) ? (u = h, ie(p)) : (e.consume(p), h);
  }
  function g(p) {
    return p === 45 ? (e.consume(p), C) : h(p);
  }
  function y(p) {
    return p === l.charCodeAt(o++) ? (e.consume(p), o === l.length ? k : y) : t(p);
  }
  function k(p) {
    return p === null ? t(p) : p === 93 ? (e.consume(p), P) : z(p) ? (u = k, ie(p)) : (e.consume(p), k);
  }
  function P(p) {
    return p === 93 ? (e.consume(p), A) : k(p);
  }
  function A(p) {
    return p === 62 ? C(p) : p === 93 ? (e.consume(p), A) : k(p);
  }
  function O(p) {
    return p === null || p === 62 ? C(p) : z(p) ? (u = O, ie(p)) : (e.consume(p), O);
  }
  function F(p) {
    return p === null ? t(p) : p === 63 ? (e.consume(p), w) : z(p) ? (u = F, ie(p)) : (e.consume(p), F);
  }
  function w(p) {
    return p === 62 ? C(p) : F(p);
  }
  function I(p) {
    return me(p) ? (e.consume(p), j) : t(p);
  }
  function j(p) {
    return p === 45 || pe(p) ? (e.consume(p), j) : W(p);
  }
  function W(p) {
    return z(p) ? (u = W, ie(p)) : ne(p) ? (e.consume(p), W) : C(p);
  }
  function b(p) {
    return p === 45 || pe(p) ? (e.consume(p), b) : p === 47 || p === 62 || re(p) ? v(p) : t(p);
  }
  function v(p) {
    return p === 47 ? (e.consume(p), C) : p === 58 || p === 95 || me(p) ? (e.consume(p), L) : z(p) ? (u = v, ie(p)) : ne(p) ? (e.consume(p), v) : C(p);
  }
  function L(p) {
    return p === 45 || p === 46 || p === 58 || p === 95 || pe(p) ? (e.consume(p), L) : Y(p);
  }
  function Y(p) {
    return p === 61 ? (e.consume(p), J) : z(p) ? (u = Y, ie(p)) : ne(p) ? (e.consume(p), Y) : v(p);
  }
  function J(p) {
    return p === null || p === 60 || p === 61 || p === 62 || p === 96 ? t(p) : p === 34 || p === 39 ? (e.consume(p), i = p, he) : z(p) ? (u = J, ie(p)) : ne(p) ? (e.consume(p), J) : (e.consume(p), i = void 0, ae);
  }
  function he(p) {
    return p === i ? (e.consume(p), le) : p === null ? t(p) : z(p) ? (u = he, ie(p)) : (e.consume(p), he);
  }
  function le(p) {
    return p === 62 || p === 47 || re(p) ? v(p) : t(p);
  }
  function ae(p) {
    return p === null || p === 34 || p === 39 || p === 60 || p === 61 || p === 96 ? t(p) : p === 62 || re(p) ? v(p) : (e.consume(p), ae);
  }
  function ie(p) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), X(
      e,
      se,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
  }
  function se(p) {
    return e.enter("htmlTextData"), u(p);
  }
  function C(p) {
    return p === 62 ? (e.consume(p), e.exit("htmlTextData"), e.exit("htmlText"), n) : t(p);
  }
}
const Vn = {
  name: "labelEnd",
  tokenize: Nl,
  resolveTo: jl,
  resolveAll: Bl
}, zl = {
  tokenize: Hl
}, _l = {
  tokenize: Ul
}, Ml = {
  tokenize: $l
};
function Bl(e) {
  let n = -1, t;
  for (; ++n < e.length; )
    t = e[n][1], (t.type === "labelImage" || t.type === "labelLink" || t.type === "labelEnd") && (e.splice(n + 1, t.type === "labelImage" ? 4 : 2), t.type = "data", n++);
  return e;
}
function jl(e, n) {
  let t = e.length, r = 0, i, l, o, u;
  for (; t--; )
    if (i = e[t][1], l) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[t][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (e[t][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (l = t, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      i.type === "labelEnd" && (o = t);
  const a = {
    type: e[l][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[l][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, c = {
    type: "label",
    start: Object.assign({}, e[l][1].start),
    end: Object.assign({}, e[o][1].end)
  }, s = {
    type: "labelText",
    start: Object.assign({}, e[l + r + 2][1].end),
    end: Object.assign({}, e[o - 2][1].start)
  };
  return u = [
    ["enter", a, n],
    ["enter", c, n]
  ], u = xe(u, e.slice(l + 1, l + r + 3)), u = xe(u, [["enter", s, n]]), u = xe(
    u,
    cn(
      n.parser.constructs.insideSpan.null,
      e.slice(l + r + 4, o - 3),
      n
    )
  ), u = xe(u, [
    ["exit", s, n],
    e[o - 2],
    e[o - 1],
    ["exit", c, n]
  ]), u = xe(u, e.slice(o + 1)), u = xe(u, [["exit", a, n]]), ye(e, l, e.length, u), e;
}
function Nl(e, n, t) {
  const r = this;
  let i = r.events.length, l, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      l = r.events[i][1];
      break;
    }
  return u;
  function u(s) {
    return l ? l._inactive ? c(s) : (o = r.parser.defined.includes(
      Se(
        r.sliceSerialize({
          start: l.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelEnd"), a) : t(s);
  }
  function a(s) {
    return s === 40 ? e.attempt(
      zl,
      n,
      o ? n : c
    )(s) : s === 91 ? e.attempt(
      _l,
      n,
      o ? e.attempt(Ml, n, c) : c
    )(s) : o ? n(s) : c(s);
  }
  function c(s) {
    return l._balanced = !0, t(s);
  }
}
function Hl(e, n, t) {
  return r;
  function r(a) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(a), e.exit("resourceMarker"), Xe(e, i);
  }
  function i(a) {
    return a === 41 ? u(a) : xr(
      e,
      l,
      t,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(a);
  }
  function l(a) {
    return re(a) ? Xe(e, o)(a) : u(a);
  }
  function o(a) {
    return a === 34 || a === 39 || a === 40 ? br(
      e,
      Xe(e, u),
      t,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(a) : u(a);
  }
  function u(a) {
    return a === 41 ? (e.enter("resourceMarker"), e.consume(a), e.exit("resourceMarker"), e.exit("resource"), n) : t(a);
  }
}
function Ul(e, n, t) {
  const r = this;
  return i;
  function i(o) {
    return kr.call(
      r,
      e,
      l,
      t,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function l(o) {
    return r.parser.defined.includes(
      Se(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? n(o) : t(o);
  }
}
function $l(e, n, t) {
  return r;
  function r(l) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(l), e.exit("referenceMarker"), i;
  }
  function i(l) {
    return l === 93 ? (e.enter("referenceMarker"), e.consume(l), e.exit("referenceMarker"), e.exit("reference"), n) : t(l);
  }
}
const ql = {
  name: "labelStartImage",
  tokenize: Vl,
  resolveAll: Vn.resolveAll
};
function Vl(e, n, t) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(u), e.exit("labelImageMarker"), l;
  }
  function l(u) {
    return u === 91 ? (e.enter("labelMarker"), e.consume(u), e.exit("labelMarker"), e.exit("labelImage"), o) : t(u);
  }
  function o(u) {
    return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(u) : n(u);
  }
}
const Wl = {
  name: "labelStartLink",
  tokenize: Yl,
  resolveAll: Vn.resolveAll
};
function Yl(e, n, t) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelLink"), l;
  }
  function l(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(o) : n(o);
  }
}
const wn = {
  name: "lineEnding",
  tokenize: Ql
};
function Ql(e, n) {
  return t;
  function t(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), X(e, n, "linePrefix");
  }
}
const ln = {
  name: "thematicBreak",
  tokenize: Xl
};
function Xl(e, n, t) {
  let r = 0, i;
  return l;
  function l(a) {
    return e.enter("thematicBreak"), i = a, o(a);
  }
  function o(a) {
    return a === i ? (e.enter("thematicBreakSequence"), u(a)) : ne(a) ? X(e, o, "whitespace")(a) : r < 3 || a !== null && !z(a) ? t(a) : (e.exit("thematicBreak"), n(a));
  }
  function u(a) {
    return a === i ? (e.consume(a), r++, u) : (e.exit("thematicBreakSequence"), o(a));
  }
}
const ge = {
  name: "list",
  tokenize: Zl,
  continuation: {
    tokenize: Jl
  },
  exit: no
}, Gl = {
  tokenize: to,
  partial: !0
}, Kl = {
  tokenize: eo,
  partial: !0
};
function Zl(e, n, t) {
  const r = this, i = r.events[r.events.length - 1];
  let l = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return u;
  function u(d) {
    const h = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (h === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : _n(d)) {
      if (r.containerState.type || (r.containerState.type = h, e.enter(h, {
        _container: !0
      })), h === "listUnordered")
        return e.enter("listItemPrefix"), d === 42 || d === 45 ? e.check(ln, t, c)(d) : c(d);
      if (!r.interrupt || d === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), a(d);
    }
    return t(d);
  }
  function a(d) {
    return _n(d) && ++o < 10 ? (e.consume(d), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (e.exit("listItemValue"), c(d)) : t(d);
  }
  function c(d) {
    return e.enter("listItemMarker"), e.consume(d), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, e.check(
      Ze,
      // Can’t be empty when interrupting.
      r.interrupt ? t : s,
      e.attempt(
        Gl,
        x,
        f
      )
    );
  }
  function s(d) {
    return r.containerState.initialBlankLine = !0, l++, x(d);
  }
  function f(d) {
    return ne(d) ? (e.enter("listItemPrefixWhitespace"), e.consume(d), e.exit("listItemPrefixWhitespace"), x) : t(d);
  }
  function x(d) {
    return r.containerState.size = l + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, n(d);
  }
}
function Jl(e, n, t) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Ze, i, l);
  function i(u) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, X(
      e,
      n,
      "listItemIndent",
      r.containerState.size + 1
    )(u);
  }
  function l(u) {
    return r.containerState.furtherBlankLines || !ne(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(Kl, n, o)(u));
  }
  function o(u) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, X(
      e,
      e.attempt(ge, n, t),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(u);
  }
}
function eo(e, n, t) {
  const r = this;
  return X(
    e,
    i,
    "listItemIndent",
    r.containerState.size + 1
  );
  function i(l) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? n(l) : t(l);
  }
}
function no(e) {
  e.exit(this.containerState.type);
}
function to(e, n, t) {
  const r = this;
  return X(
    e,
    i,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function i(l) {
    const o = r.events[r.events.length - 1];
    return !ne(l) && o && o[1].type === "listItemPrefixWhitespace" ? n(l) : t(l);
  }
}
const Tt = {
  name: "setextUnderline",
  tokenize: io,
  resolveTo: ro
};
function ro(e, n) {
  let t = e.length, r, i, l;
  for (; t--; )
    if (e[t][0] === "enter") {
      if (e[t][1].type === "content") {
        r = t;
        break;
      }
      e[t][1].type === "paragraph" && (i = t);
    } else
      e[t][1].type === "content" && e.splice(t, 1), !l && e[t][1].type === "definition" && (l = t);
  const o = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", l ? (e.splice(i, 0, ["enter", o, n]), e.splice(l + 1, 0, ["exit", e[r][1], n]), e[r][1].end = Object.assign({}, e[l][1].end)) : e[r][1] = o, e.push(["exit", o, n]), e;
}
function io(e, n, t) {
  const r = this;
  let i = r.events.length, l, o;
  for (; i--; )
    if (r.events[i][1].type !== "lineEnding" && r.events[i][1].type !== "linePrefix" && r.events[i][1].type !== "content") {
      o = r.events[i][1].type === "paragraph";
      break;
    }
  return u;
  function u(s) {
    return !r.parser.lazy[r.now().line] && (r.interrupt || o) ? (e.enter("setextHeadingLine"), e.enter("setextHeadingLineSequence"), l = s, a(s)) : t(s);
  }
  function a(s) {
    return s === l ? (e.consume(s), a) : (e.exit("setextHeadingLineSequence"), X(e, c, "lineSuffix")(s));
  }
  function c(s) {
    return s === null || z(s) ? (e.exit("setextHeadingLine"), n(s)) : t(s);
  }
}
const lo = {
  tokenize: oo
};
function oo(e) {
  const n = this, t = e.attempt(
    // Try to parse a blank line.
    Ze,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      X(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(hl, i)
        ),
        "linePrefix"
      )
    )
  );
  return t;
  function r(l) {
    if (l === null) {
      e.consume(l);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(l), e.exit("lineEndingBlank"), n.currentConstruct = void 0, t;
  }
  function i(l) {
    if (l === null) {
      e.consume(l);
      return;
    }
    return e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), n.currentConstruct = void 0, t;
  }
}
const uo = {
  resolveAll: Sr()
}, ao = wr("string"), so = wr("text");
function wr(e) {
  return {
    tokenize: n,
    resolveAll: Sr(
      e === "text" ? co : void 0
    )
  };
  function n(t) {
    const r = this, i = this.parser.constructs[e], l = t.attempt(i, o, u);
    return o;
    function o(s) {
      return c(s) ? l(s) : u(s);
    }
    function u(s) {
      if (s === null) {
        t.consume(s);
        return;
      }
      return t.enter("data"), t.consume(s), a;
    }
    function a(s) {
      return c(s) ? (t.exit("data"), l(s)) : (t.consume(s), a);
    }
    function c(s) {
      if (s === null)
        return !0;
      const f = i[s];
      let x = -1;
      if (f)
        for (; ++x < f.length; ) {
          const d = f[x];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function Sr(e) {
  return n;
  function n(t, r) {
    let i = -1, l;
    for (; ++i <= t.length; )
      l === void 0 ? t[i] && t[i][1].type === "data" && (l = i, i++) : (!t[i] || t[i][1].type !== "data") && (i !== l + 2 && (t[l][1].end = t[i - 1][1].end, t.splice(l + 2, i - l - 2), i = l + 2), l = void 0);
    return e ? e(t, r) : t;
  }
}
function co(e, n) {
  let t = 0;
  for (; ++t <= e.length; )
    if ((t === e.length || e[t][1].type === "lineEnding") && e[t - 1][1].type === "data") {
      const r = e[t - 1][1], i = n.sliceStream(r);
      let l = i.length, o = -1, u = 0, a;
      for (; l--; ) {
        const c = i[l];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            u++, o--;
          if (o)
            break;
          o = -1;
        } else if (c === -2)
          a = !0, u++;
        else if (c !== -1) {
          l++;
          break;
        }
      }
      if (u) {
        const c = {
          type: t === e.length || a || u < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - u,
            offset: r.end.offset - u,
            _index: r.start._index + l,
            _bufferIndex: l ? o : r.start._bufferIndex + o
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, c.start), r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(
          t,
          0,
          ["enter", c, n],
          ["exit", c, n]
        ), t += 2);
      }
      t++;
    }
  return e;
}
function fo(e, n, t) {
  let r = Object.assign(
    t ? Object.assign({}, t) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, l = [];
  let o = [], u = [];
  const a = {
    consume: P,
    enter: A,
    exit: O,
    attempt: I(F),
    check: I(w),
    interrupt: I(w, {
      interrupt: !0
    })
  }, c = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: d,
    sliceSerialize: x,
    now: h,
    defineSkip: g,
    write: f
  };
  let s = n.tokenize.call(c, a);
  return n.resolveAll && l.push(n), c;
  function f(v) {
    return o = xe(o, v), y(), o[o.length - 1] !== null ? [] : (j(n, 0), c.events = cn(l, c.events, c), c.events);
  }
  function x(v, L) {
    return ho(d(v), L);
  }
  function d(v) {
    return po(o, v);
  }
  function h() {
    return Object.assign({}, r);
  }
  function g(v) {
    i[v.line] = v.column, b();
  }
  function y() {
    let v;
    for (; r._index < o.length; ) {
      const L = o[r._index];
      if (typeof L == "string")
        for (v = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === v && r._bufferIndex < L.length; )
          k(L.charCodeAt(r._bufferIndex));
      else
        k(L);
    }
  }
  function k(v) {
    s = s(v);
  }
  function P(v) {
    z(v) ? (r.line++, r.column = 1, r.offset += v === -3 ? 2 : 1, b()) : v !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = v;
  }
  function A(v, L) {
    const Y = L || {};
    return Y.type = v, Y.start = h(), c.events.push(["enter", Y, c]), u.push(Y), Y;
  }
  function O(v) {
    const L = u.pop();
    return L.end = h(), c.events.push(["exit", L, c]), L;
  }
  function F(v, L) {
    j(v, L.from);
  }
  function w(v, L) {
    L.restore();
  }
  function I(v, L) {
    return Y;
    function Y(J, he, le) {
      let ae, ie, se, C;
      return Array.isArray(J) ? (
        /* c8 ignore next 1 */
        m(J)
      ) : "tokenize" in J ? m([J]) : p(J);
      function p(D) {
        return _;
        function _(U) {
          const Q = U !== null && D[U], V = U !== null && D.null, fe = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Q) ? Q : Q ? [Q] : [],
            ...Array.isArray(V) ? V : V ? [V] : []
          ];
          return m(fe)(U);
        }
      }
      function m(D) {
        return ae = D, ie = 0, D.length === 0 ? le : H(D[ie]);
      }
      function H(D) {
        return _;
        function _(U) {
          return C = W(), se = D, D.partial || (c.currentConstruct = D), D.name && c.parser.constructs.disable.null.includes(D.name) ? q() : D.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            L ? Object.assign(Object.create(c), L) : c,
            a,
            B,
            q
          )(U);
        }
      }
      function B(D) {
        return v(se, C), he;
      }
      function q(D) {
        return C.restore(), ++ie < ae.length ? H(ae[ie]) : le;
      }
    }
  }
  function j(v, L) {
    v.resolveAll && !l.includes(v) && l.push(v), v.resolve && ye(
      c.events,
      L,
      c.events.length - L,
      v.resolve(c.events.slice(L), c)
    ), v.resolveTo && (c.events = v.resolveTo(c.events, c));
  }
  function W() {
    const v = h(), L = c.previous, Y = c.currentConstruct, J = c.events.length, he = Array.from(u);
    return {
      restore: le,
      from: J
    };
    function le() {
      r = v, c.previous = L, c.currentConstruct = Y, c.events.length = J, u = he, b();
    }
  }
  function b() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function po(e, n) {
  const t = n.start._index, r = n.start._bufferIndex, i = n.end._index, l = n.end._bufferIndex;
  let o;
  return t === i ? o = [e[t].slice(r, l)] : (o = e.slice(t, i), r > -1 && (o[0] = o[0].slice(r)), l > 0 && o.push(e[i].slice(0, l))), o;
}
function ho(e, n) {
  let t = -1;
  const r = [];
  let i;
  for (; ++t < e.length; ) {
    const l = e[t];
    let o;
    if (typeof l == "string")
      o = l;
    else
      switch (l) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = n ? " " : "	";
          break;
        }
        case -1: {
          if (!n && i)
            continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(l);
      }
    i = l === -2, r.push(o);
  }
  return r.join("");
}
const mo = {
  [42]: ge,
  [43]: ge,
  [45]: ge,
  [48]: ge,
  [49]: ge,
  [50]: ge,
  [51]: ge,
  [52]: ge,
  [53]: ge,
  [54]: ge,
  [55]: ge,
  [56]: ge,
  [57]: ge,
  [62]: mr
}, go = {
  [91]: xl
}, yo = {
  [-2]: bn,
  [-1]: bn,
  [32]: bn
}, xo = {
  [35]: El,
  [42]: ln,
  [45]: [Tt, ln],
  [60]: Pl,
  [61]: Tt,
  [95]: ln,
  [96]: At,
  [126]: At
}, ko = {
  [38]: dr,
  [92]: gr
}, bo = {
  [-5]: wn,
  [-4]: wn,
  [-3]: wn,
  [33]: ql,
  [38]: dr,
  [42]: Mn,
  [60]: [Gi, Ll],
  [91]: Wl,
  [92]: [Sl, gr],
  [93]: Vn,
  [95]: Mn,
  [96]: al
}, wo = {
  null: [Mn, uo]
}, So = {
  null: [42, 95]
}, Co = {
  null: []
}, Eo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: So,
  contentInitial: go,
  disable: Co,
  document: mo,
  flow: xo,
  flowInitial: yo,
  insideSpan: wo,
  string: ko,
  text: bo
}, Symbol.toStringTag, { value: "Module" }));
function Ao(e = {}) {
  const n = hr(
    // @ts-expect-error Same as above.
    [Eo].concat(e.extensions || [])
  ), t = {
    defined: [],
    lazy: {},
    constructs: n,
    content: r($i),
    document: r(Vi),
    flow: r(lo),
    string: r(ao),
    text: r(so)
  };
  return t;
  function r(i) {
    return l;
    function l(o) {
      return fo(t, i, o);
    }
  }
}
const Pt = /[\0\t\n\r]/g;
function vo() {
  let e = 1, n = "", t = !0, r;
  return i;
  function i(l, o, u) {
    const a = [];
    let c, s, f, x, d;
    for (l = n + l.toString(o), f = 0, n = "", t && (l.charCodeAt(0) === 65279 && f++, t = void 0); f < l.length; ) {
      if (Pt.lastIndex = f, c = Pt.exec(l), x = c && c.index !== void 0 ? c.index : l.length, d = l.charCodeAt(x), !c) {
        n = l.slice(f);
        break;
      }
      if (d === 10 && f === x && r)
        a.push(-3), r = void 0;
      else
        switch (r && (a.push(-5), r = void 0), f < x && (a.push(l.slice(f, x)), e += x - f), d) {
          case 0: {
            a.push(65533), e++;
            break;
          }
          case 9: {
            for (s = Math.ceil(e / 4) * 4, a.push(-2); e++ < s; )
              a.push(-1);
            break;
          }
          case 10: {
            a.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = x + 1;
    }
    return u && (r && a.push(-5), n && a.push(n), a.push(null)), a;
  }
}
function To(e) {
  for (; !yr(e); )
    ;
  return e;
}
function Cr(e, n) {
  const t = Number.parseInt(e, n);
  return (
    // C0 except for HT, LF, FF, CR, space
    t < 9 || t === 11 || t > 13 && t < 32 || // Control character (DEL) of the basic block and C1 controls.
    t > 126 && t < 160 || // Lone high surrogates and low surrogates.
    t > 55295 && t < 57344 || // Noncharacters.
    t > 64975 && t < 65008 || (t & 65535) === 65535 || (t & 65535) === 65534 || // Out of range
    t > 1114111 ? "�" : String.fromCharCode(t)
  );
}
const Po = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Er(e) {
  return e.replace(Po, Fo);
}
function Fo(e, n, t) {
  if (n)
    return n;
  if (t.charCodeAt(0) === 35) {
    const i = t.charCodeAt(1), l = i === 120 || i === 88;
    return Cr(t.slice(l ? 2 : 1), l ? 16 : 10);
  }
  return qn(t) || e;
}
const Ar = {}.hasOwnProperty, Io = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function(e, n, t) {
    return typeof n != "string" && (t = n, n = void 0), Oo(t)(
      To(
        // @ts-expect-error: micromark types need to accept `null`.
        Ao(t).document().write(vo()(e, n, !0))
      )
    );
  }
);
function Oo(e) {
  const n = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: u(tt),
      autolinkProtocol: v,
      autolinkEmail: v,
      atxHeading: u(Le),
      blockQuote: u(fe),
      characterEscape: v,
      characterReference: v,
      codeFenced: u(ce),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: u(ce, a),
      codeText: u(Ce, a),
      codeTextData: v,
      data: v,
      codeFlowValue: v,
      definition: u(R),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: u($e),
      hardBreakEscape: u(qe),
      hardBreakTrailing: u(qe),
      htmlFlow: u(nt, a),
      htmlFlowData: v,
      htmlText: u(nt, a),
      htmlTextData: v,
      image: u(ai),
      label: a,
      link: u(tt),
      listItem: u(si),
      listItemValue: h,
      listOrdered: u(rt, d),
      listUnordered: u(rt),
      paragraph: u(ci),
      reference: q,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: u(Le),
      strong: u(fi),
      thematicBreak: u(hi)
    },
    exit: {
      atxHeading: s(),
      atxHeadingSequence: I,
      autolink: s(),
      autolinkEmail: V,
      autolinkProtocol: Q,
      blockQuote: s(),
      characterEscapeValue: L,
      characterReferenceMarkerHexadecimal: _,
      characterReferenceMarkerNumeric: _,
      characterReferenceValue: U,
      codeFenced: s(P),
      codeFencedFence: k,
      codeFencedFenceInfo: g,
      codeFencedFenceMeta: y,
      codeFlowValue: L,
      codeIndented: s(A),
      codeText: s(ae),
      codeTextData: L,
      data: L,
      definition: s(),
      definitionDestinationString: w,
      definitionLabelString: O,
      definitionTitleString: F,
      emphasis: s(),
      hardBreakEscape: s(J),
      hardBreakTrailing: s(J),
      htmlFlow: s(he),
      htmlFlowData: L,
      htmlText: s(le),
      htmlTextData: L,
      image: s(se),
      label: p,
      labelText: C,
      lineEnding: Y,
      link: s(ie),
      listItem: s(),
      listOrdered: s(),
      listUnordered: s(),
      paragraph: s(),
      referenceString: D,
      resourceDestinationString: m,
      resourceTitleString: H,
      resource: B,
      setextHeading: s(b),
      setextHeadingLineSequence: W,
      setextHeadingText: j,
      strong: s(),
      thematicBreak: s()
    }
  };
  vr(n, (e || {}).mdastExtensions || []);
  const t = {};
  return r;
  function r(S) {
    let T = {
      type: "root",
      children: []
    };
    const M = {
      stack: [T],
      tokenStack: [],
      config: n,
      enter: c,
      exit: f,
      buffer: a,
      resume: x,
      setData: l,
      getData: o
    }, Z = [];
    let ee = -1;
    for (; ++ee < S.length; )
      if (S[ee][1].type === "listOrdered" || S[ee][1].type === "listUnordered")
        if (S[ee][0] === "enter")
          Z.push(ee);
        else {
          const we = Z.pop();
          ee = i(S, we, ee);
        }
    for (ee = -1; ++ee < S.length; ) {
      const we = n[S[ee][0]];
      Ar.call(we, S[ee][1].type) && we[S[ee][1].type].call(
        Object.assign(
          {
            sliceSerialize: S[ee][2].sliceSerialize
          },
          M
        ),
        S[ee][1]
      );
    }
    if (M.tokenStack.length > 0) {
      const we = M.tokenStack[M.tokenStack.length - 1];
      (we[1] || Ft).call(M, void 0, we[0]);
    }
    for (T.position = {
      start: Oe(
        S.length > 0 ? S[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: Oe(
        S.length > 0 ? S[S.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, ee = -1; ++ee < n.transforms.length; )
      T = n.transforms[ee](T) || T;
    return T;
  }
  function i(S, T, M) {
    let Z = T - 1, ee = -1, we = !1, Ie, Te, Ve, We;
    for (; ++Z <= M; ) {
      const oe = S[Z];
      if (oe[1].type === "listUnordered" || oe[1].type === "listOrdered" || oe[1].type === "blockQuote" ? (oe[0] === "enter" ? ee++ : ee--, We = void 0) : oe[1].type === "lineEndingBlank" ? oe[0] === "enter" && (Ie && !We && !ee && !Ve && (Ve = Z), We = void 0) : oe[1].type === "linePrefix" || oe[1].type === "listItemValue" || oe[1].type === "listItemMarker" || oe[1].type === "listItemPrefix" || oe[1].type === "listItemPrefixWhitespace" || (We = void 0), !ee && oe[0] === "enter" && oe[1].type === "listItemPrefix" || ee === -1 && oe[0] === "exit" && (oe[1].type === "listUnordered" || oe[1].type === "listOrdered")) {
        if (Ie) {
          let hn = Z;
          for (Te = void 0; hn--; ) {
            const Pe = S[hn];
            if (Pe[1].type === "lineEnding" || Pe[1].type === "lineEndingBlank") {
              if (Pe[0] === "exit")
                continue;
              Te && (S[Te][1].type = "lineEndingBlank", we = !0), Pe[1].type = "lineEnding", Te = hn;
            } else if (!(Pe[1].type === "linePrefix" || Pe[1].type === "blockQuotePrefix" || Pe[1].type === "blockQuotePrefixWhitespace" || Pe[1].type === "blockQuoteMarker" || Pe[1].type === "listItemIndent"))
              break;
          }
          Ve && (!Te || Ve < Te) && (Ie._spread = !0), Ie.end = Object.assign(
            {},
            Te ? S[Te][1].start : oe[1].end
          ), S.splice(Te || Z, 0, ["exit", Ie, oe[2]]), Z++, M++;
        }
        oe[1].type === "listItemPrefix" && (Ie = {
          type: "listItem",
          // @ts-expect-error Patched
          _spread: !1,
          start: Object.assign({}, oe[1].start)
        }, S.splice(Z, 0, ["enter", Ie, oe[2]]), Z++, M++, Ve = void 0, We = !0);
      }
    }
    return S[T][1]._spread = we, M;
  }
  function l(S, T) {
    t[S] = T;
  }
  function o(S) {
    return t[S];
  }
  function u(S, T) {
    return M;
    function M(Z) {
      c.call(this, S(Z), Z), T && T.call(this, Z);
    }
  }
  function a() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function c(S, T, M) {
    return this.stack[this.stack.length - 1].children.push(S), this.stack.push(S), this.tokenStack.push([T, M]), S.position = {
      start: Oe(T.start)
    }, S;
  }
  function s(S) {
    return T;
    function T(M) {
      S && S.call(this, M), f.call(this, M);
    }
  }
  function f(S, T) {
    const M = this.stack.pop(), Z = this.tokenStack.pop();
    if (Z)
      Z[0].type !== S.type && (T ? T.call(this, S, Z[0]) : (Z[1] || Ft).call(this, S, Z[0]));
    else
      throw new Error(
        "Cannot close `" + S.type + "` (" + Qe({
          start: S.start,
          end: S.end
        }) + "): it’s not open"
      );
    return M.position.end = Oe(S.end), M;
  }
  function x() {
    return _i(this.stack.pop());
  }
  function d() {
    l("expectingFirstListItemValue", !0);
  }
  function h(S) {
    if (o("expectingFirstListItemValue")) {
      const T = this.stack[this.stack.length - 2];
      T.start = Number.parseInt(this.sliceSerialize(S), 10), l("expectingFirstListItemValue");
    }
  }
  function g() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.lang = S;
  }
  function y() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.meta = S;
  }
  function k() {
    o("flowCodeInside") || (this.buffer(), l("flowCodeInside", !0));
  }
  function P() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.value = S.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), l("flowCodeInside");
  }
  function A() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.value = S.replace(/(\r?\n|\r)$/g, "");
  }
  function O(S) {
    const T = this.resume(), M = this.stack[this.stack.length - 1];
    M.label = T, M.identifier = Se(
      this.sliceSerialize(S)
    ).toLowerCase();
  }
  function F() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.title = S;
  }
  function w() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.url = S;
  }
  function I(S) {
    const T = this.stack[this.stack.length - 1];
    if (!T.depth) {
      const M = this.sliceSerialize(S).length;
      T.depth = M;
    }
  }
  function j() {
    l("setextHeadingSlurpLineEnding", !0);
  }
  function W(S) {
    const T = this.stack[this.stack.length - 1];
    T.depth = this.sliceSerialize(S).charCodeAt(0) === 61 ? 1 : 2;
  }
  function b() {
    l("setextHeadingSlurpLineEnding");
  }
  function v(S) {
    const T = this.stack[this.stack.length - 1];
    let M = T.children[T.children.length - 1];
    (!M || M.type !== "text") && (M = pi(), M.position = {
      start: Oe(S.start)
    }, T.children.push(M)), this.stack.push(M);
  }
  function L(S) {
    const T = this.stack.pop();
    T.value += this.sliceSerialize(S), T.position.end = Oe(S.end);
  }
  function Y(S) {
    const T = this.stack[this.stack.length - 1];
    if (o("atHardBreak")) {
      const M = T.children[T.children.length - 1];
      M.position.end = Oe(S.end), l("atHardBreak");
      return;
    }
    !o("setextHeadingSlurpLineEnding") && n.canContainEols.includes(T.type) && (v.call(this, S), L.call(this, S));
  }
  function J() {
    l("atHardBreak", !0);
  }
  function he() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.value = S;
  }
  function le() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.value = S;
  }
  function ae() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.value = S;
  }
  function ie() {
    const S = this.stack[this.stack.length - 1];
    if (o("inReference")) {
      const T = o("referenceType") || "shortcut";
      S.type += "Reference", S.referenceType = T, delete S.url, delete S.title;
    } else
      delete S.identifier, delete S.label;
    l("referenceType");
  }
  function se() {
    const S = this.stack[this.stack.length - 1];
    if (o("inReference")) {
      const T = o("referenceType") || "shortcut";
      S.type += "Reference", S.referenceType = T, delete S.url, delete S.title;
    } else
      delete S.identifier, delete S.label;
    l("referenceType");
  }
  function C(S) {
    const T = this.sliceSerialize(S), M = this.stack[this.stack.length - 2];
    M.label = Er(T), M.identifier = Se(T).toLowerCase();
  }
  function p() {
    const S = this.stack[this.stack.length - 1], T = this.resume(), M = this.stack[this.stack.length - 1];
    if (l("inReference", !0), M.type === "link") {
      const Z = S.children;
      M.children = Z;
    } else
      M.alt = T;
  }
  function m() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.url = S;
  }
  function H() {
    const S = this.resume(), T = this.stack[this.stack.length - 1];
    T.title = S;
  }
  function B() {
    l("inReference");
  }
  function q() {
    l("referenceType", "collapsed");
  }
  function D(S) {
    const T = this.resume(), M = this.stack[this.stack.length - 1];
    M.label = T, M.identifier = Se(
      this.sliceSerialize(S)
    ).toLowerCase(), l("referenceType", "full");
  }
  function _(S) {
    l("characterReferenceType", S.type);
  }
  function U(S) {
    const T = this.sliceSerialize(S), M = o("characterReferenceType");
    let Z;
    M ? (Z = Cr(
      T,
      M === "characterReferenceMarkerNumeric" ? 10 : 16
    ), l("characterReferenceType")) : Z = qn(T);
    const ee = this.stack.pop();
    ee.value += Z, ee.position.end = Oe(S.end);
  }
  function Q(S) {
    L.call(this, S);
    const T = this.stack[this.stack.length - 1];
    T.url = this.sliceSerialize(S);
  }
  function V(S) {
    L.call(this, S);
    const T = this.stack[this.stack.length - 1];
    T.url = "mailto:" + this.sliceSerialize(S);
  }
  function fe() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function ce() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Ce() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function R() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function $e() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Le() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function qe() {
    return {
      type: "break"
    };
  }
  function nt() {
    return {
      type: "html",
      value: ""
    };
  }
  function ai() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function tt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function rt(S) {
    return {
      type: "list",
      ordered: S.type === "listOrdered",
      start: null,
      // @ts-expect-error Patched.
      spread: S._spread,
      children: []
    };
  }
  function si(S) {
    return {
      type: "listItem",
      // @ts-expect-error Patched.
      spread: S._spread,
      checked: null,
      children: []
    };
  }
  function ci() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function fi() {
    return {
      type: "strong",
      children: []
    };
  }
  function pi() {
    return {
      type: "text",
      value: ""
    };
  }
  function hi() {
    return {
      type: "thematicBreak"
    };
  }
}
function Oe(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function vr(e, n) {
  let t = -1;
  for (; ++t < n.length; ) {
    const r = n[t];
    Array.isArray(r) ? vr(e, r) : Do(e, r);
  }
}
function Do(e, n) {
  let t;
  for (t in n)
    if (Ar.call(n, t)) {
      if (t === "canContainEols") {
        const r = n[t];
        r && e[t].push(...r);
      } else if (t === "transforms") {
        const r = n[t];
        r && e[t].push(...r);
      } else if (t === "enter" || t === "exit") {
        const r = n[t];
        r && Object.assign(e[t], r);
      }
    }
}
function Ft(e, n) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + Qe({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + n.type + "`, " + Qe({
      start: n.start,
      end: n.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + n.type + "`, " + Qe({
      start: n.start,
      end: n.end
    }) + ") is still open"
  );
}
function Lo(e) {
  Object.assign(this, { Parser: (t) => {
    const r = (
      /** @type {Options} */
      this.data("settings")
    );
    return Io(
      t,
      Object.assign({}, r, e, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  } });
}
function Ro(e, n) {
  const t = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(n), !0)
  };
  return e.patch(n, t), e.applyData(n, t);
}
function zo(e, n) {
  const t = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(n, t), [e.applyData(n, t), { type: "text", value: `
` }];
}
function _o(e, n) {
  const t = n.value ? n.value + `
` : "", r = n.lang ? n.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null, i = {};
  r && (i.className = ["language-" + r]);
  let l = {
    type: "element",
    tagName: "code",
    properties: i,
    children: [{ type: "text", value: t }]
  };
  return n.meta && (l.data = { meta: n.meta }), e.patch(n, l), l = e.applyData(n, l), l = { type: "element", tagName: "pre", properties: {}, children: [l] }, e.patch(n, l), l;
}
function Mo(e, n) {
  const t = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(n)
  };
  return e.patch(n, t), e.applyData(n, t);
}
function Bo(e, n) {
  const t = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(n)
  };
  return e.patch(n, t), e.applyData(n, t);
}
function He(e) {
  const n = [];
  let t = -1, r = 0, i = 0;
  for (; ++t < e.length; ) {
    const l = e.charCodeAt(t);
    let o = "";
    if (l === 37 && pe(e.charCodeAt(t + 1)) && pe(e.charCodeAt(t + 2)))
      i = 2;
    else if (l < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(l)) || (o = String.fromCharCode(l));
    else if (l > 55295 && l < 57344) {
      const u = e.charCodeAt(t + 1);
      l < 56320 && u > 56319 && u < 57344 ? (o = String.fromCharCode(l, u), i = 1) : o = "�";
    } else
      o = String.fromCharCode(l);
    o && (n.push(e.slice(r, t), encodeURIComponent(o)), r = t + i + 1, o = ""), i && (t += i, i = 0);
  }
  return n.join("") + e.slice(r);
}
function Tr(e, n) {
  const t = String(n.identifier).toUpperCase(), r = He(t.toLowerCase()), i = e.footnoteOrder.indexOf(t);
  let l;
  i === -1 ? (e.footnoteOrder.push(t), e.footnoteCounts[t] = 1, l = e.footnoteOrder.length) : (e.footnoteCounts[t]++, l = i + 1);
  const o = e.footnoteCounts[t], u = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + e.clobberPrefix + "fn-" + r,
      id: e.clobberPrefix + "fnref-" + r + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(l) }]
  };
  e.patch(n, u);
  const a = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [u]
  };
  return e.patch(n, a), e.applyData(n, a);
}
function jo(e, n) {
  const t = e.footnoteById;
  let r = 1;
  for (; r in t; )
    r++;
  const i = String(r);
  return t[i] = {
    type: "footnoteDefinition",
    identifier: i,
    children: [{ type: "paragraph", children: n.children }],
    position: n.position
  }, Tr(e, {
    type: "footnoteReference",
    identifier: i,
    position: n.position
  });
}
function No(e, n) {
  const t = {
    type: "element",
    tagName: "h" + n.depth,
    properties: {},
    children: e.all(n)
  };
  return e.patch(n, t), e.applyData(n, t);
}
function Ho(e, n) {
  if (e.dangerous) {
    const t = { type: "raw", value: n.value };
    return e.patch(n, t), e.applyData(n, t);
  }
  return null;
}
function Pr(e, n) {
  const t = n.referenceType;
  let r = "]";
  if (t === "collapsed" ? r += "[]" : t === "full" && (r += "[" + (n.label || n.identifier) + "]"), n.type === "imageReference")
    return { type: "text", value: "![" + n.alt + r };
  const i = e.all(n), l = i[0];
  l && l.type === "text" ? l.value = "[" + l.value : i.unshift({ type: "text", value: "[" });
  const o = i[i.length - 1];
  return o && o.type === "text" ? o.value += r : i.push({ type: "text", value: r }), i;
}
function Uo(e, n) {
  const t = e.definition(n.identifier);
  if (!t)
    return Pr(e, n);
  const r = { src: He(t.url || ""), alt: n.alt };
  t.title !== null && t.title !== void 0 && (r.title = t.title);
  const i = { type: "element", tagName: "img", properties: r, children: [] };
  return e.patch(n, i), e.applyData(n, i);
}
function $o(e, n) {
  const t = { src: He(n.url) };
  n.alt !== null && n.alt !== void 0 && (t.alt = n.alt), n.title !== null && n.title !== void 0 && (t.title = n.title);
  const r = { type: "element", tagName: "img", properties: t, children: [] };
  return e.patch(n, r), e.applyData(n, r);
}
function qo(e, n) {
  const t = { type: "text", value: n.value.replace(/\r?\n|\r/g, " ") };
  e.patch(n, t);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [t]
  };
  return e.patch(n, r), e.applyData(n, r);
}
function Vo(e, n) {
  const t = e.definition(n.identifier);
  if (!t)
    return Pr(e, n);
  const r = { href: He(t.url || "") };
  t.title !== null && t.title !== void 0 && (r.title = t.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(n)
  };
  return e.patch(n, i), e.applyData(n, i);
}
function Wo(e, n) {
  const t = { href: He(n.url) };
  n.title !== null && n.title !== void 0 && (t.title = n.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: t,
    children: e.all(n)
  };
  return e.patch(n, r), e.applyData(n, r);
}
function Yo(e, n, t) {
  const r = e.all(n), i = t ? Qo(t) : Fr(n), l = {}, o = [];
  if (typeof n.checked == "boolean") {
    const s = r[0];
    let f;
    s && s.type === "element" && s.tagName === "p" ? f = s : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: n.checked, disabled: !0 },
      children: []
    }), l.className = ["task-list-item"];
  }
  let u = -1;
  for (; ++u < r.length; ) {
    const s = r[u];
    (i || u !== 0 || s.type !== "element" || s.tagName !== "p") && o.push({ type: "text", value: `
` }), s.type === "element" && s.tagName === "p" && !i ? o.push(...s.children) : o.push(s);
  }
  const a = r[r.length - 1];
  a && (i || a.type !== "element" || a.tagName !== "p") && o.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: l, children: o };
  return e.patch(n, c), e.applyData(n, c);
}
function Qo(e) {
  let n = !1;
  if (e.type === "list") {
    n = e.spread || !1;
    const t = e.children;
    let r = -1;
    for (; !n && ++r < t.length; )
      n = Fr(t[r]);
  }
  return n;
}
function Fr(e) {
  const n = e.spread;
  return n ?? e.children.length > 1;
}
function Xo(e, n) {
  const t = {}, r = e.all(n);
  let i = -1;
  for (typeof n.start == "number" && n.start !== 1 && (t.start = n.start); ++i < r.length; ) {
    const o = r[i];
    if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {
      t.className = ["contains-task-list"];
      break;
    }
  }
  const l = {
    type: "element",
    tagName: n.ordered ? "ol" : "ul",
    properties: t,
    children: e.wrap(r, !0)
  };
  return e.patch(n, l), e.applyData(n, l);
}
function Go(e, n) {
  const t = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(n)
  };
  return e.patch(n, t), e.applyData(n, t);
}
function Ko(e, n) {
  const t = { type: "root", children: e.wrap(e.all(n)) };
  return e.patch(n, t), e.applyData(n, t);
}
function Zo(e, n) {
  const t = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(n)
  };
  return e.patch(n, t), e.applyData(n, t);
}
const Wn = Ir("start"), Yn = Ir("end");
function Jo(e) {
  return { start: Wn(e), end: Yn(e) };
}
function Ir(e) {
  return n;
  function n(t) {
    const r = t && t.position && t.position[e] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: r.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: r.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: r.offset > -1 ? r.offset : null
    };
  }
}
function eu(e, n) {
  const t = e.all(n), r = t.shift(), i = [];
  if (r) {
    const o = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(n.children[0], o), i.push(o);
  }
  if (t.length > 0) {
    const o = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(t, !0)
    }, u = Wn(n.children[1]), a = Yn(n.children[n.children.length - 1]);
    u.line && a.line && (o.position = { start: u, end: a }), i.push(o);
  }
  const l = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(n, l), e.applyData(n, l);
}
function nu(e, n, t) {
  const r = t ? t.children : void 0, l = (r ? r.indexOf(n) : 1) === 0 ? "th" : "td", o = t && t.type === "table" ? t.align : void 0, u = o ? o.length : n.children.length;
  let a = -1;
  const c = [];
  for (; ++a < u; ) {
    const f = n.children[a], x = {}, d = o ? o[a] : void 0;
    d && (x.align = d);
    let h = { type: "element", tagName: l, properties: x, children: [] };
    f && (h.children = e.all(f), e.patch(f, h), h = e.applyData(n, h)), c.push(h);
  }
  const s = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(n, s), e.applyData(n, s);
}
function tu(e, n) {
  const t = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(n)
  };
  return e.patch(n, t), e.applyData(n, t);
}
const It = 9, Ot = 32;
function ru(e) {
  const n = String(e), t = /\r?\n|\r/g;
  let r = t.exec(n), i = 0;
  const l = [];
  for (; r; )
    l.push(
      Dt(n.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = t.exec(n);
  return l.push(Dt(n.slice(i), i > 0, !1)), l.join("");
}
function Dt(e, n, t) {
  let r = 0, i = e.length;
  if (n) {
    let l = e.codePointAt(r);
    for (; l === It || l === Ot; )
      r++, l = e.codePointAt(r);
  }
  if (t) {
    let l = e.codePointAt(i - 1);
    for (; l === It || l === Ot; )
      i--, l = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function iu(e, n) {
  const t = { type: "text", value: ru(String(n.value)) };
  return e.patch(n, t), e.applyData(n, t);
}
function lu(e, n) {
  const t = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(n, t), e.applyData(n, t);
}
const ou = {
  blockquote: Ro,
  break: zo,
  code: _o,
  delete: Mo,
  emphasis: Bo,
  footnoteReference: Tr,
  footnote: jo,
  heading: No,
  html: Ho,
  imageReference: Uo,
  image: $o,
  inlineCode: qo,
  linkReference: Vo,
  link: Wo,
  listItem: Yo,
  list: Xo,
  paragraph: Go,
  root: Ko,
  strong: Zo,
  table: eu,
  tableCell: tu,
  tableRow: nu,
  text: iu,
  thematicBreak: lu,
  toml: en,
  yaml: en,
  definition: en,
  footnoteDefinition: en
};
function en() {
  return null;
}
const Qn = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(e) {
    if (e == null)
      return cu;
    if (typeof e == "string")
      return su(e);
    if (typeof e == "object")
      return Array.isArray(e) ? uu(e) : au(e);
    if (typeof e == "function")
      return fn(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function uu(e) {
  const n = [];
  let t = -1;
  for (; ++t < e.length; )
    n[t] = Qn(e[t]);
  return fn(r);
  function r(...i) {
    let l = -1;
    for (; ++l < n.length; )
      if (n[l].call(this, ...i))
        return !0;
    return !1;
  }
}
function au(e) {
  return fn(n);
  function n(t) {
    let r;
    for (r in e)
      if (t[r] !== e[r])
        return !1;
    return !0;
  }
}
function su(e) {
  return fn(n);
  function n(t) {
    return t && t.type === e;
  }
}
function fn(e) {
  return n;
  function n(t, ...r) {
    return !!(t && typeof t == "object" && "type" in t && e.call(this, t, ...r));
  }
}
function cu() {
  return !0;
}
const fu = !0, Lt = !1, pu = "skip", Or = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(e, n, t, r) {
    typeof n == "function" && typeof t != "function" && (r = t, t = n, n = null);
    const i = Qn(n), l = r ? -1 : 1;
    o(e, void 0, [])();
    function o(u, a, c) {
      const s = u && typeof u == "object" ? u : {};
      if (typeof s.type == "string") {
        const x = (
          // `hast`
          typeof s.tagName == "string" ? s.tagName : (
            // `xast`
            typeof s.name == "string" ? s.name : void 0
          )
        );
        Object.defineProperty(f, "name", {
          value: "node (" + (u.type + (x ? "<" + x + ">" : "")) + ")"
        });
      }
      return f;
      function f() {
        let x = [], d, h, g;
        if ((!n || i(u, a, c[c.length - 1] || null)) && (x = hu(t(u, c)), x[0] === Lt))
          return x;
        if (u.children && x[0] !== pu)
          for (h = (r ? u.children.length : -1) + l, g = c.concat(u); h > -1 && h < u.children.length; ) {
            if (d = o(u.children[h], h, g)(), d[0] === Lt)
              return d;
            h = typeof d[1] == "number" ? d[1] : h + l;
          }
        return x;
      }
    }
  }
);
function hu(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [fu, e] : [e];
}
const Xn = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(e, n, t, r) {
    typeof n == "function" && typeof t != "function" && (r = t, t = n, n = null), Or(e, n, i, r);
    function i(l, o) {
      const u = o[o.length - 1];
      return t(
        l,
        u ? u.children.indexOf(l) : null,
        u
      );
    }
  }
);
function mu(e) {
  return !e || !e.position || !e.position.start || !e.position.start.line || !e.position.start.column || !e.position.end || !e.position.end.line || !e.position.end.column;
}
const Rt = {}.hasOwnProperty;
function gu(e) {
  const n = /* @__PURE__ */ Object.create(null);
  if (!e || !e.type)
    throw new Error("mdast-util-definitions expected node");
  return Xn(e, "definition", (r) => {
    const i = zt(r.identifier);
    i && !Rt.call(n, i) && (n[i] = r);
  }), t;
  function t(r) {
    const i = zt(r);
    return i && Rt.call(n, i) ? n[i] : null;
  }
}
function zt(e) {
  return String(e || "").toUpperCase();
}
const an = {}.hasOwnProperty;
function du(e, n) {
  const t = n || {}, r = t.allowDangerousHtml || !1, i = {};
  return o.dangerous = r, o.clobberPrefix = t.clobberPrefix === void 0 || t.clobberPrefix === null ? "user-content-" : t.clobberPrefix, o.footnoteLabel = t.footnoteLabel || "Footnotes", o.footnoteLabelTagName = t.footnoteLabelTagName || "h2", o.footnoteLabelProperties = t.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o.footnoteBackLabel = t.footnoteBackLabel || "Back to content", o.unknownHandler = t.unknownHandler, o.passThrough = t.passThrough, o.handlers = { ...ou, ...t.handlers }, o.definition = gu(e), o.footnoteById = i, o.footnoteOrder = [], o.footnoteCounts = {}, o.patch = yu, o.applyData = xu, o.one = u, o.all = a, o.wrap = bu, o.augment = l, Xn(e, "footnoteDefinition", (c) => {
    const s = String(c.identifier).toUpperCase();
    an.call(i, s) || (i[s] = c);
  }), o;
  function l(c, s) {
    if (c && "data" in c && c.data) {
      const f = c.data;
      f.hName && (s.type !== "element" && (s = {
        type: "element",
        tagName: "",
        properties: {},
        children: []
      }), s.tagName = f.hName), s.type === "element" && f.hProperties && (s.properties = { ...s.properties, ...f.hProperties }), "children" in s && s.children && f.hChildren && (s.children = f.hChildren);
    }
    if (c) {
      const f = "type" in c ? c : { position: c };
      mu(f) || (s.position = { start: Wn(f), end: Yn(f) });
    }
    return s;
  }
  function o(c, s, f, x) {
    return Array.isArray(f) && (x = f, f = {}), l(c, {
      type: "element",
      tagName: s,
      properties: f || {},
      children: x || []
    });
  }
  function u(c, s) {
    return Dr(o, c, s);
  }
  function a(c) {
    return Gn(o, c);
  }
}
function yu(e, n) {
  e.position && (n.position = Jo(e));
}
function xu(e, n) {
  let t = n;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, l = e.data.hProperties;
    typeof r == "string" && (t.type === "element" ? t.tagName = r : t = {
      type: "element",
      tagName: r,
      properties: {},
      children: []
    }), t.type === "element" && l && (t.properties = { ...t.properties, ...l }), "children" in t && t.children && i !== null && i !== void 0 && (t.children = i);
  }
  return t;
}
function Dr(e, n, t) {
  const r = n && n.type;
  if (!r)
    throw new Error("Expected node, got `" + n + "`");
  return an.call(e.handlers, r) ? e.handlers[r](e, n, t) : e.passThrough && e.passThrough.includes(r) ? "children" in n ? { ...n, children: Gn(e, n) } : n : e.unknownHandler ? e.unknownHandler(e, n, t) : ku(e, n);
}
function Gn(e, n) {
  const t = [];
  if ("children" in n) {
    const r = n.children;
    let i = -1;
    for (; ++i < r.length; ) {
      const l = Dr(e, r[i], n);
      if (l) {
        if (i && r[i - 1].type === "break" && (!Array.isArray(l) && l.type === "text" && (l.value = l.value.replace(/^\s+/, "")), !Array.isArray(l) && l.type === "element")) {
          const o = l.children[0];
          o && o.type === "text" && (o.value = o.value.replace(/^\s+/, ""));
        }
        Array.isArray(l) ? t.push(...l) : t.push(l);
      }
    }
  }
  return t;
}
function ku(e, n) {
  const t = n.data || {}, r = "value" in n && !(an.call(t, "hProperties") || an.call(t, "hChildren")) ? { type: "text", value: n.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: Gn(e, n)
  };
  return e.patch(n, r), e.applyData(n, r);
}
function bu(e, n) {
  const t = [];
  let r = -1;
  for (n && t.push({ type: "text", value: `
` }); ++r < e.length; )
    r && t.push({ type: "text", value: `
` }), t.push(e[r]);
  return n && e.length > 0 && t.push({ type: "text", value: `
` }), t;
}
function wu(e) {
  const n = [];
  let t = -1;
  for (; ++t < e.footnoteOrder.length; ) {
    const r = e.footnoteById[e.footnoteOrder[t]];
    if (!r)
      continue;
    const i = e.all(r), l = String(r.identifier).toUpperCase(), o = He(l.toLowerCase());
    let u = 0;
    const a = [];
    for (; ++u <= e.footnoteCounts[l]; ) {
      const f = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + e.clobberPrefix + "fnref-" + o + (u > 1 ? "-" + u : ""),
          dataFootnoteBackref: !0,
          className: ["data-footnote-backref"],
          ariaLabel: e.footnoteBackLabel
        },
        children: [{ type: "text", value: "↩" }]
      };
      u > 1 && f.children.push({
        type: "element",
        tagName: "sup",
        children: [{ type: "text", value: String(u) }]
      }), a.length > 0 && a.push({ type: "text", value: " " }), a.push(f);
    }
    const c = i[i.length - 1];
    if (c && c.type === "element" && c.tagName === "p") {
      const f = c.children[c.children.length - 1];
      f && f.type === "text" ? f.value += " " : c.children.push({ type: "text", value: " " }), c.children.push(...a);
    } else
      i.push(...a);
    const s = {
      type: "element",
      tagName: "li",
      properties: { id: e.clobberPrefix + "fn-" + o },
      children: e.wrap(i, !0)
    };
    e.patch(r, s), n.push(s);
  }
  if (n.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: e.footnoteLabelTagName,
          properties: {
            // To do: use structured clone.
            ...JSON.parse(JSON.stringify(e.footnoteLabelProperties)),
            id: "footnote-label"
          },
          children: [{ type: "text", value: e.footnoteLabel }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(n, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
function Lr(e, n) {
  const t = du(e, n), r = t.one(e, null), i = wu(t);
  return i && r.children.push({ type: "text", value: `
` }, i), Array.isArray(r) ? { type: "root", children: r } : r;
}
const Su = (
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  function(e, n) {
    return e && "run" in e ? Eu(e, n) : Au(e || n);
  }
), Cu = Su;
function Eu(e, n) {
  return (t, r, i) => {
    e.run(Lr(t, n), r, (l) => {
      i(l);
    });
  };
}
function Au(e) {
  return (n) => Lr(n, e);
}
var Bn = { exports: {} }, Sn, _t;
function Kn() {
  if (_t)
    return Sn;
  _t = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Sn = e, Sn;
}
var Cn, Mt;
function Rr() {
  return Mt || (Mt = 1, Cn = Function.call.bind(Object.prototype.hasOwnProperty)), Cn;
}
var En, Bt;
function vu() {
  if (Bt)
    return En;
  Bt = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var n = Kn(), t = {}, r = Rr();
    e = function(l) {
      var o = "Warning: " + l;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(l, o, u, a, c) {
    if (process.env.NODE_ENV !== "production") {
      for (var s in l)
        if (r(l, s)) {
          var f;
          try {
            if (typeof l[s] != "function") {
              var x = Error(
                (a || "React class") + ": " + u + " type `" + s + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[s] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw x.name = "Invariant Violation", x;
            }
            f = l[s](o, s, a, u, null, n);
          } catch (h) {
            f = h;
          }
          if (f && !(f instanceof Error) && e(
            (a || "React class") + ": type specification of " + u + " `" + s + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in t)) {
            t[f.message] = !0;
            var d = c ? c() : "";
            e(
              "Failed " + u + " type: " + f.message + (d ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (t = {});
  }, En = i, En;
}
var An, jt;
function Tu() {
  if (jt)
    return An;
  jt = 1;
  var e = or, n = mi(), t = Kn(), r = Rr(), i = vu(), l = function() {
  };
  process.env.NODE_ENV !== "production" && (l = function(u) {
    var a = "Warning: " + u;
    typeof console < "u" && console.error(a);
    try {
      throw new Error(a);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return An = function(u, a) {
    var c = typeof Symbol == "function" && Symbol.iterator, s = "@@iterator";
    function f(C) {
      var p = C && (c && C[c] || C[s]);
      if (typeof p == "function")
        return p;
    }
    var x = "<<anonymous>>", d = {
      array: k("array"),
      bigint: k("bigint"),
      bool: k("boolean"),
      func: k("function"),
      number: k("number"),
      object: k("object"),
      string: k("string"),
      symbol: k("symbol"),
      any: P(),
      arrayOf: A,
      element: O(),
      elementType: F(),
      instanceOf: w,
      node: b(),
      objectOf: j,
      oneOf: I,
      oneOfType: W,
      shape: L,
      exact: Y
    };
    function h(C, p) {
      return C === p ? C !== 0 || 1 / C === 1 / p : C !== C && p !== p;
    }
    function g(C, p) {
      this.message = C, this.data = p && typeof p == "object" ? p : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function y(C) {
      if (process.env.NODE_ENV !== "production")
        var p = {}, m = 0;
      function H(q, D, _, U, Q, V, fe) {
        if (U = U || x, V = V || _, fe !== t) {
          if (a) {
            var ce = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw ce.name = "Invariant Violation", ce;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Ce = U + ":" + _;
            !p[Ce] && // Avoid spamming the console because they are often not actionable except for lib authors
            m < 3 && (l(
              "You are manually calling a React.PropTypes validation function for the `" + V + "` prop on `" + U + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), p[Ce] = !0, m++);
          }
        }
        return D[_] == null ? q ? D[_] === null ? new g("The " + Q + " `" + V + "` is marked as required " + ("in `" + U + "`, but its value is `null`.")) : new g("The " + Q + " `" + V + "` is marked as required in " + ("`" + U + "`, but its value is `undefined`.")) : null : C(D, _, U, Q, V);
      }
      var B = H.bind(null, !1);
      return B.isRequired = H.bind(null, !0), B;
    }
    function k(C) {
      function p(m, H, B, q, D, _) {
        var U = m[H], Q = le(U);
        if (Q !== C) {
          var V = ae(U);
          return new g(
            "Invalid " + q + " `" + D + "` of type " + ("`" + V + "` supplied to `" + B + "`, expected ") + ("`" + C + "`."),
            { expectedType: C }
          );
        }
        return null;
      }
      return y(p);
    }
    function P() {
      return y(o);
    }
    function A(C) {
      function p(m, H, B, q, D) {
        if (typeof C != "function")
          return new g("Property `" + D + "` of component `" + B + "` has invalid PropType notation inside arrayOf.");
        var _ = m[H];
        if (!Array.isArray(_)) {
          var U = le(_);
          return new g("Invalid " + q + " `" + D + "` of type " + ("`" + U + "` supplied to `" + B + "`, expected an array."));
        }
        for (var Q = 0; Q < _.length; Q++) {
          var V = C(_, Q, B, q, D + "[" + Q + "]", t);
          if (V instanceof Error)
            return V;
        }
        return null;
      }
      return y(p);
    }
    function O() {
      function C(p, m, H, B, q) {
        var D = p[m];
        if (!u(D)) {
          var _ = le(D);
          return new g("Invalid " + B + " `" + q + "` of type " + ("`" + _ + "` supplied to `" + H + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(C);
    }
    function F() {
      function C(p, m, H, B, q) {
        var D = p[m];
        if (!e.isValidElementType(D)) {
          var _ = le(D);
          return new g("Invalid " + B + " `" + q + "` of type " + ("`" + _ + "` supplied to `" + H + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(C);
    }
    function w(C) {
      function p(m, H, B, q, D) {
        if (!(m[H] instanceof C)) {
          var _ = C.name || x, U = se(m[H]);
          return new g("Invalid " + q + " `" + D + "` of type " + ("`" + U + "` supplied to `" + B + "`, expected ") + ("instance of `" + _ + "`."));
        }
        return null;
      }
      return y(p);
    }
    function I(C) {
      if (!Array.isArray(C))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? l(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : l("Invalid argument supplied to oneOf, expected an array.")), o;
      function p(m, H, B, q, D) {
        for (var _ = m[H], U = 0; U < C.length; U++)
          if (h(_, C[U]))
            return null;
        var Q = JSON.stringify(C, function(fe, ce) {
          var Ce = ae(ce);
          return Ce === "symbol" ? String(ce) : ce;
        });
        return new g("Invalid " + q + " `" + D + "` of value `" + String(_) + "` " + ("supplied to `" + B + "`, expected one of " + Q + "."));
      }
      return y(p);
    }
    function j(C) {
      function p(m, H, B, q, D) {
        if (typeof C != "function")
          return new g("Property `" + D + "` of component `" + B + "` has invalid PropType notation inside objectOf.");
        var _ = m[H], U = le(_);
        if (U !== "object")
          return new g("Invalid " + q + " `" + D + "` of type " + ("`" + U + "` supplied to `" + B + "`, expected an object."));
        for (var Q in _)
          if (r(_, Q)) {
            var V = C(_, Q, B, q, D + "." + Q, t);
            if (V instanceof Error)
              return V;
          }
        return null;
      }
      return y(p);
    }
    function W(C) {
      if (!Array.isArray(C))
        return process.env.NODE_ENV !== "production" && l("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var p = 0; p < C.length; p++) {
        var m = C[p];
        if (typeof m != "function")
          return l(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ie(m) + " at index " + p + "."
          ), o;
      }
      function H(B, q, D, _, U) {
        for (var Q = [], V = 0; V < C.length; V++) {
          var fe = C[V], ce = fe(B, q, D, _, U, t);
          if (ce == null)
            return null;
          ce.data && r(ce.data, "expectedType") && Q.push(ce.data.expectedType);
        }
        var Ce = Q.length > 0 ? ", expected one of type [" + Q.join(", ") + "]" : "";
        return new g("Invalid " + _ + " `" + U + "` supplied to " + ("`" + D + "`" + Ce + "."));
      }
      return y(H);
    }
    function b() {
      function C(p, m, H, B, q) {
        return J(p[m]) ? null : new g("Invalid " + B + " `" + q + "` supplied to " + ("`" + H + "`, expected a ReactNode."));
      }
      return y(C);
    }
    function v(C, p, m, H, B) {
      return new g(
        (C || "React class") + ": " + p + " type `" + m + "." + H + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + B + "`."
      );
    }
    function L(C) {
      function p(m, H, B, q, D) {
        var _ = m[H], U = le(_);
        if (U !== "object")
          return new g("Invalid " + q + " `" + D + "` of type `" + U + "` " + ("supplied to `" + B + "`, expected `object`."));
        for (var Q in C) {
          var V = C[Q];
          if (typeof V != "function")
            return v(B, q, D, Q, ae(V));
          var fe = V(_, Q, B, q, D + "." + Q, t);
          if (fe)
            return fe;
        }
        return null;
      }
      return y(p);
    }
    function Y(C) {
      function p(m, H, B, q, D) {
        var _ = m[H], U = le(_);
        if (U !== "object")
          return new g("Invalid " + q + " `" + D + "` of type `" + U + "` " + ("supplied to `" + B + "`, expected `object`."));
        var Q = n({}, m[H], C);
        for (var V in Q) {
          var fe = C[V];
          if (r(C, V) && typeof fe != "function")
            return v(B, q, D, V, ae(fe));
          if (!fe)
            return new g(
              "Invalid " + q + " `" + D + "` key `" + V + "` supplied to `" + B + "`.\nBad object: " + JSON.stringify(m[H], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(C), null, "  ")
            );
          var ce = fe(_, V, B, q, D + "." + V, t);
          if (ce)
            return ce;
        }
        return null;
      }
      return y(p);
    }
    function J(C) {
      switch (typeof C) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !C;
        case "object":
          if (Array.isArray(C))
            return C.every(J);
          if (C === null || u(C))
            return !0;
          var p = f(C);
          if (p) {
            var m = p.call(C), H;
            if (p !== C.entries) {
              for (; !(H = m.next()).done; )
                if (!J(H.value))
                  return !1;
            } else
              for (; !(H = m.next()).done; ) {
                var B = H.value;
                if (B && !J(B[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function he(C, p) {
      return C === "symbol" ? !0 : p ? p["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && p instanceof Symbol : !1;
    }
    function le(C) {
      var p = typeof C;
      return Array.isArray(C) ? "array" : C instanceof RegExp ? "object" : he(p, C) ? "symbol" : p;
    }
    function ae(C) {
      if (typeof C > "u" || C === null)
        return "" + C;
      var p = le(C);
      if (p === "object") {
        if (C instanceof Date)
          return "date";
        if (C instanceof RegExp)
          return "regexp";
      }
      return p;
    }
    function ie(C) {
      var p = ae(C);
      switch (p) {
        case "array":
        case "object":
          return "an " + p;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + p;
        default:
          return p;
      }
    }
    function se(C) {
      return !C.constructor || !C.constructor.name ? x : C.constructor.name;
    }
    return d.checkPropTypes = i, d.resetWarningCache = i.resetWarningCache, d.PropTypes = d, d;
  }, An;
}
var vn, Nt;
function Pu() {
  if (Nt)
    return vn;
  Nt = 1;
  var e = Kn();
  function n() {
  }
  function t() {
  }
  return t.resetWarningCache = n, vn = function() {
    function r(o, u, a, c, s, f) {
      if (f !== e) {
        var x = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw x.name = "Invariant Violation", x;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var l = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: t,
      resetWarningCache: n
    };
    return l.PropTypes = l, l;
  }, vn;
}
if (process.env.NODE_ENV !== "production") {
  var Fu = or, Iu = !0;
  Bn.exports = Tu()(Fu.isElement, Iu);
} else
  Bn.exports = Pu()();
var Ou = Bn.exports;
const N = /* @__PURE__ */ Ge(Ou);
class Je {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(n, t, r) {
    this.property = n, this.normal = t, r && (this.space = r);
  }
}
Je.prototype.property = {};
Je.prototype.normal = {};
Je.prototype.space = null;
function zr(e, n) {
  const t = {}, r = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(t, e[i].property), Object.assign(r, e[i].normal);
  return new Je(t, r, n);
}
function jn(e) {
  return e.toLowerCase();
}
class be {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(n, t) {
    this.property = n, this.attribute = t;
  }
}
be.prototype.space = null;
be.prototype.boolean = !1;
be.prototype.booleanish = !1;
be.prototype.overloadedBoolean = !1;
be.prototype.number = !1;
be.prototype.commaSeparated = !1;
be.prototype.spaceSeparated = !1;
be.prototype.commaOrSpaceSeparated = !1;
be.prototype.mustUseProperty = !1;
be.prototype.defined = !1;
let Du = 0;
const $ = Me(), ue = Me(), _r = Me(), E = Me(), te = Me(), Ne = Me(), de = Me();
function Me() {
  return 2 ** ++Du;
}
const Nn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: $,
  booleanish: ue,
  commaOrSpaceSeparated: de,
  commaSeparated: Ne,
  number: E,
  overloadedBoolean: _r,
  spaceSeparated: te
}, Symbol.toStringTag, { value: "Module" })), Tn = Object.keys(Nn);
class Zn extends be {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(n, t, r, i) {
    let l = -1;
    if (super(n, t), Ht(this, "space", i), typeof r == "number")
      for (; ++l < Tn.length; ) {
        const o = Tn[l];
        Ht(this, Tn[l], (r & Nn[o]) === Nn[o]);
      }
  }
}
Zn.prototype.defined = !0;
function Ht(e, n, t) {
  t && (e[n] = t);
}
const Lu = {}.hasOwnProperty;
function Ue(e) {
  const n = {}, t = {};
  let r;
  for (r in e.properties)
    if (Lu.call(e.properties, r)) {
      const i = e.properties[r], l = new Zn(
        r,
        e.transform(e.attributes || {}, r),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (l.mustUseProperty = !0), n[r] = l, t[jn(r)] = r, t[jn(l.attribute)] = r;
    }
  return new Je(n, t, e.space);
}
const Mr = Ue({
  space: "xlink",
  transform(e, n) {
    return "xlink:" + n.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Br = Ue({
  space: "xml",
  transform(e, n) {
    return "xml:" + n.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function jr(e, n) {
  return n in e ? e[n] : n;
}
function Nr(e, n) {
  return jr(e, n.toLowerCase());
}
const Hr = Ue({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Nr,
  properties: { xmlns: null, xmlnsXLink: null }
}), Ur = Ue({
  transform(e, n) {
    return n === "role" ? n : "aria-" + n.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: ue,
    ariaAutoComplete: null,
    ariaBusy: ue,
    ariaChecked: ue,
    ariaColCount: E,
    ariaColIndex: E,
    ariaColSpan: E,
    ariaControls: te,
    ariaCurrent: null,
    ariaDescribedBy: te,
    ariaDetails: null,
    ariaDisabled: ue,
    ariaDropEffect: te,
    ariaErrorMessage: null,
    ariaExpanded: ue,
    ariaFlowTo: te,
    ariaGrabbed: ue,
    ariaHasPopup: null,
    ariaHidden: ue,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: te,
    ariaLevel: E,
    ariaLive: null,
    ariaModal: ue,
    ariaMultiLine: ue,
    ariaMultiSelectable: ue,
    ariaOrientation: null,
    ariaOwns: te,
    ariaPlaceholder: null,
    ariaPosInSet: E,
    ariaPressed: ue,
    ariaReadOnly: ue,
    ariaRelevant: null,
    ariaRequired: ue,
    ariaRoleDescription: te,
    ariaRowCount: E,
    ariaRowIndex: E,
    ariaRowSpan: E,
    ariaSelected: ue,
    ariaSetSize: E,
    ariaSort: null,
    ariaValueMax: E,
    ariaValueMin: E,
    ariaValueNow: E,
    ariaValueText: null,
    role: null
  }
}), Ru = Ue({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Nr,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Ne,
    acceptCharset: te,
    accessKey: te,
    action: null,
    allow: null,
    allowFullScreen: $,
    allowPaymentRequest: $,
    allowUserMedia: $,
    alt: null,
    as: null,
    async: $,
    autoCapitalize: null,
    autoComplete: te,
    autoFocus: $,
    autoPlay: $,
    capture: $,
    charSet: null,
    checked: $,
    cite: null,
    className: te,
    cols: E,
    colSpan: null,
    content: null,
    contentEditable: ue,
    controls: $,
    controlsList: te,
    coords: E | Ne,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: $,
    defer: $,
    dir: null,
    dirName: null,
    disabled: $,
    download: _r,
    draggable: ue,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: $,
    formTarget: null,
    headers: te,
    height: E,
    hidden: $,
    high: E,
    href: null,
    hrefLang: null,
    htmlFor: te,
    httpEquiv: te,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: $,
    itemId: null,
    itemProp: te,
    itemRef: te,
    itemScope: $,
    itemType: te,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: $,
    low: E,
    manifest: null,
    max: null,
    maxLength: E,
    media: null,
    method: null,
    min: null,
    minLength: E,
    multiple: $,
    muted: $,
    name: null,
    nonce: null,
    noModule: $,
    noValidate: $,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: $,
    optimum: E,
    pattern: null,
    ping: te,
    placeholder: null,
    playsInline: $,
    poster: null,
    preload: null,
    readOnly: $,
    referrerPolicy: null,
    rel: te,
    required: $,
    reversed: $,
    rows: E,
    rowSpan: E,
    sandbox: te,
    scope: null,
    scoped: $,
    seamless: $,
    selected: $,
    shape: null,
    size: E,
    sizes: null,
    slot: null,
    span: E,
    spellCheck: ue,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: E,
    step: null,
    style: null,
    tabIndex: E,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: $,
    useMap: null,
    value: ue,
    width: E,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: te,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: E,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: E,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: $,
    // Lists. Use CSS to reduce space between items instead
    declare: $,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: E,
    // `<img>` and `<object>`
    leftMargin: E,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: E,
    // `<body>`
    marginWidth: E,
    // `<body>`
    noResize: $,
    // `<frame>`
    noHref: $,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: $,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: $,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: E,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: ue,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: E,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: E,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: $,
    disableRemotePlayback: $,
    prefix: null,
    property: null,
    results: E,
    security: null,
    unselectable: null
  }
}), zu = Ue({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: jr,
  properties: {
    about: de,
    accentHeight: E,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: E,
    amplitude: E,
    arabicForm: null,
    ascent: E,
    attributeName: null,
    attributeType: null,
    azimuth: E,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: E,
    by: null,
    calcMode: null,
    capHeight: E,
    className: te,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: E,
    diffuseConstant: E,
    direction: null,
    display: null,
    dur: null,
    divisor: E,
    dominantBaseline: null,
    download: $,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: E,
    enableBackground: null,
    end: null,
    event: null,
    exponent: E,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: E,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Ne,
    g2: Ne,
    glyphName: Ne,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: E,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: E,
    horizOriginX: E,
    horizOriginY: E,
    id: null,
    ideographic: E,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: E,
    k: E,
    k1: E,
    k2: E,
    k3: E,
    k4: E,
    kernelMatrix: de,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: E,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: E,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: E,
    overlineThickness: E,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: E,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: te,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: E,
    pointsAtY: E,
    pointsAtZ: E,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: de,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: de,
    rev: de,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: de,
    requiredFeatures: de,
    requiredFonts: de,
    requiredFormats: de,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: E,
    specularExponent: E,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: E,
    strikethroughThickness: E,
    string: null,
    stroke: null,
    strokeDashArray: de,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: E,
    strokeOpacity: E,
    strokeWidth: null,
    style: null,
    surfaceScale: E,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: de,
    tabIndex: E,
    tableValues: null,
    target: null,
    targetX: E,
    targetY: E,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: de,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: E,
    underlineThickness: E,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: E,
    values: null,
    vAlphabetic: E,
    vMathematical: E,
    vectorEffect: null,
    vHanging: E,
    vIdeographic: E,
    version: null,
    vertAdvY: E,
    vertOriginX: E,
    vertOriginY: E,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: E,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), _u = /^data[-\w.:]+$/i, Ut = /-[a-z]/g, Mu = /[A-Z]/g;
function Bu(e, n) {
  const t = jn(n);
  let r = n, i = be;
  if (t in e.normal)
    return e.property[e.normal[t]];
  if (t.length > 4 && t.slice(0, 4) === "data" && _u.test(n)) {
    if (n.charAt(4) === "-") {
      const l = n.slice(5).replace(Ut, Nu);
      r = "data" + l.charAt(0).toUpperCase() + l.slice(1);
    } else {
      const l = n.slice(4);
      if (!Ut.test(l)) {
        let o = l.replace(Mu, ju);
        o.charAt(0) !== "-" && (o = "-" + o), n = "data" + o;
      }
    }
    i = Zn;
  }
  return new i(r, n);
}
function ju(e) {
  return "-" + e.toLowerCase();
}
function Nu(e) {
  return e.charAt(1).toUpperCase();
}
const $t = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, Hu = zr([Br, Mr, Hr, Ur, Ru], "html"), Uu = zr([Br, Mr, Hr, Ur, zu], "svg");
function $u(e) {
  if (e.allowedElements && e.disallowedElements)
    throw new TypeError(
      "Only one of `allowedElements` and `disallowedElements` should be defined"
    );
  if (e.allowedElements || e.disallowedElements || e.allowElement)
    return (n) => {
      Xn(n, "element", (t, r, i) => {
        const l = (
          /** @type {Element|Root} */
          i
        );
        let o;
        if (e.allowedElements ? o = !e.allowedElements.includes(t.tagName) : e.disallowedElements && (o = e.disallowedElements.includes(t.tagName)), !o && e.allowElement && typeof r == "number" && (o = !e.allowElement(t, r, l)), o && typeof r == "number")
          return e.unwrapDisallowed && t.children ? l.children.splice(r, 1, ...t.children) : l.children.splice(r, 1), r;
      });
    };
}
var Hn = { exports: {} }, G = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qt;
function qu() {
  if (qt)
    return G;
  qt = 1;
  var e = Symbol.for("react.element"), n = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), o = Symbol.for("react.context"), u = Symbol.for("react.server_context"), a = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), s = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), d = Symbol.for("react.offscreen"), h;
  h = Symbol.for("react.module.reference");
  function g(y) {
    if (typeof y == "object" && y !== null) {
      var k = y.$$typeof;
      switch (k) {
        case e:
          switch (y = y.type, y) {
            case t:
            case i:
            case r:
            case c:
            case s:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case u:
                case o:
                case a:
                case x:
                case f:
                case l:
                  return y;
                default:
                  return k;
              }
          }
        case n:
          return k;
      }
    }
  }
  return G.ContextConsumer = o, G.ContextProvider = l, G.Element = e, G.ForwardRef = a, G.Fragment = t, G.Lazy = x, G.Memo = f, G.Portal = n, G.Profiler = i, G.StrictMode = r, G.Suspense = c, G.SuspenseList = s, G.isAsyncMode = function() {
    return !1;
  }, G.isConcurrentMode = function() {
    return !1;
  }, G.isContextConsumer = function(y) {
    return g(y) === o;
  }, G.isContextProvider = function(y) {
    return g(y) === l;
  }, G.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === e;
  }, G.isForwardRef = function(y) {
    return g(y) === a;
  }, G.isFragment = function(y) {
    return g(y) === t;
  }, G.isLazy = function(y) {
    return g(y) === x;
  }, G.isMemo = function(y) {
    return g(y) === f;
  }, G.isPortal = function(y) {
    return g(y) === n;
  }, G.isProfiler = function(y) {
    return g(y) === i;
  }, G.isStrictMode = function(y) {
    return g(y) === r;
  }, G.isSuspense = function(y) {
    return g(y) === c;
  }, G.isSuspenseList = function(y) {
    return g(y) === s;
  }, G.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === t || y === i || y === r || y === c || y === s || y === d || typeof y == "object" && y !== null && (y.$$typeof === x || y.$$typeof === f || y.$$typeof === l || y.$$typeof === o || y.$$typeof === a || y.$$typeof === h || y.getModuleId !== void 0);
  }, G.typeOf = g, G;
}
var K = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Vt;
function Vu() {
  return Vt || (Vt = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), n = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), o = Symbol.for("react.context"), u = Symbol.for("react.server_context"), a = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), s = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), d = Symbol.for("react.offscreen"), h = !1, g = !1, y = !1, k = !1, P = !1, A;
    A = Symbol.for("react.module.reference");
    function O(R) {
      return !!(typeof R == "string" || typeof R == "function" || R === t || R === i || P || R === r || R === c || R === s || k || R === d || h || g || y || typeof R == "object" && R !== null && (R.$$typeof === x || R.$$typeof === f || R.$$typeof === l || R.$$typeof === o || R.$$typeof === a || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      R.$$typeof === A || R.getModuleId !== void 0));
    }
    function F(R) {
      if (typeof R == "object" && R !== null) {
        var $e = R.$$typeof;
        switch ($e) {
          case e:
            var Le = R.type;
            switch (Le) {
              case t:
              case i:
              case r:
              case c:
              case s:
                return Le;
              default:
                var qe = Le && Le.$$typeof;
                switch (qe) {
                  case u:
                  case o:
                  case a:
                  case x:
                  case f:
                  case l:
                    return qe;
                  default:
                    return $e;
                }
            }
          case n:
            return $e;
        }
      }
    }
    var w = o, I = l, j = e, W = a, b = t, v = x, L = f, Y = n, J = i, he = r, le = c, ae = s, ie = !1, se = !1;
    function C(R) {
      return ie || (ie = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function p(R) {
      return se || (se = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function m(R) {
      return F(R) === o;
    }
    function H(R) {
      return F(R) === l;
    }
    function B(R) {
      return typeof R == "object" && R !== null && R.$$typeof === e;
    }
    function q(R) {
      return F(R) === a;
    }
    function D(R) {
      return F(R) === t;
    }
    function _(R) {
      return F(R) === x;
    }
    function U(R) {
      return F(R) === f;
    }
    function Q(R) {
      return F(R) === n;
    }
    function V(R) {
      return F(R) === i;
    }
    function fe(R) {
      return F(R) === r;
    }
    function ce(R) {
      return F(R) === c;
    }
    function Ce(R) {
      return F(R) === s;
    }
    K.ContextConsumer = w, K.ContextProvider = I, K.Element = j, K.ForwardRef = W, K.Fragment = b, K.Lazy = v, K.Memo = L, K.Portal = Y, K.Profiler = J, K.StrictMode = he, K.Suspense = le, K.SuspenseList = ae, K.isAsyncMode = C, K.isConcurrentMode = p, K.isContextConsumer = m, K.isContextProvider = H, K.isElement = B, K.isForwardRef = q, K.isFragment = D, K.isLazy = _, K.isMemo = U, K.isPortal = Q, K.isProfiler = V, K.isStrictMode = fe, K.isSuspense = ce, K.isSuspenseList = Ce, K.isValidElementType = O, K.typeOf = F;
  }()), K;
}
process.env.NODE_ENV === "production" ? Hn.exports = qu() : Hn.exports = Vu();
var Wu = Hn.exports;
const Yu = /* @__PURE__ */ Ge(Wu);
function Qu(e) {
  const n = (
    // @ts-expect-error looks like a node.
    e && typeof e == "object" && e.type === "text" ? (
      // @ts-expect-error looks like a text.
      e.value || ""
    ) : e
  );
  return typeof n == "string" && n.replace(/[ \t\n\f\r]/g, "") === "";
}
function Xu(e) {
  return e.join(" ").trim();
}
function Gu(e, n) {
  const t = n || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (t.padRight ? " " : "") + "," + (t.padLeft === !1 ? "" : " ")
  ).trim();
}
var Jn = { exports: {} }, Wt = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Ku = /\n/g, Zu = /^\s*/, Ju = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, ea = /^:\s*/, na = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, ta = /^[;\s]*/, ra = /^\s+|\s+$/g, ia = `
`, Yt = "/", Qt = "*", ze = "", la = "comment", oa = "declaration", ua = function(e, n) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  n = n || {};
  var t = 1, r = 1;
  function i(h) {
    var g = h.match(Ku);
    g && (t += g.length);
    var y = h.lastIndexOf(ia);
    r = ~y ? h.length - y : r + h.length;
  }
  function l() {
    var h = { line: t, column: r };
    return function(g) {
      return g.position = new o(h), c(), g;
    };
  }
  function o(h) {
    this.start = h, this.end = { line: t, column: r }, this.source = n.source;
  }
  o.prototype.content = e;
  function u(h) {
    var g = new Error(
      n.source + ":" + t + ":" + r + ": " + h
    );
    if (g.reason = h, g.filename = n.source, g.line = t, g.column = r, g.source = e, !n.silent)
      throw g;
  }
  function a(h) {
    var g = h.exec(e);
    if (g) {
      var y = g[0];
      return i(y), e = e.slice(y.length), g;
    }
  }
  function c() {
    a(Zu);
  }
  function s(h) {
    var g;
    for (h = h || []; g = f(); )
      g !== !1 && h.push(g);
    return h;
  }
  function f() {
    var h = l();
    if (!(Yt != e.charAt(0) || Qt != e.charAt(1))) {
      for (var g = 2; ze != e.charAt(g) && (Qt != e.charAt(g) || Yt != e.charAt(g + 1)); )
        ++g;
      if (g += 2, ze === e.charAt(g - 1))
        return u("End of comment missing");
      var y = e.slice(2, g - 2);
      return r += 2, i(y), e = e.slice(g), r += 2, h({
        type: la,
        comment: y
      });
    }
  }
  function x() {
    var h = l(), g = a(Ju);
    if (g) {
      if (f(), !a(ea))
        return u("property missing ':'");
      var y = a(na), k = h({
        type: oa,
        property: Xt(g[0].replace(Wt, ze)),
        value: y ? Xt(y[0].replace(Wt, ze)) : ze
      });
      return a(ta), k;
    }
  }
  function d() {
    var h = [];
    s(h);
    for (var g; g = x(); )
      g !== !1 && (h.push(g), s(h));
    return h;
  }
  return c(), d();
};
function Xt(e) {
  return e ? e.replace(ra, ze) : ze;
}
var aa = ua;
function $r(e, n) {
  var t = null;
  if (!e || typeof e != "string")
    return t;
  for (var r, i = aa(e), l = typeof n == "function", o, u, a = 0, c = i.length; a < c; a++)
    r = i[a], o = r.property, u = r.value, l ? n(o, u, r) : u && (t || (t = {}), t[o] = u);
  return t;
}
Jn.exports = $r;
Jn.exports.default = $r;
var sa = Jn.exports;
const ca = /* @__PURE__ */ Ge(sa), Un = {}.hasOwnProperty, fa = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function qr(e, n) {
  const t = [];
  let r = -1, i;
  for (; ++r < n.children.length; )
    i = n.children[r], i.type === "element" ? t.push(pa(e, i, r, n)) : i.type === "text" ? (n.type !== "element" || !fa.has(n.tagName) || !Qu(i)) && t.push(i.value) : i.type === "raw" && !e.options.skipHtml && t.push(i.value);
  return t;
}
function pa(e, n, t, r) {
  const i = e.options, l = i.transformLinkUri === void 0 ? gi : i.transformLinkUri, o = e.schema, u = n.tagName, a = {};
  let c = o, s;
  if (o.space === "html" && u === "svg" && (c = Uu, e.schema = c), n.properties)
    for (s in n.properties)
      Un.call(n.properties, s) && ma(a, s, n.properties[s], e);
  (u === "ol" || u === "ul") && e.listDepth++;
  const f = qr(e, n);
  (u === "ol" || u === "ul") && e.listDepth--, e.schema = o;
  const x = n.position || {
    start: { line: null, column: null, offset: null },
    end: { line: null, column: null, offset: null }
  }, d = i.components && Un.call(i.components, u) ? i.components[u] : u, h = typeof d == "string" || d === je.Fragment;
  if (!Yu.isValidElementType(d))
    throw new TypeError(
      `Component for name \`${u}\` not defined or is not renderable`
    );
  if (a.key = t, u === "a" && i.linkTarget && (a.target = typeof i.linkTarget == "function" ? i.linkTarget(
    String(a.href || ""),
    n.children,
    typeof a.title == "string" ? a.title : null
  ) : i.linkTarget), u === "a" && l && (a.href = l(
    String(a.href || ""),
    n.children,
    typeof a.title == "string" ? a.title : null
  )), !h && u === "code" && r.type === "element" && r.tagName !== "pre" && (a.inline = !0), !h && (u === "h1" || u === "h2" || u === "h3" || u === "h4" || u === "h5" || u === "h6") && (a.level = Number.parseInt(u.charAt(1), 10)), u === "img" && i.transformImageUri && (a.src = i.transformImageUri(
    String(a.src || ""),
    String(a.alt || ""),
    typeof a.title == "string" ? a.title : null
  )), !h && u === "li" && r.type === "element") {
    const g = ha(n);
    a.checked = g && g.properties ? !!g.properties.checked : null, a.index = Pn(r, n), a.ordered = r.tagName === "ol";
  }
  return !h && (u === "ol" || u === "ul") && (a.ordered = u === "ol", a.depth = e.listDepth), (u === "td" || u === "th") && (a.align && (a.style || (a.style = {}), a.style.textAlign = a.align, delete a.align), h || (a.isHeader = u === "th")), !h && u === "tr" && r.type === "element" && (a.isHeader = r.tagName === "thead"), i.sourcePos && (a["data-sourcepos"] = ya(x)), !h && i.rawSourcePos && (a.sourcePosition = n.position), !h && i.includeElementIndex && (a.index = Pn(r, n), a.siblingCount = Pn(r)), h || (a.node = n), f.length > 0 ? je.createElement(d, a, f) : je.createElement(d, a);
}
function ha(e) {
  let n = -1;
  for (; ++n < e.children.length; ) {
    const t = e.children[n];
    if (t.type === "element" && t.tagName === "input")
      return t;
  }
  return null;
}
function Pn(e, n) {
  let t = -1, r = 0;
  for (; ++t < e.children.length && e.children[t] !== n; )
    e.children[t].type === "element" && r++;
  return r;
}
function ma(e, n, t, r) {
  const i = Bu(r.schema, n);
  let l = t;
  l == null || l !== l || (Array.isArray(l) && (l = i.commaSeparated ? Gu(l) : Xu(l)), i.property === "style" && typeof l == "string" && (l = ga(l)), i.space && i.property ? e[Un.call($t, i.property) ? $t[i.property] : i.property] = l : i.attribute && (e[i.attribute] = l));
}
function ga(e) {
  const n = {};
  try {
    ca(e, t);
  } catch {
  }
  return n;
  function t(r, i) {
    const l = r.slice(0, 4) === "-ms-" ? `ms-${r.slice(4)}` : r;
    n[l.replace(/-([a-z])/g, da)] = i;
  }
}
function da(e, n) {
  return n.toUpperCase();
}
function ya(e) {
  return [
    e.start.line,
    ":",
    e.start.column,
    "-",
    e.end.line,
    ":",
    e.end.column
  ].map(String).join("");
}
const Gt = {}.hasOwnProperty, xa = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", nn = {
  plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },
  renderers: { to: "components", id: "change-renderers-to-components" },
  astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
  allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
  escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
  source: { to: "children", id: "change-source-to-children" },
  allowNode: {
    to: "allowElement",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  allowedTypes: {
    to: "allowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  disallowedTypes: {
    to: "disallowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  includeNodeIndex: {
    to: "includeElementIndex",
    id: "change-includenodeindex-to-includeelementindex"
  }
};
function Vr(e) {
  for (const l in nn)
    if (Gt.call(nn, l) && Gt.call(e, l)) {
      const o = nn[l];
      console.warn(
        `[react-markdown] Warning: please ${o.to ? `use \`${o.to}\` instead of` : "remove"} \`${l}\` (see <${xa}#${o.id}> for more info)`
      ), delete nn[l];
    }
  const n = Oi().use(Lo).use(e.remarkPlugins || []).use(Cu, {
    ...e.remarkRehypeOptions,
    allowDangerousHtml: !0
  }).use(e.rehypePlugins || []).use($u, e), t = new ar();
  typeof e.children == "string" ? t.value = e.children : e.children !== void 0 && e.children !== null && console.warn(
    `[react-markdown] Warning: please pass a string as \`children\` (not: \`${e.children}\`)`
  );
  const r = n.runSync(n.parse(t), t);
  if (r.type !== "root")
    throw new TypeError("Expected a `root` node");
  let i = je.createElement(
    je.Fragment,
    {},
    qr({ options: e, schema: Hu, listDepth: 0 }, r)
  );
  return e.className && (i = je.createElement("div", { className: e.className }, i)), i;
}
Vr.propTypes = {
  // Core options:
  children: N.string,
  // Layout options:
  className: N.string,
  // Filter options:
  allowElement: N.func,
  allowedElements: N.arrayOf(N.string),
  disallowedElements: N.arrayOf(N.string),
  unwrapDisallowed: N.bool,
  // Plugin options:
  remarkPlugins: N.arrayOf(
    N.oneOfType([
      N.object,
      N.func,
      N.arrayOf(
        N.oneOfType([
          N.bool,
          N.string,
          N.object,
          N.func,
          N.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            N.any
          )
        ])
      )
    ])
  ),
  rehypePlugins: N.arrayOf(
    N.oneOfType([
      N.object,
      N.func,
      N.arrayOf(
        N.oneOfType([
          N.bool,
          N.string,
          N.object,
          N.func,
          N.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            N.any
          )
        ])
      )
    ])
  ),
  // Transform options:
  sourcePos: N.bool,
  rawSourcePos: N.bool,
  skipHtml: N.bool,
  includeElementIndex: N.bool,
  transformLinkUri: N.oneOfType([N.func, N.bool]),
  linkTarget: N.oneOfType([N.func, N.string]),
  transformImageUri: N.func,
  components: N.object
};
const ka = {
  tokenize: Aa,
  partial: !0
}, Wr = {
  tokenize: va,
  partial: !0
}, Yr = {
  tokenize: Ta,
  partial: !0
}, Qr = {
  tokenize: Pa,
  partial: !0
}, ba = {
  tokenize: Fa,
  partial: !0
}, Xr = {
  tokenize: Ca,
  previous: Kr
}, Gr = {
  tokenize: Ea,
  previous: Zr
}, Fe = {
  tokenize: Sa,
  previous: Jr
}, ve = {}, wa = {
  text: ve
};
let Re = 48;
for (; Re < 123; )
  ve[Re] = Fe, Re++, Re === 58 ? Re = 65 : Re === 91 && (Re = 97);
ve[43] = Fe;
ve[45] = Fe;
ve[46] = Fe;
ve[95] = Fe;
ve[72] = [Fe, Gr];
ve[104] = [Fe, Gr];
ve[87] = [Fe, Xr];
ve[119] = [Fe, Xr];
function Sa(e, n, t) {
  const r = this;
  let i, l;
  return o;
  function o(f) {
    return !$n(f) || !Jr.call(r, r.previous) || et(r.events) ? t(f) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), u(f));
  }
  function u(f) {
    return $n(f) ? (e.consume(f), u) : f === 64 ? (e.consume(f), a) : t(f);
  }
  function a(f) {
    return f === 46 ? e.check(
      ba,
      s,
      c
    )(f) : f === 45 || f === 95 || pe(f) ? (l = !0, e.consume(f), a) : s(f);
  }
  function c(f) {
    return e.consume(f), i = !0, a;
  }
  function s(f) {
    return l && i && me(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), n(f)) : t(f);
  }
}
function Ca(e, n, t) {
  const r = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !Kr.call(r, r.previous) || et(r.events) ? t(o) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(
      ka,
      e.attempt(Wr, e.attempt(Yr, l), t),
      t
    )(o));
  }
  function l(o) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), n(o);
  }
}
function Ea(e, n, t) {
  const r = this;
  let i = "", l = !1;
  return o;
  function o(f) {
    return (f === 72 || f === 104) && Zr.call(r, r.previous) && !et(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(f), e.consume(f), u) : t(f);
  }
  function u(f) {
    if (me(f) && i.length < 5)
      return i += String.fromCodePoint(f), e.consume(f), u;
    if (f === 58) {
      const x = i.toLowerCase();
      if (x === "http" || x === "https")
        return e.consume(f), a;
    }
    return t(f);
  }
  function a(f) {
    return f === 47 ? (e.consume(f), l ? c : (l = !0, a)) : t(f);
  }
  function c(f) {
    return f === null || on(f) || re(f) || _e(f) || sn(f) ? t(f) : e.attempt(Wr, e.attempt(Yr, s), t)(f);
  }
  function s(f) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), n(f);
  }
}
function Aa(e, n, t) {
  let r = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, e.consume(o), i) : o === 46 && r === 3 ? (e.consume(o), l) : t(o);
  }
  function l(o) {
    return o === null ? t(o) : n(o);
  }
}
function va(e, n, t) {
  let r, i, l;
  return o;
  function o(c) {
    return c === 46 || c === 95 ? e.check(Qr, a, u)(c) : c === null || re(c) || _e(c) || c !== 45 && sn(c) ? a(c) : (l = !0, e.consume(c), o);
  }
  function u(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), e.consume(c), o;
  }
  function a(c) {
    return i || r || !l ? t(c) : n(c);
  }
}
function Ta(e, n) {
  let t = 0, r = 0;
  return i;
  function i(o) {
    return o === 40 ? (t++, e.consume(o), i) : o === 41 && r < t ? l(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? e.check(Qr, n, l)(o) : o === null || re(o) || _e(o) ? n(o) : (e.consume(o), i);
  }
  function l(o) {
    return o === 41 && r++, e.consume(o), i;
  }
}
function Pa(e, n, t) {
  return r;
  function r(u) {
    return u === 33 || u === 34 || u === 39 || u === 41 || u === 42 || u === 44 || u === 46 || u === 58 || u === 59 || u === 63 || u === 95 || u === 126 ? (e.consume(u), r) : u === 38 ? (e.consume(u), l) : u === 93 ? (e.consume(u), i) : (
      // `<` is an end.
      u === 60 || // So is whitespace.
      u === null || re(u) || _e(u) ? n(u) : t(u)
    );
  }
  function i(u) {
    return u === null || u === 40 || u === 91 || re(u) || _e(u) ? n(u) : r(u);
  }
  function l(u) {
    return me(u) ? o(u) : t(u);
  }
  function o(u) {
    return u === 59 ? (e.consume(u), r) : me(u) ? (e.consume(u), o) : t(u);
  }
}
function Fa(e, n, t) {
  return r;
  function r(l) {
    return e.consume(l), i;
  }
  function i(l) {
    return pe(l) ? t(l) : n(l);
  }
}
function Kr(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || re(e);
}
function Zr(e) {
  return !me(e);
}
function Jr(e) {
  return !(e === 47 || $n(e));
}
function $n(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || pe(e);
}
function et(e) {
  let n = e.length, t = !1;
  for (; n--; ) {
    const r = e[n][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      t = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      t = !1;
      break;
    }
  }
  return e.length > 0 && !t && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), t;
}
const Ia = {
  tokenize: Ba,
  partial: !0
};
function Oa() {
  return {
    document: {
      [91]: {
        tokenize: za,
        continuation: {
          tokenize: _a
        },
        exit: Ma
      }
    },
    text: {
      [91]: {
        tokenize: Ra
      },
      [93]: {
        add: "after",
        tokenize: Da,
        resolveTo: La
      }
    }
  };
}
function Da(e, n, t) {
  const r = this;
  let i = r.events.length;
  const l = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const a = r.events[i][1];
    if (a.type === "labelImage") {
      o = a;
      break;
    }
    if (a.type === "gfmFootnoteCall" || a.type === "labelLink" || a.type === "label" || a.type === "image" || a.type === "link")
      break;
  }
  return u;
  function u(a) {
    if (!o || !o._balanced)
      return t(a);
    const c = Se(
      r.sliceSerialize({
        start: o.end,
        end: r.now()
      })
    );
    return c.codePointAt(0) !== 94 || !l.includes(c.slice(1)) ? t(a) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(a), e.exit("gfmFootnoteCallLabelMarker"), n(a));
  }
}
function La(e, n) {
  let t = e.length;
  for (; t--; )
    if (e[t][1].type === "labelImage" && e[t][0] === "enter") {
      e[t][1];
      break;
    }
  e[t + 1][1].type = "data", e[t + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[t + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[t + 3][1].end),
    end: Object.assign({}, e[t + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const l = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, l.start),
    end: Object.assign({}, l.end)
  }, u = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[t + 1],
    e[t + 2],
    ["enter", r, n],
    // The `[`
    e[t + 3],
    e[t + 4],
    // The `^`.
    ["enter", i, n],
    ["exit", i, n],
    // Everything in between.
    ["enter", l, n],
    ["enter", o, n],
    ["exit", o, n],
    ["exit", l, n],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, n]
  ];
  return e.splice(t, e.length - t + 1, ...u), e;
}
function Ra(e, n, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let l = 0, o;
  return u;
  function u(f) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), a;
  }
  function a(f) {
    return f !== 94 ? t(f) : (e.enter("gfmFootnoteCallMarker"), e.consume(f), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(f) {
    if (
      // Too long.
      l > 999 || // Closing brace with nothing.
      f === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || re(f)
    )
      return t(f);
    if (f === 93) {
      e.exit("chunkString");
      const x = e.exit("gfmFootnoteCallString");
      return i.includes(Se(r.sliceSerialize(x))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), n) : t(f);
    }
    return re(f) || (o = !0), l++, e.consume(f), f === 92 ? s : c;
  }
  function s(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), l++, c) : c(f);
  }
}
function za(e, n, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let l, o = 0, u;
  return a;
  function a(h) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(h) {
    return h === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", s) : t(h);
  }
  function s(h) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      h === 93 && !u || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || re(h)
    )
      return t(h);
    if (h === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteDefinitionLabelString");
      return l = Se(r.sliceSerialize(g)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), x;
    }
    return re(h) || (u = !0), o++, e.consume(h), h === 92 ? f : s;
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), o++, s) : s(h);
  }
  function x(h) {
    return h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), i.includes(l) || i.push(l), X(
      e,
      d,
      "gfmFootnoteDefinitionWhitespace"
    )) : t(h);
  }
  function d(h) {
    return n(h);
  }
}
function _a(e, n, t) {
  return e.check(Ze, n, e.attempt(Ia, n, t));
}
function Ma(e) {
  e.exit("gfmFootnoteDefinition");
}
function Ba(e, n, t) {
  const r = this;
  return X(
    e,
    i,
    "gfmFootnoteDefinitionIndent",
    4 + 1
  );
  function i(l) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? n(l) : t(l);
  }
}
function ja(e) {
  let t = (e || {}).singleTilde;
  const r = {
    tokenize: l,
    resolveAll: i
  };
  return t == null && (t = !0), {
    text: {
      [126]: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, u) {
    let a = -1;
    for (; ++a < o.length; )
      if (o[a][0] === "enter" && o[a][1].type === "strikethroughSequenceTemporary" && o[a][1]._close) {
        let c = a;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[a][1].end.offset - o[a][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[a][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const s = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[a][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[a][1].start)
            }, x = [
              ["enter", s, u],
              ["enter", o[c][1], u],
              ["exit", o[c][1], u],
              ["enter", f, u]
            ], d = u.parser.constructs.insideSpan.null;
            d && ye(
              x,
              x.length,
              0,
              // @ts-expect-error: to do: update `mdast-util-types` to allow explicit `undefined`s.
              cn(d, o.slice(c + 1, a), u)
            ), ye(x, x.length, 0, [
              ["exit", f, u],
              ["enter", o[a][1], u],
              ["exit", o[a][1], u],
              ["exit", s, u]
            ]), ye(o, c - 1, a - c + 3, x), a = c + x.length - 2;
            break;
          }
      }
    for (a = -1; ++a < o.length; )
      o[a][1].type === "strikethroughSequenceTemporary" && (o[a][1].type = "data");
    return o;
  }
  function l(o, u, a) {
    const c = this.previous, s = this.events;
    let f = 0;
    return x;
    function x(h) {
      return c === 126 && s[s.length - 1][1].type !== "characterEscape" ? a(h) : (o.enter("strikethroughSequenceTemporary"), d(h));
    }
    function d(h) {
      const g = un(c);
      if (h === 126)
        return f > 1 ? a(h) : (o.consume(h), f++, d);
      if (f < 2 && !t)
        return a(h);
      const y = o.exit("strikethroughSequenceTemporary"), k = un(h);
      return y._open = !k || k === 2 && !!g, y._close = !g || g === 2 && !!k, u(h);
    }
  }
}
class Na {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {void}
   */
  add(n, t, r) {
    Ha(this, n, t, r);
  }
  // To do: not used here.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {void}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {void}
   */
  consume(n) {
    if (this.map.sort((l, o) => l[0] - o[0]), this.map.length === 0)
      return;
    let t = this.map.length;
    const r = [];
    for (; t > 0; )
      t -= 1, r.push(n.slice(this.map[t][0] + this.map[t][1])), r.push(this.map[t][2]), n.length = this.map[t][0];
    r.push([...n]), n.length = 0;
    let i = r.pop();
    for (; i; )
      n.push(...i), i = r.pop();
    this.map.length = 0;
  }
}
function Ha(e, n, t, r) {
  let i = 0;
  if (!(t === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === n) {
        e.map[i][1] += t, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([n, t, r]);
  }
}
function Ua(e, n) {
  let t = !1;
  const r = [];
  for (; n < e.length; ) {
    const i = e[n];
    if (t) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(
          e[n + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
        );
      else if (i[1].type === "tableContent") {
        if (e[n - 1][1].type === "tableDelimiterMarker") {
          const l = r.length - 1;
          r[l] = r[l] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else
      i[0] === "enter" && i[1].type === "tableDelimiterRow" && (t = !0);
    n += 1;
  }
  return r;
}
const $a = {
  flow: {
    null: {
      tokenize: qa,
      resolveAll: Va
    }
  }
};
function qa(e, n, t) {
  const r = this;
  let i = 0, l = 0, o;
  return u;
  function u(b) {
    let v = r.events.length - 1;
    for (; v > -1; ) {
      const J = r.events[v][1].type;
      if (J === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      J === "linePrefix")
        v--;
      else
        break;
    }
    const L = v > -1 ? r.events[v][1].type : null, Y = L === "tableHead" || L === "tableRow" ? w : a;
    return Y === w && r.parser.lazy[r.now().line] ? t(b) : Y(b);
  }
  function a(b) {
    return e.enter("tableHead"), e.enter("tableRow"), c(b);
  }
  function c(b) {
    return b === 124 || (o = !0, l += 1), s(b);
  }
  function s(b) {
    return b === null ? t(b) : z(b) ? l > 1 ? (l = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), d) : t(b) : ne(b) ? X(e, s, "whitespace")(b) : (l += 1, o && (o = !1, i += 1), b === 124 ? (e.enter("tableCellDivider"), e.consume(b), e.exit("tableCellDivider"), o = !0, s) : (e.enter("data"), f(b)));
  }
  function f(b) {
    return b === null || b === 124 || re(b) ? (e.exit("data"), s(b)) : (e.consume(b), b === 92 ? x : f);
  }
  function x(b) {
    return b === 92 || b === 124 ? (e.consume(b), f) : f(b);
  }
  function d(b) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? t(b) : (e.enter("tableDelimiterRow"), o = !1, ne(b) ? X(
      e,
      h,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(b) : h(b));
  }
  function h(b) {
    return b === 45 || b === 58 ? y(b) : b === 124 ? (o = !0, e.enter("tableCellDivider"), e.consume(b), e.exit("tableCellDivider"), g) : F(b);
  }
  function g(b) {
    return ne(b) ? X(e, y, "whitespace")(b) : y(b);
  }
  function y(b) {
    return b === 58 ? (l += 1, o = !0, e.enter("tableDelimiterMarker"), e.consume(b), e.exit("tableDelimiterMarker"), k) : b === 45 ? (l += 1, k(b)) : b === null || z(b) ? O(b) : F(b);
  }
  function k(b) {
    return b === 45 ? (e.enter("tableDelimiterFiller"), P(b)) : F(b);
  }
  function P(b) {
    return b === 45 ? (e.consume(b), P) : b === 58 ? (o = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(b), e.exit("tableDelimiterMarker"), A) : (e.exit("tableDelimiterFiller"), A(b));
  }
  function A(b) {
    return ne(b) ? X(e, O, "whitespace")(b) : O(b);
  }
  function O(b) {
    return b === 124 ? h(b) : b === null || z(b) ? !o || i !== l ? F(b) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), n(b)) : F(b);
  }
  function F(b) {
    return t(b);
  }
  function w(b) {
    return e.enter("tableRow"), I(b);
  }
  function I(b) {
    return b === 124 ? (e.enter("tableCellDivider"), e.consume(b), e.exit("tableCellDivider"), I) : b === null || z(b) ? (e.exit("tableRow"), n(b)) : ne(b) ? X(e, I, "whitespace")(b) : (e.enter("data"), j(b));
  }
  function j(b) {
    return b === null || b === 124 || re(b) ? (e.exit("data"), I(b)) : (e.consume(b), b === 92 ? W : j);
  }
  function W(b) {
    return b === 92 || b === 124 ? (e.consume(b), j) : j(b);
  }
}
function Va(e, n) {
  let t = -1, r = !0, i = 0, l = [0, 0, 0, 0], o = [0, 0, 0, 0], u = !1, a = 0, c, s, f;
  const x = new Na();
  for (; ++t < e.length; ) {
    const d = e[t], h = d[1];
    d[0] === "enter" ? h.type === "tableHead" ? (u = !1, a !== 0 && (Kt(x, n, a, c, s), s = void 0, a = 0), c = {
      type: "table",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, x.add(t, 0, [["enter", c, n]])) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (r = !0, f = void 0, l = [0, 0, 0, 0], o = [0, t + 1, 0, 0], u && (u = !1, s = {
      type: "tableBody",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, x.add(t, 0, [["enter", s, n]])), i = h.type === "tableDelimiterRow" ? 2 : s ? 3 : 1) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (l[1] !== 0 && (o[0] = o[1], f = tn(
      x,
      n,
      l,
      i,
      void 0,
      f
    ), l = [0, 0, 0, 0]), o[2] = t)) : h.type === "tableCellDivider" && (r ? r = !1 : (l[1] !== 0 && (o[0] = o[1], f = tn(
      x,
      n,
      l,
      i,
      void 0,
      f
    )), l = o, o = [l[1], t, 0, 0])) : h.type === "tableHead" ? (u = !0, a = t) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (a = t, l[1] !== 0 ? (o[0] = o[1], f = tn(
      x,
      n,
      l,
      i,
      t,
      f
    )) : o[1] !== 0 && (f = tn(x, n, o, i, t, f)), i = 0) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") && (o[3] = t);
  }
  for (a !== 0 && Kt(x, n, a, c, s), x.consume(n.events), t = -1; ++t < n.events.length; ) {
    const d = n.events[t];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = Ua(n.events, t));
  }
  return e;
}
function tn(e, n, t, r, i, l) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", u = "tableContent";
  t[0] !== 0 && (l.end = Object.assign({}, Be(n.events, t[0])), e.add(t[0], 0, [["exit", l, n]]));
  const a = Be(n.events, t[1]);
  if (l = {
    type: o,
    start: Object.assign({}, a),
    // Note: correct end is set later.
    end: Object.assign({}, a)
  }, e.add(t[1], 0, [["enter", l, n]]), t[2] !== 0) {
    const c = Be(n.events, t[2]), s = Be(n.events, t[3]), f = {
      type: u,
      start: Object.assign({}, c),
      end: Object.assign({}, s)
    };
    if (e.add(t[2], 0, [["enter", f, n]]), r !== 2) {
      const x = n.events[t[2]], d = n.events[t[3]];
      if (x[1].end = Object.assign({}, d[1].end), x[1].type = "chunkText", x[1].contentType = "text", t[3] > t[2] + 1) {
        const h = t[2] + 1, g = t[3] - t[2] - 1;
        e.add(h, g, []);
      }
    }
    e.add(t[3] + 1, 0, [["exit", f, n]]);
  }
  return i !== void 0 && (l.end = Object.assign({}, Be(n.events, i)), e.add(i, 0, [["exit", l, n]]), l = void 0), l;
}
function Kt(e, n, t, r, i) {
  const l = [], o = Be(n.events, t);
  i && (i.end = Object.assign({}, o), l.push(["exit", i, n])), r.end = Object.assign({}, o), l.push(["exit", r, n]), e.add(t + 1, 0, l);
}
function Be(e, n) {
  const t = e[n], r = t[0] === "enter" ? "start" : "end";
  return t[1][r];
}
const Wa = {
  tokenize: Qa
}, Ya = {
  text: {
    [91]: Wa
  }
};
function Qa(e, n, t) {
  const r = this;
  return i;
  function i(a) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? t(a) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(a), e.exit("taskListCheckMarker"), l)
    );
  }
  function l(a) {
    return re(a) ? (e.enter("taskListCheckValueUnchecked"), e.consume(a), e.exit("taskListCheckValueUnchecked"), o) : a === 88 || a === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(a), e.exit("taskListCheckValueChecked"), o) : t(a);
  }
  function o(a) {
    return a === 93 ? (e.enter("taskListCheckMarker"), e.consume(a), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), u) : t(a);
  }
  function u(a) {
    return z(a) ? n(a) : ne(a) ? e.check(
      {
        tokenize: Xa
      },
      n,
      t
    )(a) : t(a);
  }
}
function Xa(e, n, t) {
  return X(e, r, "whitespace");
  function r(i) {
    return i === null ? t(i) : n(i);
  }
}
function Ga(e) {
  return hr([
    wa,
    Oa(),
    ja(e),
    $a,
    Ya
  ]);
}
function Zt(e, n) {
  const t = String(e);
  if (typeof n != "string")
    throw new TypeError("Expected character");
  let r = 0, i = t.indexOf(n);
  for (; i !== -1; )
    r++, i = t.indexOf(n, i + n.length);
  return r;
}
function Ka(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const Za = {}.hasOwnProperty, Ja = (
  /**
   * @type {(
   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &
   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)
   * )}
   **/
  /**
   * @template {Node} Tree
   * @param {Tree} tree
   * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find
   * @param {Replace | Options | null | undefined} [replace]
   * @param {Options | null | undefined} [options]
   * @returns {Tree}
   */
  function(e, n, t, r) {
    let i, l;
    typeof n == "string" || n instanceof RegExp ? (l = [[n, t]], i = r) : (l = n, i = t), i || (i = {});
    const o = Qn(i.ignore || []), u = es(l);
    let a = -1;
    for (; ++a < u.length; )
      Or(e, "text", c);
    return e;
    function c(f, x) {
      let d = -1, h;
      for (; ++d < x.length; ) {
        const g = x[d];
        if (o(
          g,
          // @ts-expect-error: TS doesn’t understand but it’s perfect.
          h ? h.children.indexOf(g) : void 0,
          h
        ))
          return;
        h = g;
      }
      if (h)
        return s(f, x);
    }
    function s(f, x) {
      const d = x[x.length - 1], h = u[a][0], g = u[a][1];
      let y = 0;
      const k = d.children.indexOf(f);
      let P = !1, A = [];
      h.lastIndex = 0;
      let O = h.exec(f.value);
      for (; O; ) {
        const F = O.index, w = {
          index: O.index,
          input: O.input,
          // @ts-expect-error: stack is fine.
          stack: [...x, f]
        };
        let I = g(...O, w);
        if (typeof I == "string" && (I = I.length > 0 ? { type: "text", value: I } : void 0), I !== !1 && (y !== F && A.push({
          type: "text",
          value: f.value.slice(y, F)
        }), Array.isArray(I) ? A.push(...I) : I && A.push(I), y = F + O[0].length, P = !0), !h.global)
          break;
        O = h.exec(f.value);
      }
      return P ? (y < f.value.length && A.push({ type: "text", value: f.value.slice(y) }), d.children.splice(k, 1, ...A)) : A = [f], k + A.length;
    }
  }
);
function es(e) {
  const n = [];
  if (typeof e != "object")
    throw new TypeError("Expected array or object as schema");
  if (Array.isArray(e)) {
    let t = -1;
    for (; ++t < e.length; )
      n.push([
        Jt(e[t][0]),
        er(e[t][1])
      ]);
  } else {
    let t;
    for (t in e)
      Za.call(e, t) && n.push([Jt(t), er(e[t])]);
  }
  return n;
}
function Jt(e) {
  return typeof e == "string" ? new RegExp(Ka(e), "g") : e;
}
function er(e) {
  return typeof e == "function" ? e : () => e;
}
const Fn = "phrasing", In = ["autolink", "link", "image", "label"], ns = {
  transforms: [as],
  enter: {
    literalAutolink: rs,
    literalAutolinkEmail: On,
    literalAutolinkHttp: On,
    literalAutolinkWww: On
  },
  exit: {
    literalAutolink: us,
    literalAutolinkEmail: os,
    literalAutolinkHttp: is,
    literalAutolinkWww: ls
  }
}, ts = {
  unsafe: [
    {
      character: "@",
      before: "[+\\-.\\w]",
      after: "[\\-.\\w]",
      inConstruct: Fn,
      notInConstruct: In
    },
    {
      character: ".",
      before: "[Ww]",
      after: "[\\-.\\w]",
      inConstruct: Fn,
      notInConstruct: In
    },
    { character: ":", before: "[ps]", after: "\\/", inConstruct: Fn, notInConstruct: In }
  ]
};
function rs(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function On(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function is(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function ls(e) {
  this.config.exit.data.call(this, e);
  const n = (
    /** @type {Link} */
    this.stack[this.stack.length - 1]
  );
  n.url = "http://" + this.sliceSerialize(e);
}
function os(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function us(e) {
  this.exit(e);
}
function as(e) {
  Ja(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, ss],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, cs]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function ss(e, n, t, r, i) {
  let l = "";
  if (!ei(i) || (/^w/i.test(n) && (t = n + t, n = "", l = "http://"), !fs(t)))
    return !1;
  const o = ps(t + r);
  if (!o[0])
    return !1;
  const u = {
    type: "link",
    title: null,
    url: l + n + o[0],
    children: [{ type: "text", value: n + o[0] }]
  };
  return o[1] ? [u, { type: "text", value: o[1] }] : u;
}
function cs(e, n, t, r) {
  return (
    // Not an expected previous character.
    !ei(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(t) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + n + "@" + t,
      children: [{ type: "text", value: n + "@" + t }]
    }
  );
}
function fs(e) {
  const n = e.split(".");
  return !(n.length < 2 || n[n.length - 1] && (/_/.test(n[n.length - 1]) || !/[a-zA-Z\d]/.test(n[n.length - 1])) || n[n.length - 2] && (/_/.test(n[n.length - 2]) || !/[a-zA-Z\d]/.test(n[n.length - 2])));
}
function ps(e) {
  const n = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!n)
    return [e, void 0];
  e = e.slice(0, n.index);
  let t = n[0], r = t.indexOf(")");
  const i = Zt(e, "(");
  let l = Zt(e, ")");
  for (; r !== -1 && i > l; )
    e += t.slice(0, r + 1), t = t.slice(r + 1), r = t.indexOf(")"), l++;
  return [e, t];
}
function ei(e, n) {
  const t = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || _e(t) || sn(t)) && (!n || t !== 47);
}
function ni(e) {
  return e.label || !e.identifier ? e.label || "" : Er(e.identifier);
}
function hs(e, n, t) {
  const r = n.indexStack, i = e.children || [], l = n.createTracker(t), o = [];
  let u = -1;
  for (r.push(-1); ++u < i.length; ) {
    const a = i[u];
    r[r.length - 1] = u, o.push(
      l.move(
        n.handle(a, e, n, {
          before: `
`,
          after: `
`,
          ...l.current()
        })
      )
    ), a.type !== "list" && (n.bulletLastUsed = void 0), u < i.length - 1 && o.push(
      l.move(ms(a, i[u + 1], e, n))
    );
  }
  return r.pop(), o.join("");
}
function ms(e, n, t, r) {
  let i = r.join.length;
  for (; i--; ) {
    const l = r.join[i](e, n, t, r);
    if (l === !0 || l === 1)
      break;
    if (typeof l == "number")
      return `
`.repeat(1 + l);
    if (l === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const gs = /\r?\n|\r/g;
function ds(e, n) {
  const t = [];
  let r = 0, i = 0, l;
  for (; l = gs.exec(e); )
    o(e.slice(r, l.index)), t.push(l[0]), r = l.index + l[0].length, i++;
  return o(e.slice(r)), t.join("");
  function o(u) {
    t.push(n(u, i, !u));
  }
}
function ti(e) {
  if (!e._compiled) {
    const n = (e.atBreak ? "[\\r\\n][\\t ]*" : "") + (e.before ? "(?:" + e.before + ")" : "");
    e._compiled = new RegExp(
      (n ? "(" + n + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(e.character) ? "\\" : "") + e.character + (e.after ? "(?:" + e.after + ")" : ""),
      "g"
    );
  }
  return e._compiled;
}
function ys(e, n) {
  return nr(e, n.inConstruct, !0) && !nr(e, n.notInConstruct, !1);
}
function nr(e, n, t) {
  if (typeof n == "string" && (n = [n]), !n || n.length === 0)
    return t;
  let r = -1;
  for (; ++r < n.length; )
    if (e.includes(n[r]))
      return !0;
  return !1;
}
function ri(e, n, t) {
  const r = (t.before || "") + (n || "") + (t.after || ""), i = [], l = [], o = {};
  let u = -1;
  for (; ++u < e.unsafe.length; ) {
    const s = e.unsafe[u];
    if (!ys(e.stack, s))
      continue;
    const f = ti(s);
    let x;
    for (; x = f.exec(r); ) {
      const d = "before" in s || !!s.atBreak, h = "after" in s, g = x.index + (d ? x[1].length : 0);
      i.includes(g) ? (o[g].before && !d && (o[g].before = !1), o[g].after && !h && (o[g].after = !1)) : (i.push(g), o[g] = { before: d, after: h });
    }
  }
  i.sort(xs);
  let a = t.before ? t.before.length : 0;
  const c = r.length - (t.after ? t.after.length : 0);
  for (u = -1; ++u < i.length; ) {
    const s = i[u];
    s < a || s >= c || s + 1 < c && i[u + 1] === s + 1 && o[s].after && !o[s + 1].before && !o[s + 1].after || i[u - 1] === s - 1 && o[s].before && !o[s - 1].before && !o[s - 1].after || (a !== s && l.push(tr(r.slice(a, s), "\\")), a = s, /[!-/:-@[-`{-~]/.test(r.charAt(s)) && (!t.encode || !t.encode.includes(r.charAt(s))) ? l.push("\\") : (l.push(
      "&#x" + r.charCodeAt(s).toString(16).toUpperCase() + ";"
    ), a++));
  }
  return l.push(tr(r.slice(a, c), t.after)), l.join("");
}
function xs(e, n) {
  return e - n;
}
function tr(e, n) {
  const t = /\\(?=[!-/:-@[-`{-~])/g, r = [], i = [], l = e + n;
  let o = -1, u = 0, a;
  for (; a = t.exec(l); )
    r.push(a.index);
  for (; ++o < r.length; )
    u !== r[o] && i.push(e.slice(u, r[o])), i.push("\\"), u = r[o];
  return i.push(e.slice(u)), i.join("");
}
function pn(e) {
  const n = e || {}, t = n.now || {};
  let r = n.lineShift || 0, i = t.line || 1, l = t.column || 1;
  return { move: a, current: o, shift: u };
  function o() {
    return { now: { line: i, column: l }, lineShift: r };
  }
  function u(c) {
    r += c;
  }
  function a(c) {
    const s = c || "", f = s.split(/\r?\n|\r/g), x = f[f.length - 1];
    return i += f.length - 1, l = f.length === 1 ? l + x.length : 1 + x.length + r, s;
  }
}
ii.peek = Fs;
function ks() {
  return {
    enter: {
      gfmFootnoteDefinition: ws,
      gfmFootnoteDefinitionLabelString: Ss,
      gfmFootnoteCall: As,
      gfmFootnoteCallString: vs
    },
    exit: {
      gfmFootnoteDefinition: Es,
      gfmFootnoteDefinitionLabelString: Cs,
      gfmFootnoteCall: Ps,
      gfmFootnoteCallString: Ts
    }
  };
}
function bs() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: Is, footnoteReference: ii }
  };
}
function ws(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Ss() {
  this.buffer();
}
function Cs(e) {
  const n = this.resume(), t = (
    /** @type {FootnoteDefinition} */
    this.stack[this.stack.length - 1]
  );
  t.label = n, t.identifier = Se(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function Es(e) {
  this.exit(e);
}
function As(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function vs() {
  this.buffer();
}
function Ts(e) {
  const n = this.resume(), t = (
    /** @type {FootnoteDefinition} */
    this.stack[this.stack.length - 1]
  );
  t.label = n, t.identifier = Se(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function Ps(e) {
  this.exit(e);
}
function ii(e, n, t, r) {
  const i = pn(r);
  let l = i.move("[^");
  const o = t.enter("footnoteReference"), u = t.enter("reference");
  return l += i.move(
    ri(t, ni(e), {
      ...i.current(),
      before: l,
      after: "]"
    })
  ), u(), o(), l += i.move("]"), l;
}
function Fs() {
  return "[";
}
function Is(e, n, t, r) {
  const i = pn(r);
  let l = i.move("[^");
  const o = t.enter("footnoteDefinition"), u = t.enter("label");
  return l += i.move(
    ri(t, ni(e), {
      ...i.current(),
      before: l,
      after: "]"
    })
  ), u(), l += i.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), i.shift(4), l += i.move(
    ds(hs(e, t, i.current()), Os)
  ), o(), l;
}
function Os(e, n, t) {
  return n === 0 ? e : (t ? "" : "    ") + e;
}
function li(e, n, t) {
  const r = n.indexStack, i = e.children || [], l = [];
  let o = -1, u = t.before;
  r.push(-1);
  let a = n.createTracker(t);
  for (; ++o < i.length; ) {
    const c = i[o];
    let s;
    if (r[r.length - 1] = o, o + 1 < i.length) {
      let f = n.handle.handlers[i[o + 1].type];
      f && f.peek && (f = f.peek), s = f ? f(i[o + 1], e, n, {
        before: "",
        after: "",
        ...a.current()
      }).charAt(0) : "";
    } else
      s = t.after;
    l.length > 0 && (u === "\r" || u === `
`) && c.type === "html" && (l[l.length - 1] = l[l.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), u = " ", a = n.createTracker(t), a.move(l.join(""))), l.push(
      a.move(
        n.handle(c, e, n, {
          ...a.current(),
          before: u,
          after: s
        })
      )
    ), u = l[l.length - 1].slice(-1);
  }
  return r.pop(), l.join("");
}
const Ds = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
oi.peek = Ms;
const Ls = {
  canContainEols: ["delete"],
  enter: { strikethrough: zs },
  exit: { strikethrough: _s }
}, Rs = {
  unsafe: [
    {
      character: "~",
      inConstruct: "phrasing",
      notInConstruct: Ds
    }
  ],
  handlers: { delete: oi }
};
function zs(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function _s(e) {
  this.exit(e);
}
function oi(e, n, t, r) {
  const i = pn(r), l = t.enter("strikethrough");
  let o = i.move("~~");
  return o += li(e, t, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), l(), o;
}
function Ms() {
  return "~";
}
ui.peek = Bs;
function ui(e, n, t) {
  let r = e.value || "", i = "`", l = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++l < t.unsafe.length; ) {
    const o = t.unsafe[l], u = ti(o);
    let a;
    if (o.atBreak)
      for (; a = u.exec(r); ) {
        let c = a.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(a.index + 1);
      }
  }
  return i + r + i;
}
function Bs() {
  return "`";
}
function js(e, n = {}) {
  const t = (n.align || []).concat(), r = n.stringLength || Hs, i = [], l = [], o = [], u = [];
  let a = 0, c = -1;
  for (; ++c < e.length; ) {
    const h = [], g = [];
    let y = -1;
    for (e[c].length > a && (a = e[c].length); ++y < e[c].length; ) {
      const k = Ns(e[c][y]);
      if (n.alignDelimiters !== !1) {
        const P = r(k);
        g[y] = P, (u[y] === void 0 || P > u[y]) && (u[y] = P);
      }
      h.push(k);
    }
    l[c] = h, o[c] = g;
  }
  let s = -1;
  if (typeof t == "object" && "length" in t)
    for (; ++s < a; )
      i[s] = rr(t[s]);
  else {
    const h = rr(t);
    for (; ++s < a; )
      i[s] = h;
  }
  s = -1;
  const f = [], x = [];
  for (; ++s < a; ) {
    const h = i[s];
    let g = "", y = "";
    h === 99 ? (g = ":", y = ":") : h === 108 ? g = ":" : h === 114 && (y = ":");
    let k = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      u[s] - g.length - y.length
    );
    const P = g + "-".repeat(k) + y;
    n.alignDelimiters !== !1 && (k = g.length + k + y.length, k > u[s] && (u[s] = k), x[s] = k), f[s] = P;
  }
  l.splice(1, 0, f), o.splice(1, 0, x), c = -1;
  const d = [];
  for (; ++c < l.length; ) {
    const h = l[c], g = o[c];
    s = -1;
    const y = [];
    for (; ++s < a; ) {
      const k = h[s] || "";
      let P = "", A = "";
      if (n.alignDelimiters !== !1) {
        const O = u[s] - (g[s] || 0), F = i[s];
        F === 114 ? P = " ".repeat(O) : F === 99 ? O % 2 ? (P = " ".repeat(O / 2 + 0.5), A = " ".repeat(O / 2 - 0.5)) : (P = " ".repeat(O / 2), A = P) : A = " ".repeat(O);
      }
      n.delimiterStart !== !1 && !s && y.push("|"), n.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && k === "") && (n.delimiterStart !== !1 || s) && y.push(" "), n.alignDelimiters !== !1 && y.push(P), y.push(k), n.alignDelimiters !== !1 && y.push(A), n.padding !== !1 && y.push(" "), (n.delimiterEnd !== !1 || s !== a - 1) && y.push("|");
    }
    d.push(
      n.delimiterEnd === !1 ? y.join("").replace(/ +$/, "") : y.join("")
    );
  }
  return d.join(`
`);
}
function Ns(e) {
  return e == null ? "" : String(e);
}
function Hs(e) {
  return e.length;
}
function rr(e) {
  const n = typeof e == "string" ? e.codePointAt(0) : 0;
  return n === 67 || n === 99 ? 99 : n === 76 || n === 108 ? 108 : n === 82 || n === 114 ? 114 : 0;
}
const Us = {
  enter: {
    table: $s,
    tableData: ir,
    tableHeader: ir,
    tableRow: Vs
  },
  exit: {
    codeText: Ws,
    table: qs,
    tableData: Dn,
    tableHeader: Dn,
    tableRow: Dn
  }
};
function $s(e) {
  const n = e._align;
  this.enter(
    {
      type: "table",
      align: n.map((t) => t === "none" ? null : t),
      children: []
    },
    e
  ), this.setData("inTable", !0);
}
function qs(e) {
  this.exit(e), this.setData("inTable");
}
function Vs(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Dn(e) {
  this.exit(e);
}
function ir(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Ws(e) {
  let n = this.resume();
  this.getData("inTable") && (n = n.replace(/\\([\\|])/g, Ys));
  const t = (
    /** @type {InlineCode} */
    this.stack[this.stack.length - 1]
  );
  t.value = n, this.exit(e);
}
function Ys(e, n) {
  return n === "|" ? n : e;
}
function Qs(e) {
  const n = e || {}, t = n.tableCellPadding, r = n.tablePipeAlign, i = n.stringLength, l = t ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      table: o,
      tableRow: u,
      tableCell: a,
      inlineCode: x
    }
  };
  function o(d, h, g, y) {
    return c(
      s(d, g, y),
      d.align
    );
  }
  function u(d, h, g, y) {
    const k = f(d, g, y), P = c([k]);
    return P.slice(0, P.indexOf(`
`));
  }
  function a(d, h, g, y) {
    const k = g.enter("tableCell"), P = g.enter("phrasing"), A = li(d, g, {
      ...y,
      before: l,
      after: l
    });
    return P(), k(), A;
  }
  function c(d, h) {
    return js(d, {
      align: h,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: t,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function s(d, h, g) {
    const y = d.children;
    let k = -1;
    const P = [], A = h.enter("table");
    for (; ++k < y.length; )
      P[k] = f(
        y[k],
        h,
        g
      );
    return A(), P;
  }
  function f(d, h, g) {
    const y = d.children;
    let k = -1;
    const P = [], A = h.enter("tableRow");
    for (; ++k < y.length; )
      P[k] = a(
        y[k],
        d,
        h,
        g
      );
    return A(), P;
  }
  function x(d, h, g) {
    let y = ui(d, h, g);
    return g.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function Xs(e) {
  const n = e.options.bullet || "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return n;
}
function Gs(e) {
  const n = e.options.listItemIndent || "tab";
  if (n === 1 || n === "1")
    return "one";
  if (n !== "tab" && n !== "one" && n !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return n;
}
function Ks(e, n, t, r) {
  const i = Gs(t);
  let l = t.bulletCurrent || Xs(t);
  n && n.type === "list" && n.ordered && (l = (typeof n.start == "number" && n.start > -1 ? n.start : 1) + (t.options.incrementListMarker === !1 ? 0 : n.children.indexOf(e)) + l);
  let o = l.length + 1;
  (i === "tab" || i === "mixed" && (n && n.type === "list" && n.spread || e.spread)) && (o = Math.ceil(o / 4) * 4);
  const u = t.createTracker(r);
  u.move(l + " ".repeat(o - l.length)), u.shift(o);
  const a = t.enter("listItem"), c = t.indentLines(
    t.containerFlow(e, u.current()),
    s
  );
  return a(), c;
  function s(f, x, d) {
    return x ? (d ? "" : " ".repeat(o)) + f : (d ? l : l + " ".repeat(o - l.length)) + f;
  }
}
const Zs = {
  exit: {
    taskListCheckValueChecked: lr,
    taskListCheckValueUnchecked: lr,
    paragraph: ec
  }
}, Js = {
  unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
  handlers: { listItem: nc }
};
function lr(e) {
  const n = (
    /** @type {ListItem} */
    this.stack[this.stack.length - 2]
  );
  n.checked = e.type === "taskListCheckValueChecked";
}
function ec(e) {
  const n = (
    /** @type {Parents} */
    this.stack[this.stack.length - 2]
  );
  if (n && n.type === "listItem" && typeof n.checked == "boolean") {
    const t = (
      /** @type {Paragraph} */
      this.stack[this.stack.length - 1]
    ), r = t.children[0];
    if (r && r.type === "text") {
      const i = n.children;
      let l = -1, o;
      for (; ++l < i.length; ) {
        const u = i[l];
        if (u.type === "paragraph") {
          o = u;
          break;
        }
      }
      o === t && (r.value = r.value.slice(1), r.value.length === 0 ? t.children.shift() : t.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, t.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function nc(e, n, t, r) {
  const i = e.children[0], l = typeof e.checked == "boolean" && i && i.type === "paragraph", o = "[" + (e.checked ? "x" : " ") + "] ", u = pn(r);
  l && u.move(o);
  let a = Ks(e, n, t, {
    ...r,
    ...u.current()
  });
  return l && (a = a.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), a;
  function c(s) {
    return s + o;
  }
}
function tc() {
  return [
    ns,
    ks(),
    Ls,
    Us,
    Zs
  ];
}
function rc(e) {
  return {
    extensions: [
      ts,
      bs(),
      Rs,
      Qs(e),
      Js
    ]
  };
}
function ic(e = {}) {
  const n = this.data();
  t("micromarkExtensions", Ga(e)), t("fromMarkdownExtensions", tc()), t("toMarkdownExtensions", rc(e));
  function t(r, i) {
    /** @type {unknown[]} */
    // Other extensions
    /* c8 ignore next 2 */
    (n[r] ? n[r] : n[r] = []).push(i);
  }
}
const ac = ({
  width: e,
  message: n,
  className: t = ""
}) => /* @__PURE__ */ Ee.jsx(
  "div",
  {
    className: `font-sans rounded-lg px-4 py-2 break-words mt-2 ${n.author === "AI" ? "bg-slate-200 mr-auto ml-4 inline-block text-black" : "bg-blue-500 ml-auto mr-4 inline-block text-white"} ${t}`,
    style: { whiteSpace: "pre-line", maxWidth: `calc(${e} - 130px)` },
    children: /* @__PURE__ */ Ee.jsx(
      Vr,
      {
        children: n.text,
        remarkPlugins: [ic],
        className: "text-sm text-left",
        components: {
          h1: ({ ...r }) => /* @__PURE__ */ Ee.jsx("h1", { className: "text-4xl", ...r }),
          h2: ({ ...r }) => /* @__PURE__ */ Ee.jsx("h2", { className: "text-3xl", ...r }),
          h3: ({ ...r }) => /* @__PURE__ */ Ee.jsx("h3", { className: "text-2xl", ...r }),
          ol: ({ ...r }) => /* @__PURE__ */ Ee.jsx("ol", { className: "list-decimal list-inside", ...r }),
          ul: ({ ...r }) => /* @__PURE__ */ Ee.jsx("ul", { className: "list-disc list-inside", ...r }),
          blockquote: ({ ...r }) => /* @__PURE__ */ Ee.jsx(
            "blockquote",
            {
              className: "border-l-4 border-gray-300 pl-4 my-4",
              ...r
            }
          ),
          code: ({ ...r }) => /* @__PURE__ */ Ee.jsx(
            "code",
            {
              className: "text-sm bg-gray-200 p-1 rounded-md whitespace-pre-wrap break-all",
              ...r,
              style: { whiteSpace: "pre-line" }
            }
          ),
          a: ({ ...r }) => /* @__PURE__ */ Ee.jsx("a", { className: "underline", target: "_blank", ...r })
        }
      }
    )
  }
);
export {
  ac as default
};
//# sourceMappingURL=Message-9e7c431a.js.map
