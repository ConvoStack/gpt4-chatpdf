import * as fe from "react";
import ge, { createContext as qo, useContext as Mr, useDebugValue as Uo, useLayoutEffect as Vo, useEffect as $o, useMemo as cn } from "react";
import { unstable_batchedUpdates as Bo } from "react-dom";
function Qo(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in e)) {
          const o = Object.getOwnPropertyDescriptor(n, i);
          o && Object.defineProperty(e, i, o.get ? o : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function ln(e, t) {
  if (e == null)
    return {};
  var r = {}, n = Object.keys(e), i, o;
  for (o = 0; o < n.length; o++)
    i = n[o], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
function yt() {
  return yt = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, yt.apply(this, arguments);
}
function fn(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function vr(e, t) {
  return vr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, vr(e, t);
}
function Wo(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, vr(e, t);
}
var Yo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function vi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var mr = { exports: {} }, G = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dn;
function zo() {
  if (dn)
    return G;
  dn = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, l = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, E = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, O = e ? Symbol.for("react.responder") : 60118, x = e ? Symbol.for("react.scope") : 60119;
  function S(b) {
    if (typeof b == "object" && b !== null) {
      var w = b.$$typeof;
      switch (w) {
        case t:
          switch (b = b.type, b) {
            case u:
            case c:
            case n:
            case o:
            case i:
            case f:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case a:
                case l:
                case y:
                case h:
                case s:
                  return b;
                default:
                  return w;
              }
          }
        case r:
          return w;
      }
    }
  }
  function m(b) {
    return S(b) === c;
  }
  return G.AsyncMode = u, G.ConcurrentMode = c, G.ContextConsumer = a, G.ContextProvider = s, G.Element = t, G.ForwardRef = l, G.Fragment = n, G.Lazy = y, G.Memo = h, G.Portal = r, G.Profiler = o, G.StrictMode = i, G.Suspense = f, G.isAsyncMode = function(b) {
    return m(b) || S(b) === u;
  }, G.isConcurrentMode = m, G.isContextConsumer = function(b) {
    return S(b) === a;
  }, G.isContextProvider = function(b) {
    return S(b) === s;
  }, G.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, G.isForwardRef = function(b) {
    return S(b) === l;
  }, G.isFragment = function(b) {
    return S(b) === n;
  }, G.isLazy = function(b) {
    return S(b) === y;
  }, G.isMemo = function(b) {
    return S(b) === h;
  }, G.isPortal = function(b) {
    return S(b) === r;
  }, G.isProfiler = function(b) {
    return S(b) === o;
  }, G.isStrictMode = function(b) {
    return S(b) === i;
  }, G.isSuspense = function(b) {
    return S(b) === f;
  }, G.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === n || b === c || b === o || b === i || b === f || b === d || typeof b == "object" && b !== null && (b.$$typeof === y || b.$$typeof === h || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || b.$$typeof === v || b.$$typeof === O || b.$$typeof === x || b.$$typeof === E);
  }, G.typeOf = S, G;
}
var K = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hn;
function Go() {
  return hn || (hn = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, u = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, l = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, E = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, O = e ? Symbol.for("react.responder") : 60118, x = e ? Symbol.for("react.scope") : 60119;
    function S(k) {
      return typeof k == "string" || typeof k == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      k === n || k === c || k === o || k === i || k === f || k === d || typeof k == "object" && k !== null && (k.$$typeof === y || k.$$typeof === h || k.$$typeof === s || k.$$typeof === a || k.$$typeof === l || k.$$typeof === v || k.$$typeof === O || k.$$typeof === x || k.$$typeof === E);
    }
    function m(k) {
      if (typeof k == "object" && k !== null) {
        var ke = k.$$typeof;
        switch (ke) {
          case t:
            var L = k.type;
            switch (L) {
              case u:
              case c:
              case n:
              case o:
              case i:
              case f:
                return L;
              default:
                var Te = L && L.$$typeof;
                switch (Te) {
                  case a:
                  case l:
                  case y:
                  case h:
                  case s:
                    return Te;
                  default:
                    return ke;
                }
            }
          case r:
            return ke;
        }
      }
    }
    var b = u, w = c, R = a, C = s, M = t, $ = l, U = n, z = y, te = h, g = r, T = o, N = i, D = f, j = !1;
    function V(k) {
      return j || (j = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), B(k) || m(k) === u;
    }
    function B(k) {
      return m(k) === c;
    }
    function le(k) {
      return m(k) === a;
    }
    function pe(k) {
      return m(k) === s;
    }
    function we(k) {
      return typeof k == "object" && k !== null && k.$$typeof === t;
    }
    function Se(k) {
      return m(k) === l;
    }
    function ne(k) {
      return m(k) === n;
    }
    function ee(k) {
      return m(k) === y;
    }
    function Pe(k) {
      return m(k) === h;
    }
    function xe(k) {
      return m(k) === r;
    }
    function Ve(k) {
      return m(k) === o;
    }
    function De(k) {
      return m(k) === i;
    }
    function ut(k) {
      return m(k) === f;
    }
    K.AsyncMode = b, K.ConcurrentMode = w, K.ContextConsumer = R, K.ContextProvider = C, K.Element = M, K.ForwardRef = $, K.Fragment = U, K.Lazy = z, K.Memo = te, K.Portal = g, K.Profiler = T, K.StrictMode = N, K.Suspense = D, K.isAsyncMode = V, K.isConcurrentMode = B, K.isContextConsumer = le, K.isContextProvider = pe, K.isElement = we, K.isForwardRef = Se, K.isFragment = ne, K.isLazy = ee, K.isMemo = Pe, K.isPortal = xe, K.isProfiler = Ve, K.isStrictMode = De, K.isSuspense = ut, K.isValidElementType = S, K.typeOf = m;
  }()), K;
}
process.env.NODE_ENV === "production" ? mr.exports = zo() : mr.exports = Go();
var mi = mr.exports, Fr = mi, Ko = {
  childContextTypes: !0,
  contextType: !0,
  contextTypes: !0,
  defaultProps: !0,
  displayName: !0,
  getDefaultProps: !0,
  getDerivedStateFromError: !0,
  getDerivedStateFromProps: !0,
  mixins: !0,
  propTypes: !0,
  type: !0
}, Ho = {
  name: !0,
  length: !0,
  prototype: !0,
  caller: !0,
  callee: !0,
  arguments: !0,
  arity: !0
}, Jo = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, gi = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, jr = {};
jr[Fr.ForwardRef] = Jo;
jr[Fr.Memo] = gi;
function pn(e) {
  return Fr.isMemo(e) ? gi : jr[e.$$typeof] || Ko;
}
var Xo = Object.defineProperty, Zo = Object.getOwnPropertyNames, yn = Object.getOwnPropertySymbols, es = Object.getOwnPropertyDescriptor, ts = Object.getPrototypeOf, vn = Object.prototype;
function bi(e, t, r) {
  if (typeof t != "string") {
    if (vn) {
      var n = ts(t);
      n && n !== vn && bi(e, n, r);
    }
    var i = Zo(t);
    yn && (i = i.concat(yn(t)));
    for (var o = pn(e), s = pn(t), a = 0; a < i.length; ++a) {
      var u = i[a];
      if (!Ho[u] && !(r && r[u]) && !(s && s[u]) && !(o && o[u])) {
        var c = es(t, u);
        try {
          Xo(e, u, c);
        } catch {
        }
      }
    }
  }
  return e;
}
var rs = bi;
const ns = /* @__PURE__ */ vi(rs);
function is(e, t) {
  if (!e) {
    var r = new Error("loadable: " + t);
    throw r.framesToPop = 1, r.name = "Invariant Violation", r;
  }
}
var os = /* @__PURE__ */ ge.createContext(), ss = {
  initialChunks: {}
}, mn = "PENDING", as = "RESOLVED", Wt = "REJECTED";
function us(e) {
  return typeof e == "function" ? {
    requireAsync: e,
    resolve: function() {
    },
    chunkName: function() {
    }
  } : e;
}
var cs = function(t) {
  var r = function(i) {
    return ge.createElement(os.Consumer, null, function(o) {
      return ge.createElement(t, Object.assign({
        __chunkExtractor: o
      }, i));
    });
  };
  return t.displayName && (r.displayName = t.displayName + "WithChunkExtractor"), r;
}, ls = function(t) {
  return t;
};
function Ei(e) {
  var t = e.defaultResolveComponent, r = t === void 0 ? ls : t, n = e.render, i = e.onLoad;
  function o(a, u) {
    u === void 0 && (u = {});
    var c = us(a), l = {};
    function f(O) {
      return u.cacheKey ? u.cacheKey(O) : c.resolve ? c.resolve(O) : "static";
    }
    function d(O, x, S) {
      var m = u.resolveComponent ? u.resolveComponent(O, x) : r(O);
      if (u.resolveComponent && !mi.isValidElementType(m))
        throw new Error("resolveComponent returned something that is not a React component!");
      return ns(S, m, {
        preload: !0
      }), m;
    }
    var h = function(x) {
      var S = f(x), m = l[S];
      return (!m || m.status === Wt) && (m = c.requireAsync(x), m.status = mn, l[S] = m, m.then(function() {
        m.status = as;
      }, function(b) {
        console.error("loadable-components: failed to asynchronously load component", {
          fileName: c.resolve(x),
          chunkName: c.chunkName(x),
          error: b && b.message
        }), m.status = Wt;
      })), m;
    }, y = /* @__PURE__ */ function(O) {
      Wo(x, O), x.getDerivedStateFromProps = function(b, w) {
        var R = f(b);
        return yt({}, w, {
          cacheKey: R,
          // change of a key triggers loading state automatically
          loading: w.loading || w.cacheKey !== R
        });
      };
      function x(m) {
        var b;
        return b = O.call(this, m) || this, b.state = {
          result: null,
          error: null,
          loading: !0,
          cacheKey: f(m)
        }, is(!m.__chunkExtractor || c.requireSync, "SSR requires `@loadable/babel-plugin`, please install it"), m.__chunkExtractor ? (u.ssr === !1 || (c.requireAsync(m).catch(function() {
          return null;
        }), b.loadSync(), m.__chunkExtractor.addChunk(c.chunkName(m))), fn(b)) : (u.ssr !== !1 && // is ready - was loaded in this session
        (c.isReady && c.isReady(m) || // is ready - was loaded during SSR process
        c.chunkName && ss.initialChunks[c.chunkName(m)]) && b.loadSync(), b);
      }
      var S = x.prototype;
      return S.componentDidMount = function() {
        this.mounted = !0;
        var b = this.getCache();
        b && b.status === Wt && this.setCache(), this.state.loading && this.loadAsync();
      }, S.componentDidUpdate = function(b, w) {
        w.cacheKey !== this.state.cacheKey && this.loadAsync();
      }, S.componentWillUnmount = function() {
        this.mounted = !1;
      }, S.safeSetState = function(b, w) {
        this.mounted && this.setState(b, w);
      }, S.getCacheKey = function() {
        return f(this.props);
      }, S.getCache = function() {
        return l[this.getCacheKey()];
      }, S.setCache = function(b) {
        b === void 0 && (b = void 0), l[this.getCacheKey()] = b;
      }, S.triggerOnLoad = function() {
        var b = this;
        i && setTimeout(function() {
          i(b.state.result, b.props);
        });
      }, S.loadSync = function() {
        if (this.state.loading)
          try {
            var b = c.requireSync(this.props), w = d(b, this.props, v);
            this.state.result = w, this.state.loading = !1;
          } catch (R) {
            console.error("loadable-components: failed to synchronously load component, which expected to be available", {
              fileName: c.resolve(this.props),
              chunkName: c.chunkName(this.props),
              error: R && R.message
            }), this.state.error = R;
          }
      }, S.loadAsync = function() {
        var b = this, w = this.resolveAsync();
        return w.then(function(R) {
          var C = d(R, b.props, v);
          b.safeSetState({
            result: C,
            loading: !1
          }, function() {
            return b.triggerOnLoad();
          });
        }).catch(function(R) {
          return b.safeSetState({
            error: R,
            loading: !1
          });
        }), w;
      }, S.resolveAsync = function() {
        var b = this.props;
        b.__chunkExtractor, b.forwardedRef;
        var w = ln(b, ["__chunkExtractor", "forwardedRef"]);
        return h(w);
      }, S.render = function() {
        var b = this.props, w = b.forwardedRef, R = b.fallback;
        b.__chunkExtractor;
        var C = ln(b, ["forwardedRef", "fallback", "__chunkExtractor"]), M = this.state, $ = M.error, U = M.loading, z = M.result;
        if (u.suspense) {
          var te = this.getCache() || this.loadAsync();
          if (te.status === mn)
            throw this.loadAsync();
        }
        if ($)
          throw $;
        var g = R || u.fallback || null;
        return U ? g : n({
          fallback: g,
          result: z,
          options: u,
          props: yt({}, C, {
            ref: w
          })
        });
      }, x;
    }(ge.Component), E = cs(y), v = ge.forwardRef(function(O, x) {
      return ge.createElement(E, Object.assign({
        forwardedRef: x
      }, O));
    });
    return v.displayName = "Loadable", v.preload = function(O) {
      v.load(O);
    }, v.load = function(O) {
      return h(O);
    }, v;
  }
  function s(a, u) {
    return o(a, yt({}, u, {
      suspense: !0
    }));
  }
  return {
    loadable: o,
    lazy: s
  };
}
function fs(e) {
  return e.__esModule ? e.default : e.default || e;
}
var Si = /* @__PURE__ */ Ei({
  defaultResolveComponent: fs,
  render: function(t) {
    var r = t.result, n = t.props;
    return ge.createElement(r, n);
  }
}), ds = Si.loadable, hs = Si.lazy, Oi = /* @__PURE__ */ Ei({
  onLoad: function(t, r) {
    t && r.forwardedRef && (typeof r.forwardedRef == "function" ? r.forwardedRef(t) : r.forwardedRef.current = t);
  },
  render: function(t) {
    var r = t.result, n = t.props;
    return n.children ? n.children(r) : null;
  }
}), ps = Oi.loadable, ys = Oi.lazy, Mt = ds;
Mt.lib = ps;
var vs = hs;
vs.lib = ys;
var gr = { exports: {} }, Je = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Yt, gn;
function wi() {
  if (gn)
    return Yt;
  gn = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
  function n(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var u = Object.getOwnPropertyNames(s).map(function(l) {
        return s[l];
      });
      if (u.join("") !== "0123456789")
        return !1;
      var c = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(l) {
        c[l] = l;
      }), Object.keys(Object.assign({}, c)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Yt = i() ? Object.assign : function(o, s) {
    for (var a, u = n(o), c, l = 1; l < arguments.length; l++) {
      a = Object(arguments[l]);
      for (var f in a)
        t.call(a, f) && (u[f] = a[f]);
      if (e) {
        c = e(a);
        for (var d = 0; d < c.length; d++)
          r.call(a, c[d]) && (u[c[d]] = a[c[d]]);
      }
    }
    return u;
  }, Yt;
}
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bn;
function ms() {
  if (bn)
    return Je;
  bn = 1, wi();
  var e = ge, t = 60103;
  if (Je.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var r = Symbol.for;
    t = r("react.element"), Je.Fragment = r("react.fragment");
  }
  var n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = Object.prototype.hasOwnProperty, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, u, c) {
    var l, f = {}, d = null, h = null;
    c !== void 0 && (d = "" + c), u.key !== void 0 && (d = "" + u.key), u.ref !== void 0 && (h = u.ref);
    for (l in u)
      i.call(u, l) && !o.hasOwnProperty(l) && (f[l] = u[l]);
    if (a && a.defaultProps)
      for (l in u = a.defaultProps, u)
        f[l] === void 0 && (f[l] = u[l]);
    return { $$typeof: t, type: a, key: d, ref: h, props: f, _owner: n.current };
  }
  return Je.jsx = s, Je.jsxs = s, Je;
}
var zt = {};
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var En;
function gs() {
  return En || (En = 1, function(e) {
    process.env.NODE_ENV !== "production" && function() {
      var t = ge, r = wi(), n = 60103, i = 60106;
      e.Fragment = 60107;
      var o = 60108, s = 60114, a = 60109, u = 60110, c = 60112, l = 60113, f = 60120, d = 60115, h = 60116, y = 60121, E = 60122, v = 60117, O = 60129, x = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var S = Symbol.for;
        n = S("react.element"), i = S("react.portal"), e.Fragment = S("react.fragment"), o = S("react.strict_mode"), s = S("react.profiler"), a = S("react.provider"), u = S("react.context"), c = S("react.forward_ref"), l = S("react.suspense"), f = S("react.suspense_list"), d = S("react.memo"), h = S("react.lazy"), y = S("react.block"), E = S("react.server.block"), v = S("react.fundamental"), S("react.scope"), S("react.opaque.id"), O = S("react.debug_trace_mode"), S("react.offscreen"), x = S("react.legacy_hidden");
      }
      var m = typeof Symbol == "function" && Symbol.iterator, b = "@@iterator";
      function w(p) {
        if (p === null || typeof p != "object")
          return null;
        var A = m && p[m] || p[b];
        return typeof A == "function" ? A : null;
      }
      var R = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function C(p) {
        {
          for (var A = arguments.length, I = new Array(A > 1 ? A - 1 : 0), q = 1; q < A; q++)
            I[q - 1] = arguments[q];
          M("error", p, I);
        }
      }
      function M(p, A, I) {
        {
          var q = R.ReactDebugCurrentFrame, X = q.getStackAddendum();
          X !== "" && (A += "%s", I = I.concat([X]));
          var Z = I.map(function(Y) {
            return "" + Y;
          });
          Z.unshift("Warning: " + A), Function.prototype.apply.call(console[p], console, Z);
        }
      }
      var $ = !1;
      function U(p) {
        return !!(typeof p == "string" || typeof p == "function" || p === e.Fragment || p === s || p === O || p === o || p === l || p === f || p === x || $ || typeof p == "object" && p !== null && (p.$$typeof === h || p.$$typeof === d || p.$$typeof === a || p.$$typeof === u || p.$$typeof === c || p.$$typeof === v || p.$$typeof === y || p[0] === E));
      }
      function z(p, A, I) {
        var q = A.displayName || A.name || "";
        return p.displayName || (q !== "" ? I + "(" + q + ")" : I);
      }
      function te(p) {
        return p.displayName || "Context";
      }
      function g(p) {
        if (p == null)
          return null;
        if (typeof p.tag == "number" && C("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof p == "function")
          return p.displayName || p.name || null;
        if (typeof p == "string")
          return p;
        switch (p) {
          case e.Fragment:
            return "Fragment";
          case i:
            return "Portal";
          case s:
            return "Profiler";
          case o:
            return "StrictMode";
          case l:
            return "Suspense";
          case f:
            return "SuspenseList";
        }
        if (typeof p == "object")
          switch (p.$$typeof) {
            case u:
              var A = p;
              return te(A) + ".Consumer";
            case a:
              var I = p;
              return te(I._context) + ".Provider";
            case c:
              return z(p, p.render, "ForwardRef");
            case d:
              return g(p.type);
            case y:
              return g(p._render);
            case h: {
              var q = p, X = q._payload, Z = q._init;
              try {
                return g(Z(X));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var T = 0, N, D, j, V, B, le, pe;
      function we() {
      }
      we.__reactDisabledLog = !0;
      function Se() {
        {
          if (T === 0) {
            N = console.log, D = console.info, j = console.warn, V = console.error, B = console.group, le = console.groupCollapsed, pe = console.groupEnd;
            var p = {
              configurable: !0,
              enumerable: !0,
              value: we,
              writable: !0
            };
            Object.defineProperties(console, {
              info: p,
              log: p,
              warn: p,
              error: p,
              group: p,
              groupCollapsed: p,
              groupEnd: p
            });
          }
          T++;
        }
      }
      function ne() {
        {
          if (T--, T === 0) {
            var p = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: r({}, p, {
                value: N
              }),
              info: r({}, p, {
                value: D
              }),
              warn: r({}, p, {
                value: j
              }),
              error: r({}, p, {
                value: V
              }),
              group: r({}, p, {
                value: B
              }),
              groupCollapsed: r({}, p, {
                value: le
              }),
              groupEnd: r({}, p, {
                value: pe
              })
            });
          }
          T < 0 && C("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ee = R.ReactCurrentDispatcher, Pe;
      function xe(p, A, I) {
        {
          if (Pe === void 0)
            try {
              throw Error();
            } catch (X) {
              var q = X.stack.trim().match(/\n( *(at )?)/);
              Pe = q && q[1] || "";
            }
          return `
` + Pe + p;
        }
      }
      var Ve = !1, De;
      {
        var ut = typeof WeakMap == "function" ? WeakMap : Map;
        De = new ut();
      }
      function k(p, A) {
        if (!p || Ve)
          return "";
        {
          var I = De.get(p);
          if (I !== void 0)
            return I;
        }
        var q;
        Ve = !0;
        var X = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Z;
        Z = ee.current, ee.current = null, Se();
        try {
          if (A) {
            var Y = function() {
              throw Error();
            };
            if (Object.defineProperty(Y.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Y, []);
              } catch (Ae) {
                q = Ae;
              }
              Reflect.construct(p, [], Y);
            } else {
              try {
                Y.call();
              } catch (Ae) {
                q = Ae;
              }
              p.call(Y.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Ae) {
              q = Ae;
            }
            p();
          }
        } catch (Ae) {
          if (Ae && q && typeof Ae.stack == "string") {
            for (var W = Ae.stack.split(`
`), ve = q.stack.split(`
`), oe = W.length - 1, ue = ve.length - 1; oe >= 1 && ue >= 0 && W[oe] !== ve[ue]; )
              ue--;
            for (; oe >= 1 && ue >= 0; oe--, ue--)
              if (W[oe] !== ve[ue]) {
                if (oe !== 1 || ue !== 1)
                  do
                    if (oe--, ue--, ue < 0 || W[oe] !== ve[ue]) {
                      var Re = `
` + W[oe].replace(" at new ", " at ");
                      return typeof p == "function" && De.set(p, Re), Re;
                    }
                  while (oe >= 1 && ue >= 0);
                break;
              }
          }
        } finally {
          Ve = !1, ee.current = Z, ne(), Error.prepareStackTrace = X;
        }
        var He = p ? p.displayName || p.name : "", un = He ? xe(He) : "";
        return typeof p == "function" && De.set(p, un), un;
      }
      function ke(p, A, I) {
        return k(p, !1);
      }
      function L(p) {
        var A = p.prototype;
        return !!(A && A.isReactComponent);
      }
      function Te(p, A, I) {
        if (p == null)
          return "";
        if (typeof p == "function")
          return k(p, L(p));
        if (typeof p == "string")
          return xe(p);
        switch (p) {
          case l:
            return xe("Suspense");
          case f:
            return xe("SuspenseList");
        }
        if (typeof p == "object")
          switch (p.$$typeof) {
            case c:
              return ke(p.render);
            case d:
              return Te(p.type, A, I);
            case y:
              return ke(p._render);
            case h: {
              var q = p, X = q._payload, Z = q._init;
              try {
                return Te(Z(X), A, I);
              } catch {
              }
            }
          }
        return "";
      }
      var $e = {}, ct = R.ReactDebugCurrentFrame;
      function Ot(p) {
        if (p) {
          var A = p._owner, I = Te(p.type, p._source, A ? A.type : null);
          ct.setExtraStackFrame(I);
        } else
          ct.setExtraStackFrame(null);
      }
      function Oo(p, A, I, q, X) {
        {
          var Z = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var Y in p)
            if (Z(p, Y)) {
              var W = void 0;
              try {
                if (typeof p[Y] != "function") {
                  var ve = Error((q || "React class") + ": " + I + " type `" + Y + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof p[Y] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw ve.name = "Invariant Violation", ve;
                }
                W = p[Y](A, Y, q, I, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (oe) {
                W = oe;
              }
              W && !(W instanceof Error) && (Ot(X), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", q || "React class", I, Y, typeof W), Ot(null)), W instanceof Error && !(W.message in $e) && ($e[W.message] = !0, Ot(X), C("Failed %s type: %s", I, W.message), Ot(null));
            }
        }
      }
      var lt = R.ReactCurrentOwner, Ut = Object.prototype.hasOwnProperty, wo = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Zr, en, Vt;
      Vt = {};
      function To(p) {
        if (Ut.call(p, "ref")) {
          var A = Object.getOwnPropertyDescriptor(p, "ref").get;
          if (A && A.isReactWarning)
            return !1;
        }
        return p.ref !== void 0;
      }
      function _o(p) {
        if (Ut.call(p, "key")) {
          var A = Object.getOwnPropertyDescriptor(p, "key").get;
          if (A && A.isReactWarning)
            return !1;
        }
        return p.key !== void 0;
      }
      function xo(p, A) {
        if (typeof p.ref == "string" && lt.current && A && lt.current.stateNode !== A) {
          var I = g(lt.current.type);
          Vt[I] || (C('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', g(lt.current.type), p.ref), Vt[I] = !0);
        }
      }
      function Co(p, A) {
        {
          var I = function() {
            Zr || (Zr = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
          };
          I.isReactWarning = !0, Object.defineProperty(p, "key", {
            get: I,
            configurable: !0
          });
        }
      }
      function Ro(p, A) {
        {
          var I = function() {
            en || (en = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
          };
          I.isReactWarning = !0, Object.defineProperty(p, "ref", {
            get: I,
            configurable: !0
          });
        }
      }
      var Ao = function(p, A, I, q, X, Z, Y) {
        var W = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: n,
          // Built-in properties that belong on the element
          type: p,
          key: A,
          ref: I,
          props: Y,
          // Record the component responsible for creating this element.
          _owner: Z
        };
        return W._store = {}, Object.defineProperty(W._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(W, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: q
        }), Object.defineProperty(W, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: X
        }), Object.freeze && (Object.freeze(W.props), Object.freeze(W)), W;
      };
      function No(p, A, I, q, X) {
        {
          var Z, Y = {}, W = null, ve = null;
          I !== void 0 && (W = "" + I), _o(A) && (W = "" + A.key), To(A) && (ve = A.ref, xo(A, X));
          for (Z in A)
            Ut.call(A, Z) && !wo.hasOwnProperty(Z) && (Y[Z] = A[Z]);
          if (p && p.defaultProps) {
            var oe = p.defaultProps;
            for (Z in oe)
              Y[Z] === void 0 && (Y[Z] = oe[Z]);
          }
          if (W || ve) {
            var ue = typeof p == "function" ? p.displayName || p.name || "Unknown" : p;
            W && Co(Y, ue), ve && Ro(Y, ue);
          }
          return Ao(p, W, ve, X, q, lt.current, Y);
        }
      }
      var $t = R.ReactCurrentOwner, tn = R.ReactDebugCurrentFrame;
      function Ke(p) {
        if (p) {
          var A = p._owner, I = Te(p.type, p._source, A ? A.type : null);
          tn.setExtraStackFrame(I);
        } else
          tn.setExtraStackFrame(null);
      }
      var Bt;
      Bt = !1;
      function Qt(p) {
        return typeof p == "object" && p !== null && p.$$typeof === n;
      }
      function rn() {
        {
          if ($t.current) {
            var p = g($t.current.type);
            if (p)
              return `

Check the render method of \`` + p + "`.";
          }
          return "";
        }
      }
      function Io(p) {
        {
          if (p !== void 0) {
            var A = p.fileName.replace(/^.*[\\\/]/, ""), I = p.lineNumber;
            return `

Check your code at ` + A + ":" + I + ".";
          }
          return "";
        }
      }
      var nn = {};
      function Po(p) {
        {
          var A = rn();
          if (!A) {
            var I = typeof p == "string" ? p : p.displayName || p.name;
            I && (A = `

Check the top-level render call using <` + I + ">.");
          }
          return A;
        }
      }
      function on(p, A) {
        {
          if (!p._store || p._store.validated || p.key != null)
            return;
          p._store.validated = !0;
          var I = Po(A);
          if (nn[I])
            return;
          nn[I] = !0;
          var q = "";
          p && p._owner && p._owner !== $t.current && (q = " It was passed a child from " + g(p._owner.type) + "."), Ke(p), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', I, q), Ke(null);
        }
      }
      function sn(p, A) {
        {
          if (typeof p != "object")
            return;
          if (Array.isArray(p))
            for (var I = 0; I < p.length; I++) {
              var q = p[I];
              Qt(q) && on(q, A);
            }
          else if (Qt(p))
            p._store && (p._store.validated = !0);
          else if (p) {
            var X = w(p);
            if (typeof X == "function" && X !== p.entries)
              for (var Z = X.call(p), Y; !(Y = Z.next()).done; )
                Qt(Y.value) && on(Y.value, A);
          }
        }
      }
      function Do(p) {
        {
          var A = p.type;
          if (A == null || typeof A == "string")
            return;
          var I;
          if (typeof A == "function")
            I = A.propTypes;
          else if (typeof A == "object" && (A.$$typeof === c || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          A.$$typeof === d))
            I = A.propTypes;
          else
            return;
          if (I) {
            var q = g(A);
            Oo(I, p.props, "prop", q, p);
          } else if (A.PropTypes !== void 0 && !Bt) {
            Bt = !0;
            var X = g(A);
            C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", X || "Unknown");
          }
          typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function ko(p) {
        {
          for (var A = Object.keys(p.props), I = 0; I < A.length; I++) {
            var q = A[I];
            if (q !== "children" && q !== "key") {
              Ke(p), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", q), Ke(null);
              break;
            }
          }
          p.ref !== null && (Ke(p), C("Invalid attribute `ref` supplied to `React.Fragment`."), Ke(null));
        }
      }
      function an(p, A, I, q, X, Z) {
        {
          var Y = U(p);
          if (!Y) {
            var W = "";
            (p === void 0 || typeof p == "object" && p !== null && Object.keys(p).length === 0) && (W += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var ve = Io(X);
            ve ? W += ve : W += rn();
            var oe;
            p === null ? oe = "null" : Array.isArray(p) ? oe = "array" : p !== void 0 && p.$$typeof === n ? (oe = "<" + (g(p.type) || "Unknown") + " />", W = " Did you accidentally export a JSX literal instead of a component?") : oe = typeof p, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", oe, W);
          }
          var ue = No(p, A, I, X, Z);
          if (ue == null)
            return ue;
          if (Y) {
            var Re = A.children;
            if (Re !== void 0)
              if (q)
                if (Array.isArray(Re)) {
                  for (var He = 0; He < Re.length; He++)
                    sn(Re[He], p);
                  Object.freeze && Object.freeze(Re);
                } else
                  C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                sn(Re, p);
          }
          return p === e.Fragment ? ko(ue) : Do(ue), ue;
        }
      }
      function Lo(p, A, I) {
        return an(p, A, I, !0);
      }
      function Mo(p, A, I) {
        return an(p, A, I, !1);
      }
      var Fo = Mo, jo = Lo;
      e.jsx = Fo, e.jsxs = jo;
    }();
  }(zt)), zt;
}
process.env.NODE_ENV === "production" ? gr.exports = ms() : gr.exports = gs();
var Sn = gr.exports, br = { exports: {} }, Gt = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var On;
function bs() {
  if (On)
    return Gt;
  On = 1;
  var e = ge;
  function t(f, d) {
    return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d;
  }
  var r = typeof Object.is == "function" ? Object.is : t, n = e.useState, i = e.useEffect, o = e.useLayoutEffect, s = e.useDebugValue;
  function a(f, d) {
    var h = d(), y = n({ inst: { value: h, getSnapshot: d } }), E = y[0].inst, v = y[1];
    return o(function() {
      E.value = h, E.getSnapshot = d, u(E) && v({ inst: E });
    }, [f, h, d]), i(function() {
      return u(E) && v({ inst: E }), f(function() {
        u(E) && v({ inst: E });
      });
    }, [f]), s(h), h;
  }
  function u(f) {
    var d = f.getSnapshot;
    f = f.value;
    try {
      var h = d();
      return !r(f, h);
    } catch {
      return !0;
    }
  }
  function c(f, d) {
    return d();
  }
  var l = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
  return Gt.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : l, Gt;
}
var Kt = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wn;
function Es() {
  return wn || (wn = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = ge, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(S) {
      {
        for (var m = arguments.length, b = new Array(m > 1 ? m - 1 : 0), w = 1; w < m; w++)
          b[w - 1] = arguments[w];
        n("error", S, b);
      }
    }
    function n(S, m, b) {
      {
        var w = t.ReactDebugCurrentFrame, R = w.getStackAddendum();
        R !== "" && (m += "%s", b = b.concat([R]));
        var C = b.map(function(M) {
          return String(M);
        });
        C.unshift("Warning: " + m), Function.prototype.apply.call(console[S], console, C);
      }
    }
    function i(S, m) {
      return S === m && (S !== 0 || 1 / S === 1 / m) || S !== S && m !== m;
    }
    var o = typeof Object.is == "function" ? Object.is : i, s = e.useState, a = e.useEffect, u = e.useLayoutEffect, c = e.useDebugValue, l = !1, f = !1;
    function d(S, m, b) {
      l || e.startTransition !== void 0 && (l = !0, r("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var w = m();
      if (!f) {
        var R = m();
        o(w, R) || (r("The result of getSnapshot should be cached to avoid an infinite loop"), f = !0);
      }
      var C = s({
        inst: {
          value: w,
          getSnapshot: m
        }
      }), M = C[0].inst, $ = C[1];
      return u(function() {
        M.value = w, M.getSnapshot = m, h(M) && $({
          inst: M
        });
      }, [S, w, m]), a(function() {
        h(M) && $({
          inst: M
        });
        var U = function() {
          h(M) && $({
            inst: M
          });
        };
        return S(U);
      }, [S]), c(w), w;
    }
    function h(S) {
      var m = S.getSnapshot, b = S.value;
      try {
        var w = m();
        return !o(b, w);
      } catch {
        return !0;
      }
    }
    function y(S, m, b) {
      return m();
    }
    var E = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", v = !E, O = v ? y : d, x = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : O;
    Kt.useSyncExternalStore = x, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Kt;
}
process.env.NODE_ENV === "production" ? br.exports = bs() : br.exports = Es();
var qr = br.exports, Er = { exports: {} }, Ht = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tn;
function Ss() {
  if (Tn)
    return Ht;
  Tn = 1;
  var e = ge, t = qr;
  function r(c, l) {
    return c === l && (c !== 0 || 1 / c === 1 / l) || c !== c && l !== l;
  }
  var n = typeof Object.is == "function" ? Object.is : r, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, u = e.useDebugValue;
  return Ht.useSyncExternalStoreWithSelector = function(c, l, f, d, h) {
    var y = o(null);
    if (y.current === null) {
      var E = { hasValue: !1, value: null };
      y.current = E;
    } else
      E = y.current;
    y = a(function() {
      function O(w) {
        if (!x) {
          if (x = !0, S = w, w = d(w), h !== void 0 && E.hasValue) {
            var R = E.value;
            if (h(R, w))
              return m = R;
          }
          return m = w;
        }
        if (R = m, n(S, w))
          return R;
        var C = d(w);
        return h !== void 0 && h(R, C) ? R : (S = w, m = C);
      }
      var x = !1, S, m, b = f === void 0 ? null : f;
      return [function() {
        return O(l());
      }, b === null ? void 0 : function() {
        return O(b());
      }];
    }, [l, f, d, h]);
    var v = i(c, y[0], y[1]);
    return s(function() {
      E.hasValue = !0, E.value = v;
    }, [v]), u(v), v;
  }, Ht;
}
var Jt = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _n;
function Os() {
  return _n || (_n = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = ge, t = qr;
    function r(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var n = typeof Object.is == "function" ? Object.is : r, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, u = e.useDebugValue;
    function c(l, f, d, h, y) {
      var E = o(null), v;
      E.current === null ? (v = {
        hasValue: !1,
        value: null
      }, E.current = v) : v = E.current;
      var O = a(function() {
        var b = !1, w, R, C = function(z) {
          if (!b) {
            b = !0, w = z;
            var te = h(z);
            if (y !== void 0 && v.hasValue) {
              var g = v.value;
              if (y(g, te))
                return R = g, g;
            }
            return R = te, te;
          }
          var T = w, N = R;
          if (n(T, z))
            return N;
          var D = h(z);
          return y !== void 0 && y(N, D) ? N : (w = z, R = D, D);
        }, M = d === void 0 ? null : d, $ = function() {
          return C(f());
        }, U = M === null ? void 0 : function() {
          return C(M());
        };
        return [$, U];
      }, [f, d, h, y]), x = O[0], S = O[1], m = i(l, x, S);
      return s(function() {
        v.hasValue = !0, v.value = m;
      }, [m]), u(m), m;
    }
    Jt.useSyncExternalStoreWithSelector = c, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Jt;
}
process.env.NODE_ENV === "production" ? Er.exports = Ss() : Er.exports = Os();
var ws = Er.exports;
function Ts(e) {
  e();
}
let Ti = Ts;
const _s = (e) => Ti = e, xs = () => Ti, Ne = /* @__PURE__ */ qo(null);
process.env.NODE_ENV !== "production" && (Ne.displayName = "ReactRedux");
function _i() {
  const e = Mr(Ne);
  if (process.env.NODE_ENV !== "production" && !e)
    throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");
  return e;
}
const Cs = () => {
  throw new Error("uSES not initialized!");
};
let xi = Cs;
const Rs = (e) => {
  xi = e;
}, As = (e, t) => e === t;
function Ns(e = Ne) {
  const t = e === Ne ? _i : () => Mr(e);
  return function(n, i = As) {
    if (process.env.NODE_ENV !== "production") {
      if (!n)
        throw new Error("You must pass a selector to useSelector");
      if (typeof n != "function")
        throw new Error("You must pass a function as a selector to useSelector");
      if (typeof i != "function")
        throw new Error("You must pass a function as an equality function to useSelector");
    }
    const {
      store: o,
      subscription: s,
      getServerState: a
    } = t(), u = xi(s.addNestedSub, o.getState, a || o.getState, n, i);
    return Uo(u), u;
  };
}
const Is = /* @__PURE__ */ Ns();
var H = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xn;
function Ps() {
  if (xn)
    return H;
  xn = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y;
  y = Symbol.for("react.module.reference");
  function E(v) {
    if (typeof v == "object" && v !== null) {
      var O = v.$$typeof;
      switch (O) {
        case e:
          switch (v = v.type, v) {
            case r:
            case i:
            case n:
            case c:
            case l:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case s:
                case u:
                case d:
                case f:
                case o:
                  return v;
                default:
                  return O;
              }
          }
        case t:
          return O;
      }
    }
  }
  return H.ContextConsumer = s, H.ContextProvider = o, H.Element = e, H.ForwardRef = u, H.Fragment = r, H.Lazy = d, H.Memo = f, H.Portal = t, H.Profiler = i, H.StrictMode = n, H.Suspense = c, H.SuspenseList = l, H.isAsyncMode = function() {
    return !1;
  }, H.isConcurrentMode = function() {
    return !1;
  }, H.isContextConsumer = function(v) {
    return E(v) === s;
  }, H.isContextProvider = function(v) {
    return E(v) === o;
  }, H.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, H.isForwardRef = function(v) {
    return E(v) === u;
  }, H.isFragment = function(v) {
    return E(v) === r;
  }, H.isLazy = function(v) {
    return E(v) === d;
  }, H.isMemo = function(v) {
    return E(v) === f;
  }, H.isPortal = function(v) {
    return E(v) === t;
  }, H.isProfiler = function(v) {
    return E(v) === i;
  }, H.isStrictMode = function(v) {
    return E(v) === n;
  }, H.isSuspense = function(v) {
    return E(v) === c;
  }, H.isSuspenseList = function(v) {
    return E(v) === l;
  }, H.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === i || v === n || v === c || v === l || v === h || typeof v == "object" && v !== null && (v.$$typeof === d || v.$$typeof === f || v.$$typeof === o || v.$$typeof === s || v.$$typeof === u || v.$$typeof === y || v.getModuleId !== void 0);
  }, H.typeOf = E, H;
}
var J = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cn;
function Ds() {
  return Cn || (Cn = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), y = !1, E = !1, v = !1, O = !1, x = !1, S;
    S = Symbol.for("react.module.reference");
    function m(L) {
      return !!(typeof L == "string" || typeof L == "function" || L === r || L === i || x || L === n || L === c || L === l || O || L === h || y || E || v || typeof L == "object" && L !== null && (L.$$typeof === d || L.$$typeof === f || L.$$typeof === o || L.$$typeof === s || L.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      L.$$typeof === S || L.getModuleId !== void 0));
    }
    function b(L) {
      if (typeof L == "object" && L !== null) {
        var Te = L.$$typeof;
        switch (Te) {
          case e:
            var $e = L.type;
            switch ($e) {
              case r:
              case i:
              case n:
              case c:
              case l:
                return $e;
              default:
                var ct = $e && $e.$$typeof;
                switch (ct) {
                  case a:
                  case s:
                  case u:
                  case d:
                  case f:
                  case o:
                    return ct;
                  default:
                    return Te;
                }
            }
          case t:
            return Te;
        }
      }
    }
    var w = s, R = o, C = e, M = u, $ = r, U = d, z = f, te = t, g = i, T = n, N = c, D = l, j = !1, V = !1;
    function B(L) {
      return j || (j = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function le(L) {
      return V || (V = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function pe(L) {
      return b(L) === s;
    }
    function we(L) {
      return b(L) === o;
    }
    function Se(L) {
      return typeof L == "object" && L !== null && L.$$typeof === e;
    }
    function ne(L) {
      return b(L) === u;
    }
    function ee(L) {
      return b(L) === r;
    }
    function Pe(L) {
      return b(L) === d;
    }
    function xe(L) {
      return b(L) === f;
    }
    function Ve(L) {
      return b(L) === t;
    }
    function De(L) {
      return b(L) === i;
    }
    function ut(L) {
      return b(L) === n;
    }
    function k(L) {
      return b(L) === c;
    }
    function ke(L) {
      return b(L) === l;
    }
    J.ContextConsumer = w, J.ContextProvider = R, J.Element = C, J.ForwardRef = M, J.Fragment = $, J.Lazy = U, J.Memo = z, J.Portal = te, J.Profiler = g, J.StrictMode = T, J.Suspense = N, J.SuspenseList = D, J.isAsyncMode = B, J.isConcurrentMode = le, J.isContextConsumer = pe, J.isContextProvider = we, J.isElement = Se, J.isForwardRef = ne, J.isFragment = ee, J.isLazy = Pe, J.isMemo = xe, J.isPortal = Ve, J.isProfiler = De, J.isStrictMode = ut, J.isSuspense = k, J.isSuspenseList = ke, J.isValidElementType = m, J.typeOf = b;
  }()), J;
}
process.env.NODE_ENV === "production" ? Ps() : Ds();
function ks() {
  const e = xs();
  let t = null, r = null;
  return {
    clear() {
      t = null, r = null;
    },
    notify() {
      e(() => {
        let n = t;
        for (; n; )
          n.callback(), n = n.next;
      });
    },
    get() {
      let n = [], i = t;
      for (; i; )
        n.push(i), i = i.next;
      return n;
    },
    subscribe(n) {
      let i = !0, o = r = {
        callback: n,
        next: null,
        prev: r
      };
      return o.prev ? o.prev.next = o : t = o, function() {
        !i || t === null || (i = !1, o.next ? o.next.prev = o.prev : r = o.prev, o.prev ? o.prev.next = o.next : t = o.next);
      };
    }
  };
}
const Rn = {
  notify() {
  },
  get: () => []
};
function Ls(e, t) {
  let r, n = Rn;
  function i(f) {
    return u(), n.subscribe(f);
  }
  function o() {
    n.notify();
  }
  function s() {
    l.onStateChange && l.onStateChange();
  }
  function a() {
    return !!r;
  }
  function u() {
    r || (r = t ? t.addNestedSub(s) : e.subscribe(s), n = ks());
  }
  function c() {
    r && (r(), r = void 0, n.clear(), n = Rn);
  }
  const l = {
    addNestedSub: i,
    notifyNestedSubs: o,
    handleChangeWrapper: s,
    isSubscribed: a,
    trySubscribe: u,
    tryUnsubscribe: c,
    getListeners: () => n
  };
  return l;
}
const Ms = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Fs = Ms ? Vo : $o;
function js({
  store: e,
  context: t,
  children: r,
  serverState: n
}) {
  const i = cn(() => {
    const a = Ls(e);
    return {
      store: e,
      subscription: a,
      getServerState: n ? () => n : void 0
    };
  }, [e, n]), o = cn(() => e.getState(), [e]);
  Fs(() => {
    const {
      subscription: a
    } = i;
    return a.onStateChange = a.notifyNestedSubs, a.trySubscribe(), o !== e.getState() && a.notifyNestedSubs(), () => {
      a.tryUnsubscribe(), a.onStateChange = void 0;
    };
  }, [i, o]);
  const s = t || Ne;
  return /* @__PURE__ */ ge.createElement(s.Provider, {
    value: i
  }, r);
}
function Ci(e = Ne) {
  const t = (
    // @ts-ignore
    e === Ne ? _i : () => Mr(e)
  );
  return function() {
    const {
      store: n
    } = t();
    return n;
  };
}
const qs = /* @__PURE__ */ Ci();
function Us(e = Ne) {
  const t = (
    // @ts-ignore
    e === Ne ? qs : Ci(e)
  );
  return function() {
    return t().dispatch;
  };
}
const Vs = /* @__PURE__ */ Us();
Rs(ws.useSyncExternalStoreWithSelector);
_s(Bo);
function de(e) {
  for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  if (process.env.NODE_ENV !== "production") {
    var i = Hs[e], o = i ? typeof i == "function" ? i.apply(null, r) : i : "unknown error nr: " + e;
    throw Error("[Immer] " + o);
  }
  throw Error("[Immer] minified error nr: " + e + (r.length ? " " + r.map(function(s) {
    return "'" + s + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function Ue(e) {
  return !!e && !!e[re];
}
function Ie(e) {
  var t;
  return !!e && (function(r) {
    if (!r || typeof r != "object")
      return !1;
    var n = Object.getPrototypeOf(r);
    if (n === null)
      return !0;
    var i = Object.hasOwnProperty.call(n, "constructor") && n.constructor;
    return i === Object || typeof i == "function" && Function.toString.call(i) === Js;
  }(e) || Array.isArray(e) || !!e[Ln] || !!(!((t = e.constructor) === null || t === void 0) && t[Ln]) || Ur(e) || Vr(e));
}
function ze(e, t, r) {
  r === void 0 && (r = !1), ot(e) === 0 ? (r ? Object.keys : rt)(e).forEach(function(n) {
    r && typeof n == "symbol" || t(n, e[n], e);
  }) : e.forEach(function(n, i) {
    return t(i, n, e);
  });
}
function ot(e) {
  var t = e[re];
  return t ? t.i > 3 ? t.i - 4 : t.i : Array.isArray(e) ? 1 : Ur(e) ? 2 : Vr(e) ? 3 : 0;
}
function tt(e, t) {
  return ot(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function $s(e, t) {
  return ot(e) === 2 ? e.get(t) : e[t];
}
function Ri(e, t, r) {
  var n = ot(e);
  n === 2 ? e.set(t, r) : n === 3 ? e.add(r) : e[t] = r;
}
function Ai(e, t) {
  return e === t ? e !== 0 || 1 / e == 1 / t : e != e && t != t;
}
function Ur(e) {
  return Gs && e instanceof Map;
}
function Vr(e) {
  return Ks && e instanceof Set;
}
function Le(e) {
  return e.o || e.t;
}
function $r(e) {
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  var t = Ii(e);
  delete t[re];
  for (var r = rt(t), n = 0; n < r.length; n++) {
    var i = r[n], o = t[i];
    o.writable === !1 && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (t[i] = { configurable: !0, writable: !0, enumerable: o.enumerable, value: e[i] });
  }
  return Object.create(Object.getPrototypeOf(e), t);
}
function Br(e, t) {
  return t === void 0 && (t = !1), Qr(e) || Ue(e) || !Ie(e) || (ot(e) > 1 && (e.set = e.add = e.clear = e.delete = Bs), Object.freeze(e), t && ze(e, function(r, n) {
    return Br(n, !0);
  }, !0)), e;
}
function Bs() {
  de(2);
}
function Qr(e) {
  return e == null || typeof e != "object" || Object.isFrozen(e);
}
function Ce(e) {
  var t = Tr[e];
  return t || de(18, e), t;
}
function Qs(e, t) {
  Tr[e] || (Tr[e] = t);
}
function Sr() {
  return process.env.NODE_ENV === "production" || nt || de(0), nt;
}
function Xt(e, t) {
  t && (Ce("Patches"), e.u = [], e.s = [], e.v = t);
}
function At(e) {
  Or(e), e.p.forEach(Ws), e.p = null;
}
function Or(e) {
  e === nt && (nt = e.l);
}
function An(e) {
  return nt = { p: [], l: nt, h: e, m: !0, _: 0 };
}
function Ws(e) {
  var t = e[re];
  t.i === 0 || t.i === 1 ? t.j() : t.g = !0;
}
function Zt(e, t) {
  t._ = t.p.length;
  var r = t.p[0], n = e !== void 0 && e !== r;
  return t.h.O || Ce("ES5").S(t, e, n), n ? (r[re].P && (At(t), de(4)), Ie(e) && (e = Nt(t, e), t.l || It(t, e)), t.u && Ce("Patches").M(r[re].t, e, t.u, t.s)) : e = Nt(t, r, []), At(t), t.u && t.v(t.u, t.s), e !== Ni ? e : void 0;
}
function Nt(e, t, r) {
  if (Qr(t))
    return t;
  var n = t[re];
  if (!n)
    return ze(t, function(a, u) {
      return Nn(e, n, t, a, u, r);
    }, !0), t;
  if (n.A !== e)
    return t;
  if (!n.P)
    return It(e, n.t, !0), n.t;
  if (!n.I) {
    n.I = !0, n.A._--;
    var i = n.i === 4 || n.i === 5 ? n.o = $r(n.k) : n.o, o = i, s = !1;
    n.i === 3 && (o = new Set(i), i.clear(), s = !0), ze(o, function(a, u) {
      return Nn(e, n, i, a, u, r, s);
    }), It(e, i, !1), r && e.u && Ce("Patches").N(n, r, e.u, e.s);
  }
  return n.o;
}
function Nn(e, t, r, n, i, o, s) {
  if (process.env.NODE_ENV !== "production" && i === r && de(5), Ue(i)) {
    var a = Nt(e, i, o && t && t.i !== 3 && !tt(t.R, n) ? o.concat(n) : void 0);
    if (Ri(r, n, a), !Ue(a))
      return;
    e.m = !1;
  } else
    s && r.add(i);
  if (Ie(i) && !Qr(i)) {
    if (!e.h.D && e._ < 1)
      return;
    Nt(e, i), t && t.A.l || It(e, i);
  }
}
function It(e, t, r) {
  r === void 0 && (r = !1), !e.l && e.h.D && e.m && Br(t, r);
}
function er(e, t) {
  var r = e[re];
  return (r ? Le(r) : e)[t];
}
function In(e, t) {
  if (t in e)
    for (var r = Object.getPrototypeOf(e); r; ) {
      var n = Object.getOwnPropertyDescriptor(r, t);
      if (n)
        return n;
      r = Object.getPrototypeOf(r);
    }
}
function Fe(e) {
  e.P || (e.P = !0, e.l && Fe(e.l));
}
function tr(e) {
  e.o || (e.o = $r(e.t));
}
function wr(e, t, r) {
  var n = Ur(t) ? Ce("MapSet").F(t, r) : Vr(t) ? Ce("MapSet").T(t, r) : e.O ? function(i, o) {
    var s = Array.isArray(i), a = { i: s ? 1 : 0, A: o ? o.A : Sr(), P: !1, I: !1, R: {}, l: o, t: i, k: null, o: null, j: null, C: !1 }, u = a, c = mt;
    s && (u = [a], c = dt);
    var l = Proxy.revocable(u, c), f = l.revoke, d = l.proxy;
    return a.k = d, a.j = f, d;
  }(t, r) : Ce("ES5").J(t, r);
  return (r ? r.A : Sr()).p.push(n), n;
}
function Ys(e) {
  return Ue(e) || de(22, e), function t(r) {
    if (!Ie(r))
      return r;
    var n, i = r[re], o = ot(r);
    if (i) {
      if (!i.P && (i.i < 4 || !Ce("ES5").K(i)))
        return i.t;
      i.I = !0, n = Pn(r, o), i.I = !1;
    } else
      n = Pn(r, o);
    return ze(n, function(s, a) {
      i && $s(i.t, s) === a || Ri(n, s, t(a));
    }), o === 3 ? new Set(n) : n;
  }(e);
}
function Pn(e, t) {
  switch (t) {
    case 2:
      return new Map(e);
    case 3:
      return Array.from(e);
  }
  return $r(e);
}
function zs() {
  function e(s, a) {
    var u = o[s];
    return u ? u.enumerable = a : o[s] = u = { configurable: !0, enumerable: a, get: function() {
      var c = this[re];
      return process.env.NODE_ENV !== "production" && i(c), mt.get(c, s);
    }, set: function(c) {
      var l = this[re];
      process.env.NODE_ENV !== "production" && i(l), mt.set(l, s, c);
    } }, u;
  }
  function t(s) {
    for (var a = s.length - 1; a >= 0; a--) {
      var u = s[a][re];
      if (!u.P)
        switch (u.i) {
          case 5:
            n(u) && Fe(u);
            break;
          case 4:
            r(u) && Fe(u);
        }
    }
  }
  function r(s) {
    for (var a = s.t, u = s.k, c = rt(u), l = c.length - 1; l >= 0; l--) {
      var f = c[l];
      if (f !== re) {
        var d = a[f];
        if (d === void 0 && !tt(a, f))
          return !0;
        var h = u[f], y = h && h[re];
        if (y ? y.t !== d : !Ai(h, d))
          return !0;
      }
    }
    var E = !!a[re];
    return c.length !== rt(a).length + (E ? 0 : 1);
  }
  function n(s) {
    var a = s.k;
    if (a.length !== s.t.length)
      return !0;
    var u = Object.getOwnPropertyDescriptor(a, a.length - 1);
    if (u && !u.get)
      return !0;
    for (var c = 0; c < a.length; c++)
      if (!a.hasOwnProperty(c))
        return !0;
    return !1;
  }
  function i(s) {
    s.g && de(3, JSON.stringify(Le(s)));
  }
  var o = {};
  Qs("ES5", { J: function(s, a) {
    var u = Array.isArray(s), c = function(f, d) {
      if (f) {
        for (var h = Array(d.length), y = 0; y < d.length; y++)
          Object.defineProperty(h, "" + y, e(y, !0));
        return h;
      }
      var E = Ii(d);
      delete E[re];
      for (var v = rt(E), O = 0; O < v.length; O++) {
        var x = v[O];
        E[x] = e(x, f || !!E[x].enumerable);
      }
      return Object.create(Object.getPrototypeOf(d), E);
    }(u, s), l = { i: u ? 5 : 4, A: a ? a.A : Sr(), P: !1, I: !1, R: {}, l: a, t: s, k: c, o: null, g: !1, C: !1 };
    return Object.defineProperty(c, re, { value: l, writable: !0 }), c;
  }, S: function(s, a, u) {
    u ? Ue(a) && a[re].A === s && t(s.p) : (s.u && function c(l) {
      if (l && typeof l == "object") {
        var f = l[re];
        if (f) {
          var d = f.t, h = f.k, y = f.R, E = f.i;
          if (E === 4)
            ze(h, function(m) {
              m !== re && (d[m] !== void 0 || tt(d, m) ? y[m] || c(h[m]) : (y[m] = !0, Fe(f)));
            }), ze(d, function(m) {
              h[m] !== void 0 || tt(h, m) || (y[m] = !1, Fe(f));
            });
          else if (E === 5) {
            if (n(f) && (Fe(f), y.length = !0), h.length < d.length)
              for (var v = h.length; v < d.length; v++)
                y[v] = !1;
            else
              for (var O = d.length; O < h.length; O++)
                y[O] = !0;
            for (var x = Math.min(h.length, d.length), S = 0; S < x; S++)
              h.hasOwnProperty(S) || (y[S] = !0), y[S] === void 0 && c(h[S]);
          }
        }
      }
    }(s.p[0]), t(s.p));
  }, K: function(s) {
    return s.i === 4 ? r(s) : n(s);
  } });
}
var Dn, nt, Wr = typeof Symbol < "u" && typeof Symbol("x") == "symbol", Gs = typeof Map < "u", Ks = typeof Set < "u", kn = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", Ni = Wr ? Symbol.for("immer-nothing") : ((Dn = {})["immer-nothing"] = !0, Dn), Ln = Wr ? Symbol.for("immer-draftable") : "__$immer_draftable", re = Wr ? Symbol.for("immer-state") : "__$immer_state", Hs = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(e) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(e) {
  return "Cannot apply patch, path doesn't resolve: " + e;
}, 16: 'Sets cannot have "replace" patches.', 17: function(e) {
  return "Unsupported patch operation: " + e;
}, 18: function(e) {
  return "The plugin for '" + e + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + e + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(e) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + e + "'";
}, 22: function(e) {
  return "'current' expects a draft, got: " + e;
}, 23: function(e) {
  return "'original' expects a draft, got: " + e;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, Js = "" + Object.prototype.constructor, rt = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Object.getOwnPropertyNames, Ii = Object.getOwnPropertyDescriptors || function(e) {
  var t = {};
  return rt(e).forEach(function(r) {
    t[r] = Object.getOwnPropertyDescriptor(e, r);
  }), t;
}, Tr = {}, mt = { get: function(e, t) {
  if (t === re)
    return e;
  var r = Le(e);
  if (!tt(r, t))
    return function(i, o, s) {
      var a, u = In(o, s);
      return u ? "value" in u ? u.value : (a = u.get) === null || a === void 0 ? void 0 : a.call(i.k) : void 0;
    }(e, r, t);
  var n = r[t];
  return e.I || !Ie(n) ? n : n === er(e.t, t) ? (tr(e), e.o[t] = wr(e.A.h, n, e)) : n;
}, has: function(e, t) {
  return t in Le(e);
}, ownKeys: function(e) {
  return Reflect.ownKeys(Le(e));
}, set: function(e, t, r) {
  var n = In(Le(e), t);
  if (n != null && n.set)
    return n.set.call(e.k, r), !0;
  if (!e.P) {
    var i = er(Le(e), t), o = i == null ? void 0 : i[re];
    if (o && o.t === r)
      return e.o[t] = r, e.R[t] = !1, !0;
    if (Ai(r, i) && (r !== void 0 || tt(e.t, t)))
      return !0;
    tr(e), Fe(e);
  }
  return e.o[t] === r && (r !== void 0 || t in e.o) || Number.isNaN(r) && Number.isNaN(e.o[t]) || (e.o[t] = r, e.R[t] = !0), !0;
}, deleteProperty: function(e, t) {
  return er(e.t, t) !== void 0 || t in e.t ? (e.R[t] = !1, tr(e), Fe(e)) : delete e.R[t], e.o && delete e.o[t], !0;
}, getOwnPropertyDescriptor: function(e, t) {
  var r = Le(e), n = Reflect.getOwnPropertyDescriptor(r, t);
  return n && { writable: !0, configurable: e.i !== 1 || t !== "length", enumerable: n.enumerable, value: r[t] };
}, defineProperty: function() {
  de(11);
}, getPrototypeOf: function(e) {
  return Object.getPrototypeOf(e.t);
}, setPrototypeOf: function() {
  de(12);
} }, dt = {};
ze(mt, function(e, t) {
  dt[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
}), dt.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && de(13), dt.set.call(this, e, t, void 0);
}, dt.set = function(e, t, r) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && de(14), mt.set.call(this, e[0], t, r, e[0]);
};
var Xs = function() {
  function e(r) {
    var n = this;
    this.O = kn, this.D = !0, this.produce = function(i, o, s) {
      if (typeof i == "function" && typeof o != "function") {
        var a = o;
        o = i;
        var u = n;
        return function(E) {
          var v = this;
          E === void 0 && (E = a);
          for (var O = arguments.length, x = Array(O > 1 ? O - 1 : 0), S = 1; S < O; S++)
            x[S - 1] = arguments[S];
          return u.produce(E, function(m) {
            var b;
            return (b = o).call.apply(b, [v, m].concat(x));
          });
        };
      }
      var c;
      if (typeof o != "function" && de(6), s !== void 0 && typeof s != "function" && de(7), Ie(i)) {
        var l = An(n), f = wr(n, i, void 0), d = !0;
        try {
          c = o(f), d = !1;
        } finally {
          d ? At(l) : Or(l);
        }
        return typeof Promise < "u" && c instanceof Promise ? c.then(function(E) {
          return Xt(l, s), Zt(E, l);
        }, function(E) {
          throw At(l), E;
        }) : (Xt(l, s), Zt(c, l));
      }
      if (!i || typeof i != "object") {
        if ((c = o(i)) === void 0 && (c = i), c === Ni && (c = void 0), n.D && Br(c, !0), s) {
          var h = [], y = [];
          Ce("Patches").M(i, c, h, y), s(h, y);
        }
        return c;
      }
      de(21, i);
    }, this.produceWithPatches = function(i, o) {
      if (typeof i == "function")
        return function(c) {
          for (var l = arguments.length, f = Array(l > 1 ? l - 1 : 0), d = 1; d < l; d++)
            f[d - 1] = arguments[d];
          return n.produceWithPatches(c, function(h) {
            return i.apply(void 0, [h].concat(f));
          });
        };
      var s, a, u = n.produce(i, o, function(c, l) {
        s = c, a = l;
      });
      return typeof Promise < "u" && u instanceof Promise ? u.then(function(c) {
        return [c, s, a];
      }) : [u, s, a];
    }, typeof (r == null ? void 0 : r.useProxies) == "boolean" && this.setUseProxies(r.useProxies), typeof (r == null ? void 0 : r.autoFreeze) == "boolean" && this.setAutoFreeze(r.autoFreeze);
  }
  var t = e.prototype;
  return t.createDraft = function(r) {
    Ie(r) || de(8), Ue(r) && (r = Ys(r));
    var n = An(this), i = wr(this, r, void 0);
    return i[re].C = !0, Or(n), i;
  }, t.finishDraft = function(r, n) {
    var i = r && r[re];
    process.env.NODE_ENV !== "production" && (i && i.C || de(9), i.I && de(10));
    var o = i.A;
    return Xt(o, n), Zt(void 0, o);
  }, t.setAutoFreeze = function(r) {
    this.D = r;
  }, t.setUseProxies = function(r) {
    r && !kn && de(20), this.O = r;
  }, t.applyPatches = function(r, n) {
    var i;
    for (i = n.length - 1; i >= 0; i--) {
      var o = n[i];
      if (o.path.length === 0 && o.op === "replace") {
        r = o.value;
        break;
      }
    }
    i > -1 && (n = n.slice(i + 1));
    var s = Ce("Patches").$;
    return Ue(r) ? s(r, n) : this.produce(r, function(a) {
      return s(a, n);
    });
  }, e;
}(), Ee = new Xs(), Pi = Ee.produce;
Ee.produceWithPatches.bind(Ee);
Ee.setAutoFreeze.bind(Ee);
Ee.setUseProxies.bind(Ee);
Ee.applyPatches.bind(Ee);
Ee.createDraft.bind(Ee);
Ee.finishDraft.bind(Ee);
function gt(e) {
  return gt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, gt(e);
}
function Zs(e, t) {
  if (gt(e) !== "object" || e === null)
    return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (gt(n) !== "object")
      return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ea(e) {
  var t = Zs(e, "string");
  return gt(t) === "symbol" ? t : String(t);
}
function ta(e, t, r) {
  return t = ea(t), t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function Mn(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Fn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Mn(Object(r), !0).forEach(function(n) {
      ta(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Mn(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function ye(e) {
  return "Minified Redux error #" + e + "; visit https://redux.js.org/Errors?code=" + e + " for the full message or use the non-minified dev environment for full errors. ";
}
var jn = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}(), rr = function() {
  return Math.random().toString(36).substring(7).split("").join(".");
}, Ye = {
  INIT: "@@redux/INIT" + rr(),
  REPLACE: "@@redux/REPLACE" + rr(),
  PROBE_UNKNOWN_ACTION: function() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + rr();
  }
};
function Di(e) {
  if (typeof e != "object" || e === null)
    return !1;
  for (var t = e; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function ra(e) {
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  var t = typeof e;
  switch (t) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return t;
  }
  if (Array.isArray(e))
    return "array";
  if (oa(e))
    return "date";
  if (ia(e))
    return "error";
  var r = na(e);
  switch (r) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return r;
  }
  return t.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function na(e) {
  return typeof e.constructor == "function" ? e.constructor.name : null;
}
function ia(e) {
  return e instanceof Error || typeof e.message == "string" && e.constructor && typeof e.constructor.stackTraceLimit == "number";
}
function oa(e) {
  return e instanceof Date ? !0 : typeof e.toDateString == "function" && typeof e.getDate == "function" && typeof e.setDate == "function";
}
function Be(e) {
  var t = typeof e;
  return process.env.NODE_ENV !== "production" && (t = ra(e)), t;
}
function ki(e, t, r) {
  var n;
  if (typeof t == "function" && typeof r == "function" || typeof r == "function" && typeof arguments[3] == "function")
    throw new Error(process.env.NODE_ENV === "production" ? ye(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if (typeof t == "function" && typeof r > "u" && (r = t, t = void 0), typeof r < "u") {
    if (typeof r != "function")
      throw new Error(process.env.NODE_ENV === "production" ? ye(1) : "Expected the enhancer to be a function. Instead, received: '" + Be(r) + "'");
    return r(ki)(e, t);
  }
  if (typeof e != "function")
    throw new Error(process.env.NODE_ENV === "production" ? ye(2) : "Expected the root reducer to be a function. Instead, received: '" + Be(e) + "'");
  var i = e, o = t, s = [], a = s, u = !1;
  function c() {
    a === s && (a = s.slice());
  }
  function l() {
    if (u)
      throw new Error(process.env.NODE_ENV === "production" ? ye(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return o;
  }
  function f(E) {
    if (typeof E != "function")
      throw new Error(process.env.NODE_ENV === "production" ? ye(4) : "Expected the listener to be a function. Instead, received: '" + Be(E) + "'");
    if (u)
      throw new Error(process.env.NODE_ENV === "production" ? ye(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    var v = !0;
    return c(), a.push(E), function() {
      if (v) {
        if (u)
          throw new Error(process.env.NODE_ENV === "production" ? ye(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        v = !1, c();
        var x = a.indexOf(E);
        a.splice(x, 1), s = null;
      }
    };
  }
  function d(E) {
    if (!Di(E))
      throw new Error(process.env.NODE_ENV === "production" ? ye(7) : "Actions must be plain objects. Instead, the actual type was: '" + Be(E) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    if (typeof E.type > "u")
      throw new Error(process.env.NODE_ENV === "production" ? ye(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (u)
      throw new Error(process.env.NODE_ENV === "production" ? ye(9) : "Reducers may not dispatch actions.");
    try {
      u = !0, o = i(o, E);
    } finally {
      u = !1;
    }
    for (var v = s = a, O = 0; O < v.length; O++) {
      var x = v[O];
      x();
    }
    return E;
  }
  function h(E) {
    if (typeof E != "function")
      throw new Error(process.env.NODE_ENV === "production" ? ye(10) : "Expected the nextReducer to be a function. Instead, received: '" + Be(E));
    i = E, d({
      type: Ye.REPLACE
    });
  }
  function y() {
    var E, v = f;
    return E = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function(x) {
        if (typeof x != "object" || x === null)
          throw new Error(process.env.NODE_ENV === "production" ? ye(11) : "Expected the observer to be an object. Instead, received: '" + Be(x) + "'");
        function S() {
          x.next && x.next(l());
        }
        S();
        var m = v(S);
        return {
          unsubscribe: m
        };
      }
    }, E[jn] = function() {
      return this;
    }, E;
  }
  return d({
    type: Ye.INIT
  }), n = {
    dispatch: d,
    subscribe: f,
    getState: l,
    replaceReducer: h
  }, n[jn] = y, n;
}
function qn(e) {
  typeof console < "u" && typeof console.error == "function" && console.error(e);
  try {
    throw new Error(e);
  } catch {
  }
}
function sa(e, t, r, n) {
  var i = Object.keys(t), o = r && r.type === Ye.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (i.length === 0)
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  if (!Di(e))
    return "The " + o + ' has unexpected type of "' + Be(e) + '". Expected argument to be an object with the following ' + ('keys: "' + i.join('", "') + '"');
  var s = Object.keys(e).filter(function(a) {
    return !t.hasOwnProperty(a) && !n[a];
  });
  if (s.forEach(function(a) {
    n[a] = !0;
  }), !(r && r.type === Ye.REPLACE) && s.length > 0)
    return "Unexpected " + (s.length > 1 ? "keys" : "key") + " " + ('"' + s.join('", "') + '" found in ' + o + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + i.join('", "') + '". Unexpected keys will be ignored.');
}
function aa(e) {
  Object.keys(e).forEach(function(t) {
    var r = e[t], n = r(void 0, {
      type: Ye.INIT
    });
    if (typeof n > "u")
      throw new Error(process.env.NODE_ENV === "production" ? ye(12) : 'The slice reducer for key "' + t + `" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    if (typeof r(void 0, {
      type: Ye.PROBE_UNKNOWN_ACTION()
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? ye(13) : 'The slice reducer for key "' + t + '" returned undefined when probed with a random type. ' + ("Don't try to handle '" + Ye.INIT + `' or other actions in "redux/*" `) + "namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.");
  });
}
function ua(e) {
  for (var t = Object.keys(e), r = {}, n = 0; n < t.length; n++) {
    var i = t[n];
    process.env.NODE_ENV !== "production" && typeof e[i] > "u" && qn('No reducer provided for key "' + i + '"'), typeof e[i] == "function" && (r[i] = e[i]);
  }
  var o = Object.keys(r), s;
  process.env.NODE_ENV !== "production" && (s = {});
  var a;
  try {
    aa(r);
  } catch (u) {
    a = u;
  }
  return function(c, l) {
    if (c === void 0 && (c = {}), a)
      throw a;
    if (process.env.NODE_ENV !== "production") {
      var f = sa(c, r, l, s);
      f && qn(f);
    }
    for (var d = !1, h = {}, y = 0; y < o.length; y++) {
      var E = o[y], v = r[E], O = c[E], x = v(O, l);
      if (typeof x > "u") {
        var S = l && l.type;
        throw new Error(process.env.NODE_ENV === "production" ? ye(14) : "When called with an action of type " + (S ? '"' + String(S) + '"' : "(unknown type)") + ', the slice reducer for key "' + E + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.');
      }
      h[E] = x, d = d || x !== O;
    }
    return d = d || o.length !== Object.keys(c).length, d ? h : c;
  };
}
function Pt() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return t.length === 0 ? function(n) {
    return n;
  } : t.length === 1 ? t[0] : t.reduce(function(n, i) {
    return function() {
      return n(i.apply(void 0, arguments));
    };
  });
}
function ca() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return function(n) {
    return function() {
      var i = n.apply(void 0, arguments), o = function() {
        throw new Error(process.env.NODE_ENV === "production" ? ye(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      }, s = {
        getState: i.getState,
        dispatch: function() {
          return o.apply(void 0, arguments);
        }
      }, a = t.map(function(u) {
        return u(s);
      });
      return o = Pt.apply(void 0, a)(i.dispatch), Fn(Fn({}, i), {}, {
        dispatch: o
      });
    };
  };
}
function Li(e) {
  var t = function(n) {
    var i = n.dispatch, o = n.getState;
    return function(s) {
      return function(a) {
        return typeof a == "function" ? a(i, o, e) : s(a);
      };
    };
  };
  return t;
}
var Mi = Li();
Mi.withExtraArgument = Li;
const Un = Mi;
var Fi = globalThis && globalThis.__extends || function() {
  var e = function(t, r) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
      n.__proto__ = i;
    } || function(n, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
    }, e(t, r);
  };
  return function(t, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    e(t, r);
    function n() {
      this.constructor = t;
    }
    t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), la = globalThis && globalThis.__generator || function(e, t) {
  var r = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, n, i, o, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, i && (o = c[0] & 2 ? i.return : c[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, c[1])).done)
          return o;
        switch (i = 0, o && (c = [c[0] & 2, o.value]), c[0]) {
          case 0:
          case 1:
            o = c;
            break;
          case 4:
            return r.label++, { value: c[1], done: !1 };
          case 5:
            r.label++, i = c[1], c = [0];
            continue;
          case 7:
            c = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (o = r.trys, !(o = o.length > 0 && o[o.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              r = 0;
              continue;
            }
            if (c[0] === 3 && (!o || c[1] > o[0] && c[1] < o[3])) {
              r.label = c[1];
              break;
            }
            if (c[0] === 6 && r.label < o[1]) {
              r.label = o[1], o = c;
              break;
            }
            if (o && r.label < o[2]) {
              r.label = o[2], r.ops.push(c);
              break;
            }
            o[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        c = t.call(e, r);
      } catch (l) {
        c = [6, l], i = 0;
      } finally {
        n = o = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, it = globalThis && globalThis.__spreadArray || function(e, t) {
  for (var r = 0, n = t.length, i = e.length; r < n; r++, i++)
    e[i] = t[r];
  return e;
}, fa = Object.defineProperty, da = Object.defineProperties, ha = Object.getOwnPropertyDescriptors, Vn = Object.getOwnPropertySymbols, pa = Object.prototype.hasOwnProperty, ya = Object.prototype.propertyIsEnumerable, $n = function(e, t, r) {
  return t in e ? fa(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
}, je = function(e, t) {
  for (var r in t || (t = {}))
    pa.call(t, r) && $n(e, r, t[r]);
  if (Vn)
    for (var n = 0, i = Vn(t); n < i.length; n++) {
      var r = i[n];
      ya.call(t, r) && $n(e, r, t[r]);
    }
  return e;
}, nr = function(e, t) {
  return da(e, ha(t));
}, va = function(e, t, r) {
  return new Promise(function(n, i) {
    var o = function(u) {
      try {
        a(r.next(u));
      } catch (c) {
        i(c);
      }
    }, s = function(u) {
      try {
        a(r.throw(u));
      } catch (c) {
        i(c);
      }
    }, a = function(u) {
      return u.done ? n(u.value) : Promise.resolve(u.value).then(o, s);
    };
    a((r = r.apply(e, t)).next());
  });
}, ma = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length !== 0)
    return typeof arguments[0] == "object" ? Pt : Pt.apply(null, arguments);
};
function ji(e) {
  if (typeof e != "object" || e === null)
    return !1;
  var t = Object.getPrototypeOf(e);
  if (t === null)
    return !0;
  for (var r = t; Object.getPrototypeOf(r) !== null; )
    r = Object.getPrototypeOf(r);
  return t === r;
}
function qi(e, t) {
  var r = 0;
  return {
    measureTime: function(n) {
      var i = Date.now();
      try {
        return n();
      } finally {
        var o = Date.now();
        r += o - i;
      }
    },
    warnIfExceeded: function() {
      r > e && console.warn(t + " took " + r + "ms, which is more than the warning threshold of " + e + `ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
    }
  };
}
var ga = (
  /** @class */
  function(e) {
    Fi(t, e);
    function t() {
      for (var r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      var i = e.apply(this, r) || this;
      return Object.setPrototypeOf(i, t.prototype), i;
    }
    return Object.defineProperty(t, Symbol.species, {
      get: function() {
        return t;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.concat = function() {
      for (var r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      return e.prototype.concat.apply(this, r);
    }, t.prototype.prepend = function() {
      for (var r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      return r.length === 1 && Array.isArray(r[0]) ? new (t.bind.apply(t, it([void 0], r[0].concat(this))))() : new (t.bind.apply(t, it([void 0], r.concat(this))))();
    }, t;
  }(Array)
), ba = (
  /** @class */
  function(e) {
    Fi(t, e);
    function t() {
      for (var r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      var i = e.apply(this, r) || this;
      return Object.setPrototypeOf(i, t.prototype), i;
    }
    return Object.defineProperty(t, Symbol.species, {
      get: function() {
        return t;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.concat = function() {
      for (var r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      return e.prototype.concat.apply(this, r);
    }, t.prototype.prepend = function() {
      for (var r = [], n = 0; n < arguments.length; n++)
        r[n] = arguments[n];
      return r.length === 1 && Array.isArray(r[0]) ? new (t.bind.apply(t, it([void 0], r[0].concat(this))))() : new (t.bind.apply(t, it([void 0], r.concat(this))))();
    }, t;
  }(Array)
);
function _r(e) {
  return Ie(e) ? Pi(e, function() {
  }) : e;
}
var Ea = process.env.NODE_ENV === "production", Bn = "Invariant failed";
function Qn(e, t) {
  if (!e)
    throw Ea ? new Error(Bn) : new Error(Bn + ": " + (t || ""));
}
function Sa(e, t, r, n) {
  return JSON.stringify(e, Oa(t, n), r);
}
function Oa(e, t) {
  var r = [], n = [];
  return t || (t = function(i, o) {
    return r[0] === o ? "[Circular ~]" : "[Circular ~." + n.slice(0, r.indexOf(o)).join(".") + "]";
  }), function(i, o) {
    if (r.length > 0) {
      var s = r.indexOf(this);
      ~s ? r.splice(s + 1) : r.push(this), ~s ? n.splice(s, 1 / 0, i) : n.push(i), ~r.indexOf(o) && (o = t.call(this, i, o));
    } else
      r.push(o);
    return e == null ? o : e.call(this, i, o);
  };
}
function wa(e) {
  return typeof e != "object" || e == null || Object.isFrozen(e);
}
function Ta(e, t, r) {
  var n = Ui(e, t, r);
  return {
    detectMutations: function() {
      return Vi(e, t, n, r);
    }
  };
}
function Ui(e, t, r, n) {
  t === void 0 && (t = []), n === void 0 && (n = "");
  var i = { value: r };
  if (!e(r)) {
    i.children = {};
    for (var o in r) {
      var s = n ? n + "." + o : o;
      t.length && t.indexOf(s) !== -1 || (i.children[o] = Ui(e, t, r[o], s));
    }
  }
  return i;
}
function Vi(e, t, r, n, i, o) {
  t === void 0 && (t = []), i === void 0 && (i = !1), o === void 0 && (o = "");
  var s = r ? r.value : void 0, a = s === n;
  if (i && !a && !Number.isNaN(n))
    return { wasMutated: !0, path: o };
  if (e(s) || e(n))
    return { wasMutated: !1 };
  var u = {};
  for (var c in r.children)
    u[c] = !0;
  for (var c in n)
    u[c] = !0;
  var l = t.length > 0, f = function(h) {
    var y = o ? o + "." + h : h;
    if (l) {
      var E = t.some(function(O) {
        return O instanceof RegExp ? O.test(y) : y === O;
      });
      if (E)
        return "continue";
    }
    var v = Vi(e, t, r.children[h], n[h], a, y);
    if (v.wasMutated)
      return { value: v };
  };
  for (var c in u) {
    var d = f(c);
    if (typeof d == "object")
      return d.value;
  }
  return { wasMutated: !1 };
}
function _a(e) {
  if (e === void 0 && (e = {}), process.env.NODE_ENV === "production")
    return function() {
      return function(u) {
        return function(c) {
          return u(c);
        };
      };
    };
  var t = e.isImmutable, r = t === void 0 ? wa : t, n = e.ignoredPaths, i = e.warnAfter, o = i === void 0 ? 32 : i, s = e.ignore;
  n = n || s;
  var a = Ta.bind(null, r, n);
  return function(u) {
    var c = u.getState, l = c(), f = a(l), d;
    return function(h) {
      return function(y) {
        var E = qi(o, "ImmutableStateInvariantMiddleware");
        E.measureTime(function() {
          l = c(), d = f.detectMutations(), f = a(l), Qn(!d.wasMutated, "A state mutation was detected between dispatches, in the path '" + (d.path || "") + "'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
        });
        var v = h(y);
        return E.measureTime(function() {
          l = c(), d = f.detectMutations(), f = a(l), d.wasMutated && Qn(!d.wasMutated, "A state mutation was detected inside a dispatch, in the path: " + (d.path || "") + ". Take a look at the reducer(s) handling the action " + Sa(y) + ". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)");
        }), E.warnIfExceeded(), v;
      };
    };
  };
}
function $i(e) {
  var t = typeof e;
  return e == null || t === "string" || t === "boolean" || t === "number" || Array.isArray(e) || ji(e);
}
function xr(e, t, r, n, i, o) {
  t === void 0 && (t = ""), r === void 0 && (r = $i), i === void 0 && (i = []);
  var s;
  if (!r(e))
    return {
      keyPath: t || "<root>",
      value: e
    };
  if (typeof e != "object" || e === null || o != null && o.has(e))
    return !1;
  for (var a = n != null ? n(e) : Object.entries(e), u = i.length > 0, c = function(v, O) {
    var x = t ? t + "." + v : v;
    if (u) {
      var S = i.some(function(m) {
        return m instanceof RegExp ? m.test(x) : x === m;
      });
      if (S)
        return "continue";
    }
    if (!r(O))
      return { value: {
        keyPath: x,
        value: O
      } };
    if (typeof O == "object" && (s = xr(O, x, r, n, i, o), s))
      return { value: s };
  }, l = 0, f = a; l < f.length; l++) {
    var d = f[l], h = d[0], y = d[1], E = c(h, y);
    if (typeof E == "object")
      return E.value;
  }
  return o && Bi(e) && o.add(e), !1;
}
function Bi(e) {
  if (!Object.isFrozen(e))
    return !1;
  for (var t = 0, r = Object.values(e); t < r.length; t++) {
    var n = r[t];
    if (!(typeof n != "object" || n === null) && !Bi(n))
      return !1;
  }
  return !0;
}
function xa(e) {
  if (e === void 0 && (e = {}), process.env.NODE_ENV === "production")
    return function() {
      return function(S) {
        return function(m) {
          return S(m);
        };
      };
    };
  var t = e.isSerializable, r = t === void 0 ? $i : t, n = e.getEntries, i = e.ignoredActions, o = i === void 0 ? [] : i, s = e.ignoredActionPaths, a = s === void 0 ? ["meta.arg", "meta.baseQueryMeta"] : s, u = e.ignoredPaths, c = u === void 0 ? [] : u, l = e.warnAfter, f = l === void 0 ? 32 : l, d = e.ignoreState, h = d === void 0 ? !1 : d, y = e.ignoreActions, E = y === void 0 ? !1 : y, v = e.disableCache, O = v === void 0 ? !1 : v, x = !O && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
  return function(S) {
    return function(m) {
      return function(b) {
        var w = m(b), R = qi(f, "SerializableStateInvariantMiddleware");
        return !E && !(o.length && o.indexOf(b.type) !== -1) && R.measureTime(function() {
          var C = xr(b, "", r, n, a, x);
          if (C) {
            var M = C.keyPath, $ = C.value;
            console.error("A non-serializable value was detected in an action, in the path: `" + M + "`. Value:", $, `
Take a look at the logic that dispatched this action: `, b, `
(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)`, `
(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)`);
          }
        }), h || (R.measureTime(function() {
          var C = S.getState(), M = xr(C, "", r, n, c, x);
          if (M) {
            var $ = M.keyPath, U = M.value;
            console.error("A non-serializable value was detected in the state, in the path: `" + $ + "`. Value:", U, `
Take a look at the reducer(s) handling this action type: ` + b.type + `.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
          }
        }), R.warnIfExceeded()), w;
      };
    };
  };
}
function ir(e) {
  return typeof e == "boolean";
}
function Ca() {
  return function(t) {
    return Ra(t);
  };
}
function Ra(e) {
  e === void 0 && (e = {});
  var t = e.thunk, r = t === void 0 ? !0 : t, n = e.immutableCheck, i = n === void 0 ? !0 : n, o = e.serializableCheck, s = o === void 0 ? !0 : o, a = new ga();
  if (r && (ir(r) ? a.push(Un) : a.push(Un.withExtraArgument(r.extraArgument))), process.env.NODE_ENV !== "production") {
    if (i) {
      var u = {};
      ir(i) || (u = i), a.unshift(_a(u));
    }
    if (s) {
      var c = {};
      ir(s) || (c = s), a.push(xa(c));
    }
  }
  return a;
}
var or = process.env.NODE_ENV === "production";
function Aa(e) {
  var t = Ca(), r = e || {}, n = r.reducer, i = n === void 0 ? void 0 : n, o = r.middleware, s = o === void 0 ? t() : o, a = r.devTools, u = a === void 0 ? !0 : a, c = r.preloadedState, l = c === void 0 ? void 0 : c, f = r.enhancers, d = f === void 0 ? void 0 : f, h;
  if (typeof i == "function")
    h = i;
  else if (ji(i))
    h = ua(i);
  else
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  var y = s;
  if (typeof y == "function" && (y = y(t), !or && !Array.isArray(y)))
    throw new Error("when using a middleware builder function, an array of middleware must be returned");
  if (!or && y.some(function(m) {
    return typeof m != "function";
  }))
    throw new Error("each middleware provided to configureStore must be a function");
  var E = ca.apply(void 0, y), v = Pt;
  u && (v = ma(je({
    trace: !or
  }, typeof u == "object" && u)));
  var O = new ba(E), x = O;
  Array.isArray(d) ? x = it([E], d) : typeof d == "function" && (x = d(O));
  var S = v.apply(void 0, x);
  return ki(h, l, S);
}
function qe(e, t) {
  function r() {
    for (var n = [], i = 0; i < arguments.length; i++)
      n[i] = arguments[i];
    if (t) {
      var o = t.apply(void 0, n);
      if (!o)
        throw new Error("prepareAction did not return an object");
      return je(je({
        type: e,
        payload: o.payload
      }, "meta" in o && { meta: o.meta }), "error" in o && { error: o.error });
    }
    return { type: e, payload: n[0] };
  }
  return r.toString = function() {
    return "" + e;
  }, r.type = e, r.match = function(n) {
    return n.type === e;
  }, r;
}
function Qi(e) {
  var t = {}, r = [], n, i = {
    addCase: function(o, s) {
      if (process.env.NODE_ENV !== "production") {
        if (r.length > 0)
          throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
        if (n)
          throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
      }
      var a = typeof o == "string" ? o : o.type;
      if (a in t)
        throw new Error("addCase cannot be called with two reducers for the same action type");
      return t[a] = s, i;
    },
    addMatcher: function(o, s) {
      if (process.env.NODE_ENV !== "production" && n)
        throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
      return r.push({ matcher: o, reducer: s }), i;
    },
    addDefaultCase: function(o) {
      if (process.env.NODE_ENV !== "production" && n)
        throw new Error("`builder.addDefaultCase` can only be called once");
      return n = o, i;
    }
  };
  return e(i), [t, r, n];
}
function Na(e) {
  return typeof e == "function";
}
var Wn = !1;
function Ia(e, t, r, n) {
  r === void 0 && (r = []), process.env.NODE_ENV !== "production" && typeof t == "object" && (Wn || (Wn = !0, console.warn("The object notation for `createReducer` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer")));
  var i = typeof t == "function" ? Qi(t) : [t, r, n], o = i[0], s = i[1], a = i[2], u;
  if (Na(e))
    u = function() {
      return _r(e());
    };
  else {
    var c = _r(e);
    u = function() {
      return c;
    };
  }
  function l(f, d) {
    f === void 0 && (f = u());
    var h = it([
      o[d.type]
    ], s.filter(function(y) {
      var E = y.matcher;
      return E(d);
    }).map(function(y) {
      var E = y.reducer;
      return E;
    }));
    return h.filter(function(y) {
      return !!y;
    }).length === 0 && (h = [a]), h.reduce(function(y, E) {
      if (E)
        if (Ue(y)) {
          var v = y, O = E(v, d);
          return O === void 0 ? y : O;
        } else {
          if (Ie(y))
            return Pi(y, function(x) {
              return E(x, d);
            });
          var O = E(y, d);
          if (O === void 0) {
            if (y === null)
              return y;
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return O;
        }
      return y;
    }, f);
  }
  return l.getInitialState = u, l;
}
var Yn = !1;
function Pa(e, t) {
  return e + "/" + t;
}
function Da(e) {
  var t = e.name;
  if (!t)
    throw new Error("`name` is a required option for createSlice");
  typeof process < "u" && process.env.NODE_ENV === "development" && e.initialState === void 0 && console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
  var r = typeof e.initialState == "function" ? e.initialState : _r(e.initialState), n = e.reducers || {}, i = Object.keys(n), o = {}, s = {}, a = {};
  i.forEach(function(l) {
    var f = n[l], d = Pa(t, l), h, y;
    "reducer" in f ? (h = f.reducer, y = f.prepare) : h = f, o[l] = h, s[d] = h, a[l] = y ? qe(d, y) : qe(d);
  });
  function u() {
    process.env.NODE_ENV !== "production" && typeof e.extraReducers == "object" && (Yn || (Yn = !0, console.warn("The object notation for `createSlice.extraReducers` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice")));
    var l = typeof e.extraReducers == "function" ? Qi(e.extraReducers) : [e.extraReducers], f = l[0], d = f === void 0 ? {} : f, h = l[1], y = h === void 0 ? [] : h, E = l[2], v = E === void 0 ? void 0 : E, O = je(je({}, d), s);
    return Ia(r, function(x) {
      for (var S in O)
        x.addCase(S, O[S]);
      for (var m = 0, b = y; m < b.length; m++) {
        var w = b[m];
        x.addMatcher(w.matcher, w.reducer);
      }
      v && x.addDefaultCase(v);
    });
  }
  var c;
  return {
    name: t,
    reducer: function(l, f) {
      return c || (c = u()), c(l, f);
    },
    actions: a,
    caseReducers: o,
    getInitialState: function() {
      return c || (c = u()), c.getInitialState();
    }
  };
}
var ka = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", La = function(e) {
  e === void 0 && (e = 21);
  for (var t = "", r = e; r--; )
    t += ka[Math.random() * 64 | 0];
  return t;
}, Ma = [
  "name",
  "message",
  "stack",
  "code"
], sr = (
  /** @class */
  function() {
    function e(t, r) {
      this.payload = t, this.meta = r;
    }
    return e;
  }()
), zn = (
  /** @class */
  function() {
    function e(t, r) {
      this.payload = t, this.meta = r;
    }
    return e;
  }()
), Fa = function(e) {
  if (typeof e == "object" && e !== null) {
    for (var t = {}, r = 0, n = Ma; r < n.length; r++) {
      var i = n[r];
      typeof e[i] == "string" && (t[i] = e[i]);
    }
    return t;
  }
  return { message: String(e) };
};
(function() {
  function e(t, r, n) {
    var i = qe(t + "/fulfilled", function(l, f, d, h) {
      return {
        payload: l,
        meta: nr(je({}, h || {}), {
          arg: d,
          requestId: f,
          requestStatus: "fulfilled"
        })
      };
    }), o = qe(t + "/pending", function(l, f, d) {
      return {
        payload: void 0,
        meta: nr(je({}, d || {}), {
          arg: f,
          requestId: l,
          requestStatus: "pending"
        })
      };
    }), s = qe(t + "/rejected", function(l, f, d, h, y) {
      return {
        payload: h,
        error: (n && n.serializeError || Fa)(l || "Rejected"),
        meta: nr(je({}, y || {}), {
          arg: d,
          requestId: f,
          rejectedWithValue: !!h,
          requestStatus: "rejected",
          aborted: (l == null ? void 0 : l.name) === "AbortError",
          condition: (l == null ? void 0 : l.name) === "ConditionError"
        })
      };
    }), a = !1, u = typeof AbortController < "u" ? AbortController : (
      /** @class */
      function() {
        function l() {
          this.signal = {
            aborted: !1,
            addEventListener: function() {
            },
            dispatchEvent: function() {
              return !1;
            },
            onabort: function() {
            },
            removeEventListener: function() {
            },
            reason: void 0,
            throwIfAborted: function() {
            }
          };
        }
        return l.prototype.abort = function() {
          process.env.NODE_ENV !== "production" && (a || (a = !0, console.info("This platform does not implement AbortController. \nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.")));
        }, l;
      }()
    );
    function c(l) {
      return function(f, d, h) {
        var y = n != null && n.idGenerator ? n.idGenerator(l) : La(), E = new u(), v;
        function O(S) {
          v = S, E.abort();
        }
        var x = function() {
          return va(this, null, function() {
            var S, m, b, w, R, C, M;
            return la(this, function($) {
              switch ($.label) {
                case 0:
                  return $.trys.push([0, 4, , 5]), w = (S = n == null ? void 0 : n.condition) == null ? void 0 : S.call(n, l, { getState: d, extra: h }), qa(w) ? [4, w] : [3, 2];
                case 1:
                  w = $.sent(), $.label = 2;
                case 2:
                  if (w === !1 || E.signal.aborted)
                    throw {
                      name: "ConditionError",
                      message: "Aborted due to condition callback returning false."
                    };
                  return R = new Promise(function(U, z) {
                    return E.signal.addEventListener("abort", function() {
                      return z({
                        name: "AbortError",
                        message: v || "Aborted"
                      });
                    });
                  }), f(o(y, l, (m = n == null ? void 0 : n.getPendingMeta) == null ? void 0 : m.call(n, { requestId: y, arg: l }, { getState: d, extra: h }))), [4, Promise.race([
                    R,
                    Promise.resolve(r(l, {
                      dispatch: f,
                      getState: d,
                      extra: h,
                      requestId: y,
                      signal: E.signal,
                      abort: O,
                      rejectWithValue: function(U, z) {
                        return new sr(U, z);
                      },
                      fulfillWithValue: function(U, z) {
                        return new zn(U, z);
                      }
                    })).then(function(U) {
                      if (U instanceof sr)
                        throw U;
                      return U instanceof zn ? i(U.payload, y, l, U.meta) : i(U, y, l);
                    })
                  ])];
                case 3:
                  return b = $.sent(), [3, 5];
                case 4:
                  return C = $.sent(), b = C instanceof sr ? s(null, y, l, C.payload, C.meta) : s(C, y, l), [3, 5];
                case 5:
                  return M = n && !n.dispatchConditionRejection && s.match(b) && b.meta.condition, M || f(b), [2, b];
              }
            });
          });
        }();
        return Object.assign(x, {
          abort: O,
          requestId: y,
          arg: l,
          unwrap: function() {
            return x.then(ja);
          }
        });
      };
    }
    return Object.assign(c, {
      pending: o,
      rejected: s,
      fulfilled: i,
      typePrefix: t
    });
  }
  return e.withTypes = function() {
    return e;
  }, e;
})();
function ja(e) {
  if (e.meta && e.meta.rejectedWithValue)
    throw e.payload;
  if (e.error)
    throw e.error;
  return e.payload;
}
function qa(e) {
  return e !== null && typeof e == "object" && typeof e.then == "function";
}
var Yr = "listenerMiddleware";
qe(Yr + "/add");
qe(Yr + "/removeAll");
qe(Yr + "/remove");
var Gn;
typeof queueMicrotask == "function" && queueMicrotask.bind(typeof window < "u" ? window : typeof global < "u" ? global : globalThis);
zs();
const Ua = {
  graphqlUrl: "",
  websocketUrl: "",
  workspaceId: "",
  accessToken: "",
  refreshToken: "",
  accessTokenExpiry: null,
  refreshTokenExpiry: null,
  activeConversationId: null,
  context: null,
  defaultAgent: null,
  isWidgetWindowVisible: !1,
  isConversationListVisible: !0,
  styling: null,
  userData: void 0,
  data: null,
  embedActiveConversationId: {},
  isEmbedConversationListVisible: {},
  embedData: {},
  embedDefaultAgent: {},
  createdFirstConversation: !1
}, Wi = Da({
  name: "conversation",
  initialState: Ua,
  reducers: {
    setGraphqlUrl(e, t) {
      e.graphqlUrl = t.payload;
    },
    setWebsocketlUrl(e, t) {
      e.websocketUrl = t.payload;
    },
    setWorkspaceId(e, t) {
      e.workspaceId = t.payload;
    },
    setAccessToken(e, t) {
      e.accessToken = t.payload;
    },
    setRefreshToken(e, t) {
      e.refreshToken = t.payload;
    },
    setAccessTokenExpiry(e, t) {
      e.accessTokenExpiry = t.payload;
    },
    setRefreshTokenExpiry(e, t) {
      e.refreshTokenExpiry = t.payload;
    },
    setConversationId(e, t) {
      e.activeConversationId = t.payload;
    },
    setContext(e, t) {
      e.context = t.payload;
    },
    setShowWidgetWindow(e, t) {
      e.isWidgetWindowVisible = t.payload;
    },
    setIsConversationListVisible(e, t) {
      e.isConversationListVisible = t.payload;
    },
    setDefaultAgent(e, t) {
      e.defaultAgent = t.payload;
    },
    setStyling(e, t) {
      e.styling = t.payload;
    },
    setUserData(e, t) {
      e.userData = t.payload;
    },
    setData(e, t) {
      e.data = t.payload;
    },
    setEmbedConversationId(e, t) {
      const { embedId: r, value: n } = t.payload;
      e.embedActiveConversationId[r] = n;
    },
    setIsEmbedConversationListVisible(e, t) {
      const { embedId: r, value: n } = t.payload;
      e.isEmbedConversationListVisible[r] = n;
    },
    setEmbedData(e, t) {
      const { embedId: r, value: n } = t.payload;
      e.embedData[r] = n;
    },
    setEmbedDefaultAgent(e, t) {
      const { embedId: r, value: n } = t.payload;
      e.embedDefaultAgent[r] = n;
    },
    setCreatedFirstConversation(e, t) {
      e.createdFirstConversation = t.payload;
    }
  }
}), {
  setGraphqlUrl: $c,
  setWebsocketlUrl: Bc,
  setWorkspaceId: Qc,
  setAccessToken: Kn,
  setRefreshToken: Va,
  setAccessTokenExpiry: Hn,
  setRefreshTokenExpiry: $a,
  setConversationId: Ba,
  setContext: Qa,
  setShowWidgetWindow: ar,
  setIsConversationListVisible: ur,
  setDefaultAgent: Wc,
  setStyling: Yc,
  setUserData: zc,
  setData: cr,
  setEmbedConversationId: Wa,
  setIsEmbedConversationListVisible: lr,
  setEmbedData: fr,
  setEmbedDefaultAgent: Gc,
  setCreatedFirstConversation: Jn
} = Wi.actions, Ya = Wi.reducer, ae = Aa({
  reducer: {
    conversation: Ya
  }
});
class st {
  constructor() {
    this.listeners = [], this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.push(t), this.onSubscribe(), () => {
      this.listeners = this.listeners.filter((r) => r !== t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.length > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}
const bt = typeof window > "u" || "Deno" in window;
function Oe() {
}
function za(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Cr(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function Yi(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function ht(e, t, r) {
  return St(e) ? typeof t == "function" ? {
    ...r,
    queryKey: e,
    queryFn: t
  } : {
    ...t,
    queryKey: e
  } : e;
}
function Ga(e, t, r) {
  return St(e) ? typeof t == "function" ? {
    ...r,
    mutationKey: e,
    mutationFn: t
  } : {
    ...t,
    mutationKey: e
  } : typeof e == "function" ? {
    ...t,
    mutationFn: e
  } : {
    ...e
  };
}
function Me(e, t, r) {
  return St(e) ? [{
    ...t,
    queryKey: e
  }, r] : [e || {}, t];
}
function Xn(e, t) {
  const {
    type: r = "all",
    exact: n,
    fetchStatus: i,
    predicate: o,
    queryKey: s,
    stale: a
  } = e;
  if (St(s)) {
    if (n) {
      if (t.queryHash !== zr(s, t.options))
        return !1;
    } else if (!Ze(t.queryKey, s))
      return !1;
  }
  if (r !== "all") {
    const u = t.isActive();
    if (r === "active" && !u || r === "inactive" && u)
      return !1;
  }
  return !(typeof a == "boolean" && t.isStale() !== a || typeof i < "u" && i !== t.state.fetchStatus || o && !o(t));
}
function Zn(e, t) {
  const {
    exact: r,
    fetching: n,
    predicate: i,
    mutationKey: o
  } = e;
  if (St(o)) {
    if (!t.options.mutationKey)
      return !1;
    if (r) {
      if (We(t.options.mutationKey) !== We(o))
        return !1;
    } else if (!Ze(t.options.mutationKey, o))
      return !1;
  }
  return !(typeof n == "boolean" && t.state.status === "loading" !== n || i && !i(t));
}
function zr(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || We)(e);
}
function We(e) {
  return JSON.stringify(e, (t, r) => Ar(r) ? Object.keys(r).sort().reduce((n, i) => (n[i] = r[i], n), {}) : r);
}
function Ze(e, t) {
  return zi(e, t);
}
function zi(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some((r) => !zi(e[r], t[r])) : !1;
}
function Gi(e, t) {
  if (e === t)
    return e;
  const r = ei(e) && ei(t);
  if (r || Ar(e) && Ar(t)) {
    const n = r ? e.length : Object.keys(e).length, i = r ? t : Object.keys(t), o = i.length, s = r ? [] : {};
    let a = 0;
    for (let u = 0; u < o; u++) {
      const c = r ? u : i[u];
      s[c] = Gi(e[c], t[c]), s[c] === e[c] && a++;
    }
    return n === o && a === n ? e : s;
  }
  return t;
}
function Rr(e, t) {
  if (e && !t || t && !e)
    return !1;
  for (const r in e)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function ei(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function Ar(e) {
  if (!ti(e))
    return !1;
  const t = e.constructor;
  if (typeof t > "u")
    return !0;
  const r = t.prototype;
  return !(!ti(r) || !r.hasOwnProperty("isPrototypeOf"));
}
function ti(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function St(e) {
  return Array.isArray(e);
}
function Ki(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function ri(e) {
  Ki(0).then(e);
}
function Ka() {
  if (typeof AbortController == "function")
    return new AbortController();
}
function Nr(e, t, r) {
  return r.isDataEqual != null && r.isDataEqual(e, t) ? e : typeof r.structuralSharing == "function" ? r.structuralSharing(e, t) : r.structuralSharing !== !1 ? Gi(e, t) : t;
}
class Ha extends st {
  constructor() {
    super(), this.setup = (t) => {
      if (!bt && window.addEventListener) {
        const r = () => t();
        return window.addEventListener("visibilitychange", r, !1), window.addEventListener("focus", r, !1), () => {
          window.removeEventListener("visibilitychange", r), window.removeEventListener("focus", r);
        };
      }
    };
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var t;
      (t = this.cleanup) == null || t.call(this), this.cleanup = void 0;
    }
  }
  setEventListener(t) {
    var r;
    this.setup = t, (r = this.cleanup) == null || r.call(this), this.cleanup = t((n) => {
      typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
    });
  }
  setFocused(t) {
    this.focused = t, t && this.onFocus();
  }
  onFocus() {
    this.listeners.forEach((t) => {
      t();
    });
  }
  isFocused() {
    return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? !0 : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
}
const Dt = new Ha();
class Ja extends st {
  constructor() {
    super(), this.setup = (t) => {
      if (!bt && window.addEventListener) {
        const r = () => t();
        return window.addEventListener("online", r, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", r), window.removeEventListener("offline", r);
        };
      }
    };
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var t;
      (t = this.cleanup) == null || t.call(this), this.cleanup = void 0;
    }
  }
  setEventListener(t) {
    var r;
    this.setup = t, (r = this.cleanup) == null || r.call(this), this.cleanup = t((n) => {
      typeof n == "boolean" ? this.setOnline(n) : this.onOnline();
    });
  }
  setOnline(t) {
    this.online = t, t && this.onOnline();
  }
  onOnline() {
    this.listeners.forEach((t) => {
      t();
    });
  }
  isOnline() {
    return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? !0 : navigator.onLine;
  }
}
const kt = new Ja();
function Xa(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function Ft(e) {
  return (e ?? "online") === "online" ? kt.isOnline() : !0;
}
class Hi {
  constructor(t) {
    this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
}
function _t(e) {
  return e instanceof Hi;
}
function Ji(e) {
  let t = !1, r = 0, n = !1, i, o, s;
  const a = new Promise((v, O) => {
    o = v, s = O;
  }), u = (v) => {
    n || (h(new Hi(v)), e.abort == null || e.abort());
  }, c = () => {
    t = !0;
  }, l = () => {
    t = !1;
  }, f = () => !Dt.isFocused() || e.networkMode !== "always" && !kt.isOnline(), d = (v) => {
    n || (n = !0, e.onSuccess == null || e.onSuccess(v), i == null || i(), o(v));
  }, h = (v) => {
    n || (n = !0, e.onError == null || e.onError(v), i == null || i(), s(v));
  }, y = () => new Promise((v) => {
    i = (O) => {
      const x = n || !f();
      return x && v(O), x;
    }, e.onPause == null || e.onPause();
  }).then(() => {
    i = void 0, n || e.onContinue == null || e.onContinue();
  }), E = () => {
    if (n)
      return;
    let v;
    try {
      v = e.fn();
    } catch (O) {
      v = Promise.reject(O);
    }
    Promise.resolve(v).then(d).catch((O) => {
      var x, S;
      if (n)
        return;
      const m = (x = e.retry) != null ? x : 3, b = (S = e.retryDelay) != null ? S : Xa, w = typeof b == "function" ? b(r, O) : b, R = m === !0 || typeof m == "number" && r < m || typeof m == "function" && m(r, O);
      if (t || !R) {
        h(O);
        return;
      }
      r++, e.onFail == null || e.onFail(r, O), Ki(w).then(() => {
        if (f())
          return y();
      }).then(() => {
        t ? h(O) : E();
      });
    });
  };
  return Ft(e.networkMode) ? E() : y().then(E), {
    promise: a,
    cancel: u,
    continue: () => (i == null ? void 0 : i()) ? a : Promise.resolve(),
    cancelRetry: c,
    continueRetry: l
  };
}
const Gr = console;
function Za() {
  let e = [], t = 0, r = (l) => {
    l();
  }, n = (l) => {
    l();
  };
  const i = (l) => {
    let f;
    t++;
    try {
      f = l();
    } finally {
      t--, t || a();
    }
    return f;
  }, o = (l) => {
    t ? e.push(l) : ri(() => {
      r(l);
    });
  }, s = (l) => (...f) => {
    o(() => {
      l(...f);
    });
  }, a = () => {
    const l = e;
    e = [], l.length && ri(() => {
      n(() => {
        l.forEach((f) => {
          r(f);
        });
      });
    });
  };
  return {
    batch: i,
    batchCalls: s,
    schedule: o,
    setNotifyFunction: (l) => {
      r = l;
    },
    setBatchNotifyFunction: (l) => {
      n = l;
    }
  };
}
const ie = Za();
class Xi {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Cr(this.cacheTime) && (this.gcTimeout = setTimeout(() => {
      this.optionalRemove();
    }, this.cacheTime));
  }
  updateCacheTime(t) {
    this.cacheTime = Math.max(this.cacheTime || 0, t ?? (bt ? 1 / 0 : 5 * 60 * 1e3));
  }
  clearGcTimeout() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);
  }
}
class eu extends Xi {
  constructor(t) {
    super(), this.abortSignalConsumed = !1, this.defaultOptions = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.cache = t.cache, this.logger = t.logger || Gr, this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.initialState = t.state || tu(this.options), this.state = this.initialState, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(t) {
    this.options = {
      ...this.defaultOptions,
      ...t
    }, this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.cache.remove(this);
  }
  setData(t, r) {
    const n = Nr(this.state.data, t, this.options);
    return this.dispatch({
      data: n,
      type: "success",
      dataUpdatedAt: r == null ? void 0 : r.updatedAt,
      manual: r == null ? void 0 : r.manual
    }), n;
  }
  setState(t, r) {
    this.dispatch({
      type: "setState",
      state: t,
      setStateOptions: r
    });
  }
  cancel(t) {
    var r;
    const n = this.promise;
    return (r = this.retryer) == null || r.cancel(t), n ? n.then(Oe).catch(Oe) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({
      silent: !0
    });
  }
  reset() {
    this.destroy(), this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((t) => t.options.enabled !== !1);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((t) => t.getCurrentResult().isStale);
  }
  isStaleByTime(t = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !Yi(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    var t;
    const r = this.observers.find((n) => n.shouldFetchOnWindowFocus());
    r && r.refetch({
      cancelRefetch: !1
    }), (t = this.retryer) == null || t.continue();
  }
  onOnline() {
    var t;
    const r = this.observers.find((n) => n.shouldFetchOnReconnect());
    r && r.refetch({
      cancelRefetch: !1
    }), (t = this.retryer) == null || t.continue();
  }
  addObserver(t) {
    this.observers.indexOf(t) === -1 && (this.observers.push(t), this.clearGcTimeout(), this.cache.notify({
      type: "observerAdded",
      query: this,
      observer: t
    }));
  }
  removeObserver(t) {
    this.observers.indexOf(t) !== -1 && (this.observers = this.observers.filter((r) => r !== t), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({
      revert: !0
    }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({
      type: "observerRemoved",
      query: this,
      observer: t
    }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.dispatch({
      type: "invalidate"
    });
  }
  fetch(t, r) {
    var n, i;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && r != null && r.cancelRefetch)
        this.cancel({
          silent: !0
        });
      else if (this.promise) {
        var o;
        return (o = this.retryer) == null || o.continueRetry(), this.promise;
      }
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const h = this.observers.find((y) => y.options.queryFn);
      h && this.setOptions(h.options);
    }
    Array.isArray(this.options.queryKey) || process.env.NODE_ENV !== "production" && this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");
    const s = Ka(), a = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    }, u = (h) => {
      Object.defineProperty(h, "signal", {
        enumerable: !0,
        get: () => {
          if (s)
            return this.abortSignalConsumed = !0, s.signal;
        }
      });
    };
    u(a);
    const c = () => this.options.queryFn ? (this.abortSignalConsumed = !1, this.options.queryFn(a)) : Promise.reject("Missing queryFn"), l = {
      fetchOptions: r,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: c
    };
    if (u(l), (n = this.options.behavior) == null || n.onFetch(l), this.revertState = this.state, this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((i = l.fetchOptions) == null ? void 0 : i.meta)) {
      var f;
      this.dispatch({
        type: "fetch",
        meta: (f = l.fetchOptions) == null ? void 0 : f.meta
      });
    }
    const d = (h) => {
      if (_t(h) && h.silent || this.dispatch({
        type: "error",
        error: h
      }), !_t(h)) {
        var y, E, v, O;
        (y = (E = this.cache.config).onError) == null || y.call(E, h, this), (v = (O = this.cache.config).onSettled) == null || v.call(O, this.state.data, h, this), process.env.NODE_ENV !== "production" && this.logger.error(h);
      }
      this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
    };
    return this.retryer = Ji({
      fn: l.fetchFn,
      abort: s == null ? void 0 : s.abort.bind(s),
      onSuccess: (h) => {
        var y, E, v, O;
        if (typeof h > "u") {
          process.env.NODE_ENV !== "production" && this.logger.error("Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: " + this.queryHash), d(new Error(this.queryHash + " data is undefined"));
          return;
        }
        this.setData(h), (y = (E = this.cache.config).onSuccess) == null || y.call(E, h, this), (v = (O = this.cache.config).onSettled) == null || v.call(O, h, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
      },
      onError: d,
      onFail: (h, y) => {
        this.dispatch({
          type: "failed",
          failureCount: h,
          error: y
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: l.options.retry,
      retryDelay: l.options.retryDelay,
      networkMode: l.options.networkMode
    }), this.promise = this.retryer.promise, this.promise;
  }
  dispatch(t) {
    const r = (n) => {
      var i, o;
      switch (t.type) {
        case "failed":
          return {
            ...n,
            fetchFailureCount: t.failureCount,
            fetchFailureReason: t.error
          };
        case "pause":
          return {
            ...n,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...n,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...n,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (i = t.meta) != null ? i : null,
            fetchStatus: Ft(this.options.networkMode) ? "fetching" : "paused",
            ...!n.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...n,
            data: t.data,
            dataUpdateCount: n.dataUpdateCount + 1,
            dataUpdatedAt: (o = t.dataUpdatedAt) != null ? o : Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...!t.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const s = t.error;
          return _t(s) && s.revert && this.revertState ? {
            ...this.revertState
          } : {
            ...n,
            error: s,
            errorUpdateCount: n.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: n.fetchFailureCount + 1,
            fetchFailureReason: s,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...n,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...n,
            ...t.state
          };
      }
    };
    this.state = r(this.state), ie.batch(() => {
      this.observers.forEach((n) => {
        n.onQueryUpdate(t);
      }), this.cache.notify({
        query: this,
        type: "updated",
        action: t
      });
    });
  }
}
function tu(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, r = typeof t < "u", n = r ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? n ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "loading",
    fetchStatus: "idle"
  };
}
class ru extends st {
  constructor(t) {
    super(), this.config = t || {}, this.queries = [], this.queriesMap = {};
  }
  build(t, r, n) {
    var i;
    const o = r.queryKey, s = (i = r.queryHash) != null ? i : zr(o, r);
    let a = this.get(s);
    return a || (a = new eu({
      cache: this,
      logger: t.getLogger(),
      queryKey: o,
      queryHash: s,
      options: t.defaultQueryOptions(r),
      state: n,
      defaultOptions: t.getQueryDefaults(o)
    }), this.add(a)), a;
  }
  add(t) {
    this.queriesMap[t.queryHash] || (this.queriesMap[t.queryHash] = t, this.queries.push(t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const r = this.queriesMap[t.queryHash];
    r && (t.destroy(), this.queries = this.queries.filter((n) => n !== t), r === t && delete this.queriesMap[t.queryHash], this.notify({
      type: "removed",
      query: t
    }));
  }
  clear() {
    ie.batch(() => {
      this.queries.forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return this.queriesMap[t];
  }
  getAll() {
    return this.queries;
  }
  find(t, r) {
    const [n] = Me(t, r);
    return typeof n.exact > "u" && (n.exact = !0), this.queries.find((i) => Xn(n, i));
  }
  findAll(t, r) {
    const [n] = Me(t, r);
    return Object.keys(n).length > 0 ? this.queries.filter((i) => Xn(n, i)) : this.queries;
  }
  notify(t) {
    ie.batch(() => {
      this.listeners.forEach((r) => {
        r(t);
      });
    });
  }
  onFocus() {
    ie.batch(() => {
      this.queries.forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    ie.batch(() => {
      this.queries.forEach((t) => {
        t.onOnline();
      });
    });
  }
}
class nu extends Xi {
  constructor(t) {
    super(), this.defaultOptions = t.defaultOptions, this.mutationId = t.mutationId, this.mutationCache = t.mutationCache, this.logger = t.logger || Gr, this.observers = [], this.state = t.state || Zi(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = {
      ...this.defaultOptions,
      ...t
    }, this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(t) {
    this.dispatch({
      type: "setState",
      state: t
    });
  }
  addObserver(t) {
    this.observers.indexOf(t) === -1 && (this.observers.push(t), this.clearGcTimeout(), this.mutationCache.notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    this.observers = this.observers.filter((r) => r !== t), this.scheduleGc(), this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    this.observers.length || (this.state.status === "loading" ? this.scheduleGc() : this.mutationCache.remove(this));
  }
  continue() {
    var t, r;
    return (t = (r = this.retryer) == null ? void 0 : r.continue()) != null ? t : this.execute();
  }
  async execute() {
    const t = () => {
      var R;
      return this.retryer = Ji({
        fn: () => this.options.mutationFn ? this.options.mutationFn(this.state.variables) : Promise.reject("No mutationFn found"),
        onFail: (C, M) => {
          this.dispatch({
            type: "failed",
            failureCount: C,
            error: M
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (R = this.options.retry) != null ? R : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      }), this.retryer.promise;
    }, r = this.state.status === "loading";
    try {
      var n, i, o, s, a, u, c, l;
      if (!r) {
        var f, d, h, y;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        }), await ((f = (d = this.mutationCache.config).onMutate) == null ? void 0 : f.call(d, this.state.variables, this));
        const C = await ((h = (y = this.options).onMutate) == null ? void 0 : h.call(y, this.state.variables));
        C !== this.state.context && this.dispatch({
          type: "loading",
          context: C,
          variables: this.state.variables
        });
      }
      const R = await t();
      return await ((n = (i = this.mutationCache.config).onSuccess) == null ? void 0 : n.call(i, R, this.state.variables, this.state.context, this)), await ((o = (s = this.options).onSuccess) == null ? void 0 : o.call(s, R, this.state.variables, this.state.context)), await ((a = (u = this.mutationCache.config).onSettled) == null ? void 0 : a.call(u, R, null, this.state.variables, this.state.context, this)), await ((c = (l = this.options).onSettled) == null ? void 0 : c.call(l, R, null, this.state.variables, this.state.context)), this.dispatch({
        type: "success",
        data: R
      }), R;
    } catch (R) {
      try {
        var E, v, O, x, S, m, b, w;
        throw await ((E = (v = this.mutationCache.config).onError) == null ? void 0 : E.call(v, R, this.state.variables, this.state.context, this)), process.env.NODE_ENV !== "production" && this.logger.error(R), await ((O = (x = this.options).onError) == null ? void 0 : O.call(x, R, this.state.variables, this.state.context)), await ((S = (m = this.mutationCache.config).onSettled) == null ? void 0 : S.call(m, void 0, R, this.state.variables, this.state.context, this)), await ((b = (w = this.options).onSettled) == null ? void 0 : b.call(w, void 0, R, this.state.variables, this.state.context)), R;
      } finally {
        this.dispatch({
          type: "error",
          error: R
        });
      }
    }
  }
  dispatch(t) {
    const r = (n) => {
      switch (t.type) {
        case "failed":
          return {
            ...n,
            failureCount: t.failureCount,
            failureReason: t.error
          };
        case "pause":
          return {
            ...n,
            isPaused: !0
          };
        case "continue":
          return {
            ...n,
            isPaused: !1
          };
        case "loading":
          return {
            ...n,
            context: t.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !Ft(this.options.networkMode),
            status: "loading",
            variables: t.variables
          };
        case "success":
          return {
            ...n,
            data: t.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1
          };
        case "error":
          return {
            ...n,
            data: void 0,
            error: t.error,
            failureCount: n.failureCount + 1,
            failureReason: t.error,
            isPaused: !1,
            status: "error"
          };
        case "setState":
          return {
            ...n,
            ...t.state
          };
      }
    };
    this.state = r(this.state), ie.batch(() => {
      this.observers.forEach((n) => {
        n.onMutationUpdate(t);
      }), this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action: t
      });
    });
  }
}
function Zi() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0
  };
}
class iu extends st {
  constructor(t) {
    super(), this.config = t || {}, this.mutations = [], this.mutationId = 0;
  }
  build(t, r, n) {
    const i = new nu({
      mutationCache: this,
      logger: t.getLogger(),
      mutationId: ++this.mutationId,
      options: t.defaultMutationOptions(r),
      state: n,
      defaultOptions: r.mutationKey ? t.getMutationDefaults(r.mutationKey) : void 0
    });
    return this.add(i), i;
  }
  add(t) {
    this.mutations.push(t), this.notify({
      type: "added",
      mutation: t
    });
  }
  remove(t) {
    this.mutations = this.mutations.filter((r) => r !== t), this.notify({
      type: "removed",
      mutation: t
    });
  }
  clear() {
    ie.batch(() => {
      this.mutations.forEach((t) => {
        this.remove(t);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(t) {
    return typeof t.exact > "u" && (t.exact = !0), this.mutations.find((r) => Zn(t, r));
  }
  findAll(t) {
    return this.mutations.filter((r) => Zn(t, r));
  }
  notify(t) {
    ie.batch(() => {
      this.listeners.forEach((r) => {
        r(t);
      });
    });
  }
  resumePausedMutations() {
    var t;
    return this.resuming = ((t = this.resuming) != null ? t : Promise.resolve()).then(() => {
      const r = this.mutations.filter((n) => n.state.isPaused);
      return ie.batch(() => r.reduce((n, i) => n.then(() => i.continue().catch(Oe)), Promise.resolve()));
    }).then(() => {
      this.resuming = void 0;
    }), this.resuming;
  }
}
function ou() {
  return {
    onFetch: (e) => {
      e.fetchFn = () => {
        var t, r, n, i, o, s;
        const a = (t = e.fetchOptions) == null || (r = t.meta) == null ? void 0 : r.refetchPage, u = (n = e.fetchOptions) == null || (i = n.meta) == null ? void 0 : i.fetchMore, c = u == null ? void 0 : u.pageParam, l = (u == null ? void 0 : u.direction) === "forward", f = (u == null ? void 0 : u.direction) === "backward", d = ((o = e.state.data) == null ? void 0 : o.pages) || [], h = ((s = e.state.data) == null ? void 0 : s.pageParams) || [];
        let y = h, E = !1;
        const v = (w) => {
          Object.defineProperty(w, "signal", {
            enumerable: !0,
            get: () => {
              var R;
              if ((R = e.signal) != null && R.aborted)
                E = !0;
              else {
                var C;
                (C = e.signal) == null || C.addEventListener("abort", () => {
                  E = !0;
                });
              }
              return e.signal;
            }
          });
        }, O = e.options.queryFn || (() => Promise.reject("Missing queryFn")), x = (w, R, C, M) => (y = M ? [R, ...y] : [...y, R], M ? [C, ...w] : [...w, C]), S = (w, R, C, M) => {
          if (E)
            return Promise.reject("Cancelled");
          if (typeof C > "u" && !R && w.length)
            return Promise.resolve(w);
          const $ = {
            queryKey: e.queryKey,
            pageParam: C,
            meta: e.options.meta
          };
          v($);
          const U = O($);
          return Promise.resolve(U).then((te) => x(w, C, te, M));
        };
        let m;
        if (!d.length)
          m = S([]);
        else if (l) {
          const w = typeof c < "u", R = w ? c : ni(e.options, d);
          m = S(d, w, R);
        } else if (f) {
          const w = typeof c < "u", R = w ? c : su(e.options, d);
          m = S(d, w, R, !0);
        } else {
          y = [];
          const w = typeof e.options.getNextPageParam > "u";
          m = (a && d[0] ? a(d[0], 0, d) : !0) ? S([], w, h[0]) : Promise.resolve(x([], h[0], d[0]));
          for (let C = 1; C < d.length; C++)
            m = m.then((M) => {
              if (a && d[C] ? a(d[C], C, d) : !0) {
                const U = w ? h[C] : ni(e.options, M);
                return S(M, w, U);
              }
              return Promise.resolve(x(M, h[C], d[C]));
            });
        }
        return m.then((w) => ({
          pages: w,
          pageParams: y
        }));
      };
    }
  };
}
function ni(e, t) {
  return e.getNextPageParam == null ? void 0 : e.getNextPageParam(t[t.length - 1], t);
}
function su(e, t) {
  return e.getPreviousPageParam == null ? void 0 : e.getPreviousPageParam(t[0], t);
}
class au {
  constructor(t = {}) {
    this.queryCache = t.queryCache || new ru(), this.mutationCache = t.mutationCache || new iu(), this.logger = t.logger || Gr, this.defaultOptions = t.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [], this.mountCount = 0, process.env.NODE_ENV !== "production" && t.logger && this.logger.error("Passing a custom logger has been deprecated and will be removed in the next major version.");
  }
  mount() {
    this.mountCount++, this.mountCount === 1 && (this.unsubscribeFocus = Dt.subscribe(() => {
      Dt.isFocused() && (this.resumePausedMutations(), this.queryCache.onFocus());
    }), this.unsubscribeOnline = kt.subscribe(() => {
      kt.isOnline() && (this.resumePausedMutations(), this.queryCache.onOnline());
    }));
  }
  unmount() {
    var t, r;
    this.mountCount--, this.mountCount === 0 && ((t = this.unsubscribeFocus) == null || t.call(this), this.unsubscribeFocus = void 0, (r = this.unsubscribeOnline) == null || r.call(this), this.unsubscribeOnline = void 0);
  }
  isFetching(t, r) {
    const [n] = Me(t, r);
    return n.fetchStatus = "fetching", this.queryCache.findAll(n).length;
  }
  isMutating(t) {
    return this.mutationCache.findAll({
      ...t,
      fetching: !0
    }).length;
  }
  getQueryData(t, r) {
    var n;
    return (n = this.queryCache.find(t, r)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(t, r, n) {
    const i = ht(t, r, n), o = this.getQueryData(i.queryKey);
    return o ? Promise.resolve(o) : this.fetchQuery(i);
  }
  getQueriesData(t) {
    return this.getQueryCache().findAll(t).map(({
      queryKey: r,
      state: n
    }) => {
      const i = n.data;
      return [r, i];
    });
  }
  setQueryData(t, r, n) {
    const i = this.queryCache.find(t), o = i == null ? void 0 : i.state.data, s = za(r, o);
    if (typeof s > "u")
      return;
    const a = ht(t), u = this.defaultQueryOptions(a);
    return this.queryCache.build(this, u).setData(s, {
      ...n,
      manual: !0
    });
  }
  setQueriesData(t, r, n) {
    return ie.batch(() => this.getQueryCache().findAll(t).map(({
      queryKey: i
    }) => [i, this.setQueryData(i, r, n)]));
  }
  getQueryState(t, r) {
    var n;
    return (n = this.queryCache.find(t, r)) == null ? void 0 : n.state;
  }
  removeQueries(t, r) {
    const [n] = Me(t, r), i = this.queryCache;
    ie.batch(() => {
      i.findAll(n).forEach((o) => {
        i.remove(o);
      });
    });
  }
  resetQueries(t, r, n) {
    const [i, o] = Me(t, r, n), s = this.queryCache, a = {
      type: "active",
      ...i
    };
    return ie.batch(() => (s.findAll(i).forEach((u) => {
      u.reset();
    }), this.refetchQueries(a, o)));
  }
  cancelQueries(t, r, n) {
    const [i, o = {}] = Me(t, r, n);
    typeof o.revert > "u" && (o.revert = !0);
    const s = ie.batch(() => this.queryCache.findAll(i).map((a) => a.cancel(o)));
    return Promise.all(s).then(Oe).catch(Oe);
  }
  invalidateQueries(t, r, n) {
    const [i, o] = Me(t, r, n);
    return ie.batch(() => {
      var s, a;
      if (this.queryCache.findAll(i).forEach((c) => {
        c.invalidate();
      }), i.refetchType === "none")
        return Promise.resolve();
      const u = {
        ...i,
        type: (s = (a = i.refetchType) != null ? a : i.type) != null ? s : "active"
      };
      return this.refetchQueries(u, o);
    });
  }
  refetchQueries(t, r, n) {
    const [i, o] = Me(t, r, n), s = ie.batch(() => this.queryCache.findAll(i).filter((u) => !u.isDisabled()).map((u) => {
      var c;
      return u.fetch(void 0, {
        ...o,
        cancelRefetch: (c = o == null ? void 0 : o.cancelRefetch) != null ? c : !0,
        meta: {
          refetchPage: i.refetchPage
        }
      });
    }));
    let a = Promise.all(s).then(Oe);
    return o != null && o.throwOnError || (a = a.catch(Oe)), a;
  }
  fetchQuery(t, r, n) {
    const i = ht(t, r, n), o = this.defaultQueryOptions(i);
    typeof o.retry > "u" && (o.retry = !1);
    const s = this.queryCache.build(this, o);
    return s.isStaleByTime(o.staleTime) ? s.fetch(o) : Promise.resolve(s.state.data);
  }
  prefetchQuery(t, r, n) {
    return this.fetchQuery(t, r, n).then(Oe).catch(Oe);
  }
  fetchInfiniteQuery(t, r, n) {
    const i = ht(t, r, n);
    return i.behavior = ou(), this.fetchQuery(i);
  }
  prefetchInfiniteQuery(t, r, n) {
    return this.fetchInfiniteQuery(t, r, n).then(Oe).catch(Oe);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(t) {
    this.defaultOptions = t;
  }
  setQueryDefaults(t, r) {
    const n = this.queryDefaults.find((i) => We(t) === We(i.queryKey));
    n ? n.defaultOptions = r : this.queryDefaults.push({
      queryKey: t,
      defaultOptions: r
    });
  }
  getQueryDefaults(t) {
    if (!t)
      return;
    const r = this.queryDefaults.find((n) => Ze(t, n.queryKey));
    return process.env.NODE_ENV !== "production" && this.queryDefaults.filter((i) => Ze(t, i.queryKey)).length > 1 && this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(t) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults."), r == null ? void 0 : r.defaultOptions;
  }
  setMutationDefaults(t, r) {
    const n = this.mutationDefaults.find((i) => We(t) === We(i.mutationKey));
    n ? n.defaultOptions = r : this.mutationDefaults.push({
      mutationKey: t,
      defaultOptions: r
    });
  }
  getMutationDefaults(t) {
    if (!t)
      return;
    const r = this.mutationDefaults.find((n) => Ze(t, n.mutationKey));
    return process.env.NODE_ENV !== "production" && this.mutationDefaults.filter((i) => Ze(t, i.mutationKey)).length > 1 && this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(t) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults."), r == null ? void 0 : r.defaultOptions;
  }
  defaultQueryOptions(t) {
    if (t != null && t._defaulted)
      return t;
    const r = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(t == null ? void 0 : t.queryKey),
      ...t,
      _defaulted: !0
    };
    return !r.queryHash && r.queryKey && (r.queryHash = zr(r.queryKey, r)), typeof r.refetchOnReconnect > "u" && (r.refetchOnReconnect = r.networkMode !== "always"), typeof r.useErrorBoundary > "u" && (r.useErrorBoundary = !!r.suspense), r;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(t == null ? void 0 : t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    this.queryCache.clear(), this.mutationCache.clear();
  }
}
class uu extends st {
  constructor(t, r) {
    super(), this.client = t, this.options = r, this.trackedProps = /* @__PURE__ */ new Set(), this.selectError = null, this.bindMethods(), this.setOptions(r);
  }
  bindMethods() {
    this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.length === 1 && (this.currentQuery.addObserver(this), ii(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());
  }
  onUnsubscribe() {
    this.listeners.length || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Ir(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return Ir(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = [], this.clearStaleTimeout(), this.clearRefetchInterval(), this.currentQuery.removeObserver(this);
  }
  setOptions(t, r) {
    const n = this.options, i = this.currentQuery;
    if (this.options = this.client.defaultQueryOptions(t), process.env.NODE_ENV !== "production" && typeof (t == null ? void 0 : t.isDataEqual) < "u" && this.client.getLogger().error("The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option"), Rr(n, this.options) || this.client.getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: this.currentQuery,
      observer: this
    }), typeof this.options.enabled < "u" && typeof this.options.enabled != "boolean")
      throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = n.queryKey), this.updateQuery();
    const o = this.hasListeners();
    o && oi(this.currentQuery, i, this.options, n) && this.executeFetch(), this.updateResult(r), o && (this.currentQuery !== i || this.options.enabled !== n.enabled || this.options.staleTime !== n.staleTime) && this.updateStaleTimeout();
    const s = this.computeRefetchInterval();
    o && (this.currentQuery !== i || this.options.enabled !== n.enabled || s !== this.currentRefetchInterval) && this.updateRefetchInterval(s);
  }
  getOptimisticResult(t) {
    const r = this.client.getQueryCache().build(this.client, t);
    return this.createResult(r, t);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(t) {
    const r = {};
    return Object.keys(t).forEach((n) => {
      Object.defineProperty(r, n, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackedProps.add(n), t[n])
      });
    }), r;
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({
    refetchPage: t,
    ...r
  } = {}) {
    return this.fetch({
      ...r,
      meta: {
        refetchPage: t
      }
    });
  }
  fetchOptimistic(t) {
    const r = this.client.defaultQueryOptions(t), n = this.client.getQueryCache().build(this.client, r);
    return n.isFetchingOptimistic = !0, n.fetch().then(() => this.createResult(n, r));
  }
  fetch(t) {
    var r;
    return this.executeFetch({
      ...t,
      cancelRefetch: (r = t.cancelRefetch) != null ? r : !0
    }).then(() => (this.updateResult(), this.currentResult));
  }
  executeFetch(t) {
    this.updateQuery();
    let r = this.currentQuery.fetch(this.options, t);
    return t != null && t.throwOnError || (r = r.catch(Oe)), r;
  }
  updateStaleTimeout() {
    if (this.clearStaleTimeout(), bt || this.currentResult.isStale || !Cr(this.options.staleTime))
      return;
    const r = Yi(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;
    this.staleTimeoutId = setTimeout(() => {
      this.currentResult.isStale || this.updateResult();
    }, r);
  }
  computeRefetchInterval() {
    var t;
    return typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (t = this.options.refetchInterval) != null ? t : !1;
  }
  updateRefetchInterval(t) {
    this.clearRefetchInterval(), this.currentRefetchInterval = t, !(bt || this.options.enabled === !1 || !Cr(this.currentRefetchInterval) || this.currentRefetchInterval === 0) && (this.refetchIntervalId = setInterval(() => {
      (this.options.refetchIntervalInBackground || Dt.isFocused()) && this.executeFetch();
    }, this.currentRefetchInterval));
  }
  updateTimers() {
    this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);
  }
  clearRefetchInterval() {
    this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);
  }
  createResult(t, r) {
    const n = this.currentQuery, i = this.options, o = this.currentResult, s = this.currentResultState, a = this.currentResultOptions, u = t !== n, c = u ? t.state : this.currentQueryInitialState, l = u ? this.currentResult : this.previousQueryResult, {
      state: f
    } = t;
    let {
      dataUpdatedAt: d,
      error: h,
      errorUpdatedAt: y,
      fetchStatus: E,
      status: v
    } = f, O = !1, x = !1, S;
    if (r._optimisticResults) {
      const C = this.hasListeners(), M = !C && ii(t, r), $ = C && oi(t, n, r, i);
      (M || $) && (E = Ft(t.options.networkMode) ? "fetching" : "paused", d || (v = "loading")), r._optimisticResults === "isRestoring" && (E = "idle");
    }
    if (r.keepPreviousData && !f.dataUpdatedAt && l != null && l.isSuccess && v !== "error")
      S = l.data, d = l.dataUpdatedAt, v = l.status, O = !0;
    else if (r.select && typeof f.data < "u")
      if (o && f.data === (s == null ? void 0 : s.data) && r.select === this.selectFn)
        S = this.selectResult;
      else
        try {
          this.selectFn = r.select, S = r.select(f.data), S = Nr(o == null ? void 0 : o.data, S, r), this.selectResult = S, this.selectError = null;
        } catch (C) {
          process.env.NODE_ENV !== "production" && this.client.getLogger().error(C), this.selectError = C;
        }
    else
      S = f.data;
    if (typeof r.placeholderData < "u" && typeof S > "u" && v === "loading") {
      let C;
      if (o != null && o.isPlaceholderData && r.placeholderData === (a == null ? void 0 : a.placeholderData))
        C = o.data;
      else if (C = typeof r.placeholderData == "function" ? r.placeholderData() : r.placeholderData, r.select && typeof C < "u")
        try {
          C = r.select(C), this.selectError = null;
        } catch (M) {
          process.env.NODE_ENV !== "production" && this.client.getLogger().error(M), this.selectError = M;
        }
      typeof C < "u" && (v = "success", S = Nr(o == null ? void 0 : o.data, C, r), x = !0);
    }
    this.selectError && (h = this.selectError, S = this.selectResult, y = Date.now(), v = "error");
    const m = E === "fetching", b = v === "loading", w = v === "error";
    return {
      status: v,
      fetchStatus: E,
      isLoading: b,
      isSuccess: v === "success",
      isError: w,
      isInitialLoading: b && m,
      data: S,
      dataUpdatedAt: d,
      error: h,
      errorUpdatedAt: y,
      failureCount: f.fetchFailureCount,
      failureReason: f.fetchFailureReason,
      errorUpdateCount: f.errorUpdateCount,
      isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
      isFetchedAfterMount: f.dataUpdateCount > c.dataUpdateCount || f.errorUpdateCount > c.errorUpdateCount,
      isFetching: m,
      isRefetching: m && !b,
      isLoadingError: w && f.dataUpdatedAt === 0,
      isPaused: E === "paused",
      isPlaceholderData: x,
      isPreviousData: O,
      isRefetchError: w && f.dataUpdatedAt !== 0,
      isStale: Kr(t, r),
      refetch: this.refetch,
      remove: this.remove
    };
  }
  updateResult(t) {
    const r = this.currentResult, n = this.createResult(this.currentQuery, this.options);
    if (this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, Rr(n, r))
      return;
    this.currentResult = n;
    const i = {
      cache: !0
    }, o = () => {
      if (!r)
        return !0;
      const {
        notifyOnChangeProps: s
      } = this.options;
      if (s === "all" || !s && !this.trackedProps.size)
        return !0;
      const a = new Set(s ?? this.trackedProps);
      return this.options.useErrorBoundary && a.add("error"), Object.keys(this.currentResult).some((u) => {
        const c = u;
        return this.currentResult[c] !== r[c] && a.has(c);
      });
    };
    (t == null ? void 0 : t.listeners) !== !1 && o() && (i.listeners = !0), this.notify({
      ...i,
      ...t
    });
  }
  updateQuery() {
    const t = this.client.getQueryCache().build(this.client, this.options);
    if (t === this.currentQuery)
      return;
    const r = this.currentQuery;
    this.currentQuery = t, this.currentQueryInitialState = t.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (r == null || r.removeObserver(this), t.addObserver(this));
  }
  onQueryUpdate(t) {
    const r = {};
    t.type === "success" ? r.onSuccess = !t.manual : t.type === "error" && !_t(t.error) && (r.onError = !0), this.updateResult(r), this.hasListeners() && this.updateTimers();
  }
  notify(t) {
    ie.batch(() => {
      if (t.onSuccess) {
        var r, n, i, o;
        (r = (n = this.options).onSuccess) == null || r.call(n, this.currentResult.data), (i = (o = this.options).onSettled) == null || i.call(o, this.currentResult.data, null);
      } else if (t.onError) {
        var s, a, u, c;
        (s = (a = this.options).onError) == null || s.call(a, this.currentResult.error), (u = (c = this.options).onSettled) == null || u.call(c, void 0, this.currentResult.error);
      }
      t.listeners && this.listeners.forEach((l) => {
        l(this.currentResult);
      }), t.cache && this.client.getQueryCache().notify({
        query: this.currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }
}
function cu(e, t) {
  return t.enabled !== !1 && !e.state.dataUpdatedAt && !(e.state.status === "error" && t.retryOnMount === !1);
}
function ii(e, t) {
  return cu(e, t) || e.state.dataUpdatedAt > 0 && Ir(e, t, t.refetchOnMount);
}
function Ir(e, t, r) {
  if (t.enabled !== !1) {
    const n = typeof r == "function" ? r(e) : r;
    return n === "always" || n !== !1 && Kr(e, t);
  }
  return !1;
}
function oi(e, t, r, n) {
  return r.enabled !== !1 && (e !== t || n.enabled === !1) && (!r.suspense || e.state.status !== "error") && Kr(e, r);
}
function Kr(e, t) {
  return e.isStaleByTime(t.staleTime);
}
class lu extends st {
  constructor(t, r) {
    super(), this.client = t, this.setOptions(r), this.bindMethods(), this.updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(t) {
    var r;
    const n = this.options;
    this.options = this.client.defaultMutationOptions(t), Rr(n, this.options) || this.client.getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: this.currentMutation,
      observer: this
    }), (r = this.currentMutation) == null || r.setOptions(this.options);
  }
  onUnsubscribe() {
    if (!this.listeners.length) {
      var t;
      (t = this.currentMutation) == null || t.removeObserver(this);
    }
  }
  onMutationUpdate(t) {
    this.updateResult();
    const r = {
      listeners: !0
    };
    t.type === "success" ? r.onSuccess = !0 : t.type === "error" && (r.onError = !0), this.notify(r);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  reset() {
    this.currentMutation = void 0, this.updateResult(), this.notify({
      listeners: !0
    });
  }
  mutate(t, r) {
    return this.mutateOptions = r, this.currentMutation && this.currentMutation.removeObserver(this), this.currentMutation = this.client.getMutationCache().build(this.client, {
      ...this.options,
      variables: typeof t < "u" ? t : this.options.variables
    }), this.currentMutation.addObserver(this), this.currentMutation.execute();
  }
  updateResult() {
    const t = this.currentMutation ? this.currentMutation.state : Zi(), r = {
      ...t,
      isLoading: t.status === "loading",
      isSuccess: t.status === "success",
      isError: t.status === "error",
      isIdle: t.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
    this.currentResult = r;
  }
  notify(t) {
    ie.batch(() => {
      if (this.mutateOptions && this.hasListeners()) {
        if (t.onSuccess) {
          var r, n, i, o;
          (r = (n = this.mutateOptions).onSuccess) == null || r.call(n, this.currentResult.data, this.currentResult.variables, this.currentResult.context), (i = (o = this.mutateOptions).onSettled) == null || i.call(o, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
        } else if (t.onError) {
          var s, a, u, c;
          (s = (a = this.mutateOptions).onError) == null || s.call(a, this.currentResult.error, this.currentResult.variables, this.currentResult.context), (u = (c = this.mutateOptions).onSettled) == null || u.call(c, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
        }
      }
      t.listeners && this.listeners.forEach((l) => {
        l(this.currentResult);
      });
    });
  }
}
const eo = qr.useSyncExternalStore, si = /* @__PURE__ */ fe.createContext(void 0), to = /* @__PURE__ */ fe.createContext(!1);
function ro(e, t) {
  return e || (t && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = si), window.ReactQueryClientContext) : si);
}
const no = ({
  context: e
} = {}) => {
  const t = fe.useContext(ro(e, fe.useContext(to)));
  if (!t)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return t;
}, fu = ({
  client: e,
  children: t,
  context: r,
  contextSharing: n = !1
}) => {
  fe.useEffect(() => (e.mount(), () => {
    e.unmount();
  }), [e]), process.env.NODE_ENV !== "production" && n && e.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
  const i = ro(r, n);
  return /* @__PURE__ */ fe.createElement(to.Provider, {
    value: !r && n
  }, /* @__PURE__ */ fe.createElement(i.Provider, {
    value: e
  }, t));
}, io = /* @__PURE__ */ fe.createContext(!1), du = () => fe.useContext(io);
io.Provider;
function hu() {
  let e = !1;
  return {
    clearReset: () => {
      e = !1;
    },
    reset: () => {
      e = !0;
    },
    isReset: () => e
  };
}
const pu = /* @__PURE__ */ fe.createContext(hu()), yu = () => fe.useContext(pu);
function oo(e, t) {
  return typeof e == "function" ? e(...t) : !!e;
}
const vu = (e, t) => {
  (e.suspense || e.useErrorBoundary) && (t.isReset() || (e.retryOnMount = !1));
}, mu = (e) => {
  fe.useEffect(() => {
    e.clearReset();
  }, [e]);
}, gu = ({
  result: e,
  errorResetBoundary: t,
  useErrorBoundary: r,
  query: n
}) => e.isError && !t.isReset() && !e.isFetching && oo(r, [e.error, n]), bu = (e) => {
  e.suspense && typeof e.staleTime != "number" && (e.staleTime = 1e3);
}, Eu = (e, t) => e.isLoading && e.isFetching && !t, Su = (e, t, r) => (e == null ? void 0 : e.suspense) && Eu(t, r), Ou = (e, t, r) => t.fetchOptimistic(e).then(({
  data: n
}) => {
  e.onSuccess == null || e.onSuccess(n), e.onSettled == null || e.onSettled(n, null);
}).catch((n) => {
  r.clearReset(), e.onError == null || e.onError(n), e.onSettled == null || e.onSettled(void 0, n);
});
function wu(e, t) {
  const r = no({
    context: e.context
  }), n = du(), i = yu(), o = r.defaultQueryOptions(e);
  o._optimisticResults = n ? "isRestoring" : "optimistic", o.onError && (o.onError = ie.batchCalls(o.onError)), o.onSuccess && (o.onSuccess = ie.batchCalls(o.onSuccess)), o.onSettled && (o.onSettled = ie.batchCalls(o.onSettled)), bu(o), vu(o, i), mu(i);
  const [s] = fe.useState(() => new t(r, o)), a = s.getOptimisticResult(o);
  if (eo(fe.useCallback((u) => n ? () => {
  } : s.subscribe(ie.batchCalls(u)), [s, n]), () => s.getCurrentResult(), () => s.getCurrentResult()), fe.useEffect(() => {
    s.setOptions(o, {
      listeners: !1
    });
  }, [o, s]), Su(o, a, n))
    throw Ou(o, s, i);
  if (gu({
    result: a,
    errorResetBoundary: i,
    useErrorBoundary: o.useErrorBoundary,
    query: s.getCurrentQuery()
  }))
    throw a.error;
  return o.notifyOnChangeProps ? a : s.trackResult(a);
}
function Tu(e, t, r) {
  const n = ht(e, t, r);
  return wu(n, uu);
}
function _u(e, t, r) {
  const n = Ga(e, t, r), i = no({
    context: n.context
  }), [o] = fe.useState(() => new lu(i, n));
  fe.useEffect(() => {
    o.setOptions(n);
  }, [o, n]);
  const s = eo(fe.useCallback((u) => o.subscribe(ie.batchCalls(u)), [o]), () => o.getCurrentResult(), () => o.getCurrentResult()), a = fe.useCallback((u, c) => {
    o.mutate(u, c).catch(xu);
  }, [o]);
  if (s.error && oo(o.options.useErrorBoundary, [s.error]))
    throw s.error;
  return {
    ...s,
    mutate: a,
    mutateAsync: s.mutate
  };
}
function xu() {
}
const Kc = ({ children: e }) => {
  const t = new au();
  return /* @__PURE__ */ Sn.jsx(fu, { client: t, children: /* @__PURE__ */ Sn.jsx(js, { store: ae, children: e }) });
};
function so(e, t, r, n) {
  return async () => e.request({
    document: t,
    variables: r,
    requestHeaders: n
  });
}
const Cu = `
    mutation Login($email: String, $name: String, $hash: String, $anonymousId: String, $externalId: String) {
  login(
    email: $email
    name: $name
    hash: $hash
    anonymousId: $anonymousId
    externalId: $externalId
  ) {
    accessToken {
      token
      expAt
    }
    anonymousId
    refreshToken {
      token
      expAt
    }
    anonymous
    email
    name
    userId
  }
}
    `, Ru = `
    mutation RefreshAuth($refreshToken: String!) {
  refreshAuth(refreshToken: $refreshToken) {
    accessToken {
      token
      expAt
    }
    anonymousId
    refreshToken {
      token
      expAt
    }
    anonymous
    email
    name
    userId
  }
}
    `, Au = `
    mutation sendMessage($message: MessageInput!, $conversationId: String, $agent: String, $context: JSON) {
  sendMessage(
    message: $message
    conversationId: $conversationId
    agent: $agent
    context: $context
  ) {
    conversationId
  }
}
    `, Hc = (e, t, r) => _u(
  ["sendMessage"],
  (n) => so(e, Au, n, r)(),
  t
), Nu = `
    mutation updateConversationContext($conversationId: String!, $context: JSON!) {
  updateConversationContext(conversationId: $conversationId, context: $context) {
    id
  }
}
    `, Iu = `
    query GetConversations {
  getConversations {
    id
    title
    lastMessage {
      id
      content
      userId
      createdAt
    }
    agent {
      key
      displayName
      avatarUrl
    }
  }
}
    `, Jc = (e, t, r, n) => Tu(
  t === void 0 ? ["GetConversations"] : ["GetConversations", t],
  so(e, Iu, t, n),
  r
), Pu = `
    subscription subscribeConversationEvents($conversationId: String, $agent: String, $context: JSON) {
  subscribeConversationEvents(
    conversationId: $conversationId
    agent: $agent
    context: $context
  ) {
    kind
    payload
  }
}
    `, Hr = JSON, Du = (e) => e.toUpperCase(), ku = (e) => {
  const t = {};
  return e.forEach((r, n) => {
    t[n] = r;
  }), t;
}, Lu = (e, t, r) => e.document ? e : {
  document: e,
  variables: t,
  requestHeaders: r,
  signal: void 0
}, Mu = (e, t, r) => e.query ? e : {
  query: e,
  variables: t,
  requestHeaders: r,
  signal: void 0
}, Fu = (e, t) => e.documents ? e : {
  documents: e,
  requestHeaders: t,
  signal: void 0
};
function xt(e, t) {
  if (!!!e)
    throw new Error(t);
}
function ju(e) {
  return typeof e == "object" && e !== null;
}
function qu(e, t) {
  if (!!!e)
    throw new Error(
      t ?? "Unexpected invariant triggered."
    );
}
const Uu = /\r\n|[\n\r]/g;
function Pr(e, t) {
  let r = 0, n = 1;
  for (const i of e.body.matchAll(Uu)) {
    if (typeof i.index == "number" || qu(!1), i.index >= t)
      break;
    r = i.index + i[0].length, n += 1;
  }
  return {
    line: n,
    column: t + 1 - r
  };
}
function Vu(e) {
  return ao(
    e.source,
    Pr(e.source, e.start)
  );
}
function ao(e, t) {
  const r = e.locationOffset.column - 1, n = "".padStart(r) + e.body, i = t.line - 1, o = e.locationOffset.line - 1, s = t.line + o, a = t.line === 1 ? r : 0, u = t.column + a, c = `${e.name}:${s}:${u}
`, l = n.split(/\r\n|[\n\r]/g), f = l[i];
  if (f.length > 120) {
    const d = Math.floor(u / 80), h = u % 80, y = [];
    for (let E = 0; E < f.length; E += 80)
      y.push(f.slice(E, E + 80));
    return c + ai([
      [`${s} |`, y[0]],
      ...y.slice(1, d + 1).map((E) => ["|", E]),
      ["|", "^".padStart(h)],
      ["|", y[d + 1]]
    ]);
  }
  return c + ai([
    // Lines specified like this: ["prefix", "string"],
    [`${s - 1} |`, l[i - 1]],
    [`${s} |`, f],
    ["|", "^".padStart(u)],
    [`${s + 1} |`, l[i + 1]]
  ]);
}
function ai(e) {
  const t = e.filter(([n, i]) => i !== void 0), r = Math.max(...t.map(([n]) => n.length));
  return t.map(([n, i]) => n.padStart(r) + (i ? " " + i : "")).join(`
`);
}
function $u(e) {
  const t = e[0];
  return t == null || "kind" in t || "length" in t ? {
    nodes: t,
    source: e[1],
    positions: e[2],
    path: e[3],
    originalError: e[4],
    extensions: e[5]
  } : t;
}
class Jr extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(t, ...r) {
    var n, i, o;
    const { nodes: s, source: a, positions: u, path: c, originalError: l, extensions: f } = $u(r);
    super(t), this.name = "GraphQLError", this.path = c ?? void 0, this.originalError = l ?? void 0, this.nodes = ui(
      Array.isArray(s) ? s : s ? [s] : void 0
    );
    const d = ui(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((y) => y.loc).filter((y) => y != null)
    );
    this.source = a ?? (d == null || (i = d[0]) === null || i === void 0 ? void 0 : i.source), this.positions = u ?? (d == null ? void 0 : d.map((y) => y.start)), this.locations = u && a ? u.map((y) => Pr(a, y)) : d == null ? void 0 : d.map((y) => Pr(y.source, y.start));
    const h = ju(
      l == null ? void 0 : l.extensions
    ) ? l == null ? void 0 : l.extensions : void 0;
    this.extensions = (o = f ?? h) !== null && o !== void 0 ? o : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), l != null && l.stack ? Object.defineProperty(this, "stack", {
      value: l.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, Jr) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let t = this.message;
    if (this.nodes)
      for (const r of this.nodes)
        r.loc && (t += `

` + Vu(r.loc));
    else if (this.source && this.locations)
      for (const r of this.locations)
        t += `

` + ao(this.source, r);
    return t;
  }
  toJSON() {
    const t = {
      message: this.message
    };
    return this.locations != null && (t.locations = this.locations), this.path != null && (t.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t.extensions = this.extensions), t;
  }
}
function ui(e) {
  return e === void 0 || e.length === 0 ? void 0 : e;
}
function he(e, t, r) {
  return new Jr(`Syntax Error: ${r}`, {
    source: e,
    positions: [t]
  });
}
class Bu {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(t, r, n) {
    this.start = t.start, this.end = r.end, this.startToken = t, this.endToken = r, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class uo {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(t, r, n, i, o, s) {
    this.kind = t, this.start = r, this.end = n, this.line = i, this.column = o, this.value = s, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const co = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, Qu = new Set(Object.keys(co));
function ci(e) {
  const t = e == null ? void 0 : e.kind;
  return typeof t == "string" && Qu.has(t);
}
var et;
(function(e) {
  e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
})(et || (et = {}));
var Dr;
(function(e) {
  e.QUERY = "QUERY", e.MUTATION = "MUTATION", e.SUBSCRIPTION = "SUBSCRIPTION", e.FIELD = "FIELD", e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", e.INLINE_FRAGMENT = "INLINE_FRAGMENT", e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", e.SCHEMA = "SCHEMA", e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.FIELD_DEFINITION = "FIELD_DEFINITION", e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.ENUM_VALUE = "ENUM_VALUE", e.INPUT_OBJECT = "INPUT_OBJECT", e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(Dr || (Dr = {}));
var F;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(F || (F = {}));
function kr(e) {
  return e === 9 || e === 32;
}
function Et(e) {
  return e >= 48 && e <= 57;
}
function lo(e) {
  return e >= 97 && e <= 122 || // A-Z
  e >= 65 && e <= 90;
}
function fo(e) {
  return lo(e) || e === 95;
}
function Wu(e) {
  return lo(e) || Et(e) || e === 95;
}
function Yu(e) {
  var t;
  let r = Number.MAX_SAFE_INTEGER, n = null, i = -1;
  for (let s = 0; s < e.length; ++s) {
    var o;
    const a = e[s], u = zu(a);
    u !== a.length && (n = (o = n) !== null && o !== void 0 ? o : s, i = s, s !== 0 && u < r && (r = u));
  }
  return e.map((s, a) => a === 0 ? s : s.slice(r)).slice(
    (t = n) !== null && t !== void 0 ? t : 0,
    i + 1
  );
}
function zu(e) {
  let t = 0;
  for (; t < e.length && kr(e.charCodeAt(t)); )
    ++t;
  return t;
}
function Gu(e, t) {
  const r = e.replace(/"""/g, '\\"""'), n = r.split(/\r\n|[\n\r]/g), i = n.length === 1, o = n.length > 1 && n.slice(1).every((h) => h.length === 0 || kr(h.charCodeAt(0))), s = r.endsWith('\\"""'), a = e.endsWith('"') && !s, u = e.endsWith("\\"), c = a || u, l = !(t != null && t.minimize) && // add leading and trailing new lines only if it improves readability
  (!i || e.length > 70 || c || o || s);
  let f = "";
  const d = i && kr(e.charCodeAt(0));
  return (l && !d || o) && (f += `
`), f += r, (l || c) && (f += `
`), '"""' + f + '"""';
}
var _;
(function(e) {
  e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment";
})(_ || (_ = {}));
class Ku {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(t) {
    const r = new uo(_.SOF, 0, 0, 0, 0);
    this.source = t, this.lastToken = r, this.token = r, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let t = this.token;
    if (t.kind !== _.EOF)
      do
        if (t.next)
          t = t.next;
        else {
          const r = Ju(this, t.end);
          t.next = r, r.prev = t, t = r;
        }
      while (t.kind === _.COMMENT);
    return t;
  }
}
function Hu(e) {
  return e === _.BANG || e === _.DOLLAR || e === _.AMP || e === _.PAREN_L || e === _.PAREN_R || e === _.SPREAD || e === _.COLON || e === _.EQUALS || e === _.AT || e === _.BRACKET_L || e === _.BRACKET_R || e === _.BRACE_L || e === _.PIPE || e === _.BRACE_R;
}
function at(e) {
  return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
}
function jt(e, t) {
  return ho(e.charCodeAt(t)) && po(e.charCodeAt(t + 1));
}
function ho(e) {
  return e >= 55296 && e <= 56319;
}
function po(e) {
  return e >= 56320 && e <= 57343;
}
function Ge(e, t) {
  const r = e.source.body.codePointAt(t);
  if (r === void 0)
    return _.EOF;
  if (r >= 32 && r <= 126) {
    const n = String.fromCodePoint(r);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + r.toString(16).toUpperCase().padStart(4, "0");
}
function ce(e, t, r, n, i) {
  const o = e.line, s = 1 + r - e.lineStart;
  return new uo(t, r, n, o, s, i);
}
function Ju(e, t) {
  const r = e.source.body, n = r.length;
  let i = t;
  for (; i < n; ) {
    const o = r.charCodeAt(i);
    switch (o) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++i;
        continue;
      case 10:
        ++i, ++e.line, e.lineStart = i;
        continue;
      case 13:
        r.charCodeAt(i + 1) === 10 ? i += 2 : ++i, ++e.line, e.lineStart = i;
        continue;
      case 35:
        return Xu(e, i);
      case 33:
        return ce(e, _.BANG, i, i + 1);
      case 36:
        return ce(e, _.DOLLAR, i, i + 1);
      case 38:
        return ce(e, _.AMP, i, i + 1);
      case 40:
        return ce(e, _.PAREN_L, i, i + 1);
      case 41:
        return ce(e, _.PAREN_R, i, i + 1);
      case 46:
        if (r.charCodeAt(i + 1) === 46 && r.charCodeAt(i + 2) === 46)
          return ce(e, _.SPREAD, i, i + 3);
        break;
      case 58:
        return ce(e, _.COLON, i, i + 1);
      case 61:
        return ce(e, _.EQUALS, i, i + 1);
      case 64:
        return ce(e, _.AT, i, i + 1);
      case 91:
        return ce(e, _.BRACKET_L, i, i + 1);
      case 93:
        return ce(e, _.BRACKET_R, i, i + 1);
      case 123:
        return ce(e, _.BRACE_L, i, i + 1);
      case 124:
        return ce(e, _.PIPE, i, i + 1);
      case 125:
        return ce(e, _.BRACE_R, i, i + 1);
      case 34:
        return r.charCodeAt(i + 1) === 34 && r.charCodeAt(i + 2) === 34 ? ic(e, i) : ec(e, i);
    }
    if (Et(o) || o === 45)
      return Zu(e, i, o);
    if (fo(o))
      return oc(e, i);
    throw he(
      e.source,
      i,
      o === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : at(o) || jt(r, i) ? `Unexpected character: ${Ge(e, i)}.` : `Invalid character: ${Ge(e, i)}.`
    );
  }
  return ce(e, _.EOF, n, n);
}
function Xu(e, t) {
  const r = e.source.body, n = r.length;
  let i = t + 1;
  for (; i < n; ) {
    const o = r.charCodeAt(i);
    if (o === 10 || o === 13)
      break;
    if (at(o))
      ++i;
    else if (jt(r, i))
      i += 2;
    else
      break;
  }
  return ce(
    e,
    _.COMMENT,
    t,
    i,
    r.slice(t + 1, i)
  );
}
function Zu(e, t, r) {
  const n = e.source.body;
  let i = t, o = r, s = !1;
  if (o === 45 && (o = n.charCodeAt(++i)), o === 48) {
    if (o = n.charCodeAt(++i), Et(o))
      throw he(
        e.source,
        i,
        `Invalid number, unexpected digit after 0: ${Ge(
          e,
          i
        )}.`
      );
  } else
    i = dr(e, i, o), o = n.charCodeAt(i);
  if (o === 46 && (s = !0, o = n.charCodeAt(++i), i = dr(e, i, o), o = n.charCodeAt(i)), (o === 69 || o === 101) && (s = !0, o = n.charCodeAt(++i), (o === 43 || o === 45) && (o = n.charCodeAt(++i)), i = dr(e, i, o), o = n.charCodeAt(i)), o === 46 || fo(o))
    throw he(
      e.source,
      i,
      `Invalid number, expected digit but got: ${Ge(
        e,
        i
      )}.`
    );
  return ce(
    e,
    s ? _.FLOAT : _.INT,
    t,
    i,
    n.slice(t, i)
  );
}
function dr(e, t, r) {
  if (!Et(r))
    throw he(
      e.source,
      t,
      `Invalid number, expected digit but got: ${Ge(
        e,
        t
      )}.`
    );
  const n = e.source.body;
  let i = t + 1;
  for (; Et(n.charCodeAt(i)); )
    ++i;
  return i;
}
function ec(e, t) {
  const r = e.source.body, n = r.length;
  let i = t + 1, o = i, s = "";
  for (; i < n; ) {
    const a = r.charCodeAt(i);
    if (a === 34)
      return s += r.slice(o, i), ce(e, _.STRING, t, i + 1, s);
    if (a === 92) {
      s += r.slice(o, i);
      const u = r.charCodeAt(i + 1) === 117 ? r.charCodeAt(i + 2) === 123 ? tc(e, i) : rc(e, i) : nc(e, i);
      s += u.value, i += u.size, o = i;
      continue;
    }
    if (a === 10 || a === 13)
      break;
    if (at(a))
      ++i;
    else if (jt(r, i))
      i += 2;
    else
      throw he(
        e.source,
        i,
        `Invalid character within String: ${Ge(
          e,
          i
        )}.`
      );
  }
  throw he(e.source, i, "Unterminated string.");
}
function tc(e, t) {
  const r = e.source.body;
  let n = 0, i = 3;
  for (; i < 12; ) {
    const o = r.charCodeAt(t + i++);
    if (o === 125) {
      if (i < 5 || !at(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: i
      };
    }
    if (n = n << 4 | pt(o), n < 0)
      break;
  }
  throw he(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${r.slice(
      t,
      t + i
    )}".`
  );
}
function rc(e, t) {
  const r = e.source.body, n = li(r, t + 2);
  if (at(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (ho(n) && r.charCodeAt(t + 6) === 92 && r.charCodeAt(t + 7) === 117) {
    const i = li(r, t + 8);
    if (po(i))
      return {
        value: String.fromCodePoint(n, i),
        size: 12
      };
  }
  throw he(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${r.slice(t, t + 6)}".`
  );
}
function li(e, t) {
  return pt(e.charCodeAt(t)) << 12 | pt(e.charCodeAt(t + 1)) << 8 | pt(e.charCodeAt(t + 2)) << 4 | pt(e.charCodeAt(t + 3));
}
function pt(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function nc(e, t) {
  const r = e.source.body;
  switch (r.charCodeAt(t + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw he(
    e.source,
    t,
    `Invalid character escape sequence: "${r.slice(
      t,
      t + 2
    )}".`
  );
}
function ic(e, t) {
  const r = e.source.body, n = r.length;
  let i = e.lineStart, o = t + 3, s = o, a = "";
  const u = [];
  for (; o < n; ) {
    const c = r.charCodeAt(o);
    if (c === 34 && r.charCodeAt(o + 1) === 34 && r.charCodeAt(o + 2) === 34) {
      a += r.slice(s, o), u.push(a);
      const l = ce(
        e,
        _.BLOCK_STRING,
        t,
        o + 3,
        // Return a string of the lines joined with U+000A.
        Yu(u).join(`
`)
      );
      return e.line += u.length - 1, e.lineStart = i, l;
    }
    if (c === 92 && r.charCodeAt(o + 1) === 34 && r.charCodeAt(o + 2) === 34 && r.charCodeAt(o + 3) === 34) {
      a += r.slice(s, o), s = o + 1, o += 4;
      continue;
    }
    if (c === 10 || c === 13) {
      a += r.slice(s, o), u.push(a), c === 13 && r.charCodeAt(o + 1) === 10 ? o += 2 : ++o, a = "", s = o, i = o;
      continue;
    }
    if (at(c))
      ++o;
    else if (jt(r, o))
      o += 2;
    else
      throw he(
        e.source,
        o,
        `Invalid character within String: ${Ge(
          e,
          o
        )}.`
      );
  }
  throw he(e.source, o, "Unterminated string.");
}
function oc(e, t) {
  const r = e.source.body, n = r.length;
  let i = t + 1;
  for (; i < n; ) {
    const o = r.charCodeAt(i);
    if (Wu(o))
      ++i;
    else
      break;
  }
  return ce(
    e,
    _.NAME,
    t,
    i,
    r.slice(t, i)
  );
}
const sc = 10, yo = 2;
function Xr(e) {
  return qt(e, []);
}
function qt(e, t) {
  switch (typeof e) {
    case "string":
      return JSON.stringify(e);
    case "function":
      return e.name ? `[function ${e.name}]` : "[function]";
    case "object":
      return ac(e, t);
    default:
      return String(e);
  }
}
function ac(e, t) {
  if (e === null)
    return "null";
  if (t.includes(e))
    return "[Circular]";
  const r = [...t, e];
  if (uc(e)) {
    const n = e.toJSON();
    if (n !== e)
      return typeof n == "string" ? n : qt(n, r);
  } else if (Array.isArray(e))
    return lc(e, r);
  return cc(e, r);
}
function uc(e) {
  return typeof e.toJSON == "function";
}
function cc(e, t) {
  const r = Object.entries(e);
  return r.length === 0 ? "{}" : t.length > yo ? "[" + fc(e) + "]" : "{ " + r.map(
    ([i, o]) => i + ": " + qt(o, t)
  ).join(", ") + " }";
}
function lc(e, t) {
  if (e.length === 0)
    return "[]";
  if (t.length > yo)
    return "[Array]";
  const r = Math.min(sc, e.length), n = e.length - r, i = [];
  for (let o = 0; o < r; ++o)
    i.push(qt(e[o], t));
  return n === 1 ? i.push("... 1 more item") : n > 1 && i.push(`... ${n} more items`), "[" + i.join(", ") + "]";
}
function fc(e) {
  const t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
  if (t === "Object" && typeof e.constructor == "function") {
    const r = e.constructor.name;
    if (typeof r == "string" && r !== "")
      return r;
  }
  return t;
}
const dc = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  // eslint-disable-next-line no-undef
  process.env.NODE_ENV === "production" ? function(t, r) {
    return t instanceof r;
  } : function(t, r) {
    if (t instanceof r)
      return !0;
    if (typeof t == "object" && t !== null) {
      var n;
      const i = r.prototype[Symbol.toStringTag], o = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in t ? t[Symbol.toStringTag] : (n = t.constructor) === null || n === void 0 ? void 0 : n.name
      );
      if (i === o) {
        const s = Xr(t);
        throw new Error(`Cannot use ${i} "${s}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class vo {
  constructor(t, r = "GraphQL request", n = {
    line: 1,
    column: 1
  }) {
    typeof t == "string" || xt(!1, `Body must be a string. Received: ${Xr(t)}.`), this.body = t, this.name = r, this.locationOffset = n, this.locationOffset.line > 0 || xt(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || xt(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function hc(e) {
  return dc(e, vo);
}
function pc(e, t) {
  return new yc(e, t).parseDocument();
}
class yc {
  constructor(t, r = {}) {
    const n = hc(t) ? t : new vo(t);
    this._lexer = new Ku(n), this._options = r, this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const t = this.expectToken(_.NAME);
    return this.node(t, {
      kind: F.NAME,
      value: t.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: F.DOCUMENT,
      definitions: this.many(
        _.SOF,
        this.parseDefinition,
        _.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(_.BRACE_L))
      return this.parseOperationDefinition();
    const t = this.peekDescription(), r = t ? this._lexer.lookahead() : this._lexer.token;
    if (r.kind === _.NAME) {
      switch (r.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (t)
        throw he(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (r.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(r);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const t = this._lexer.token;
    if (this.peek(_.BRACE_L))
      return this.node(t, {
        kind: F.OPERATION_DEFINITION,
        operation: et.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const r = this.parseOperationType();
    let n;
    return this.peek(_.NAME) && (n = this.parseName()), this.node(t, {
      kind: F.OPERATION_DEFINITION,
      operation: r,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const t = this.expectToken(_.NAME);
    switch (t.value) {
      case "query":
        return et.QUERY;
      case "mutation":
        return et.MUTATION;
      case "subscription":
        return et.SUBSCRIPTION;
    }
    throw this.unexpected(t);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      _.PAREN_L,
      this.parseVariableDefinition,
      _.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: F.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(_.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(_.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const t = this._lexer.token;
    return this.expectToken(_.DOLLAR), this.node(t, {
      kind: F.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: F.SELECTION_SET,
      selections: this.many(
        _.BRACE_L,
        this.parseSelection,
        _.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(_.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const t = this._lexer.token, r = this.parseName();
    let n, i;
    return this.expectOptionalToken(_.COLON) ? (n = r, i = this.parseName()) : i = r, this.node(t, {
      kind: F.FIELD,
      alias: n,
      name: i,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(_.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(t) {
    const r = t ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(_.PAREN_L, r, _.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(t = !1) {
    const r = this._lexer.token, n = this.parseName();
    return this.expectToken(_.COLON), this.node(r, {
      kind: F.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const t = this._lexer.token;
    this.expectToken(_.SPREAD);
    const r = this.expectOptionalKeyword("on");
    return !r && this.peek(_.NAME) ? this.node(t, {
      kind: F.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(t, {
      kind: F.INLINE_FRAGMENT,
      typeCondition: r ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const t = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(t, {
      kind: F.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(t, {
      kind: F.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(t) {
    const r = this._lexer.token;
    switch (r.kind) {
      case _.BRACKET_L:
        return this.parseList(t);
      case _.BRACE_L:
        return this.parseObject(t);
      case _.INT:
        return this.advanceLexer(), this.node(r, {
          kind: F.INT,
          value: r.value
        });
      case _.FLOAT:
        return this.advanceLexer(), this.node(r, {
          kind: F.FLOAT,
          value: r.value
        });
      case _.STRING:
      case _.BLOCK_STRING:
        return this.parseStringLiteral();
      case _.NAME:
        switch (this.advanceLexer(), r.value) {
          case "true":
            return this.node(r, {
              kind: F.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(r, {
              kind: F.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(r, {
              kind: F.NULL
            });
          default:
            return this.node(r, {
              kind: F.ENUM,
              value: r.value
            });
        }
      case _.DOLLAR:
        if (t)
          if (this.expectToken(_.DOLLAR), this._lexer.token.kind === _.NAME) {
            const n = this._lexer.token.value;
            throw he(
              this._lexer.source,
              r.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(r);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const t = this._lexer.token;
    return this.advanceLexer(), this.node(t, {
      kind: F.STRING,
      value: t.value,
      block: t.kind === _.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(t) {
    const r = () => this.parseValueLiteral(t);
    return this.node(this._lexer.token, {
      kind: F.LIST,
      values: this.any(_.BRACKET_L, r, _.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(t) {
    const r = () => this.parseObjectField(t);
    return this.node(this._lexer.token, {
      kind: F.OBJECT,
      fields: this.any(_.BRACE_L, r, _.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(t) {
    const r = this._lexer.token, n = this.parseName();
    return this.expectToken(_.COLON), this.node(r, {
      kind: F.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(t) {
    const r = [];
    for (; this.peek(_.AT); )
      r.push(this.parseDirective(t));
    return r;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(t) {
    const r = this._lexer.token;
    return this.expectToken(_.AT), this.node(r, {
      kind: F.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(t)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const t = this._lexer.token;
    let r;
    if (this.expectOptionalToken(_.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(_.BRACKET_R), r = this.node(t, {
        kind: F.LIST_TYPE,
        type: n
      });
    } else
      r = this.parseNamedType();
    return this.expectOptionalToken(_.BANG) ? this.node(t, {
      kind: F.NON_NULL_TYPE,
      type: r
    }) : r;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: F.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(_.STRING) || this.peek(_.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), i = this.many(
      _.BRACE_L,
      this.parseOperationTypeDefinition,
      _.BRACE_R
    );
    return this.node(t, {
      kind: F.SCHEMA_DEFINITION,
      description: r,
      directives: n,
      operationTypes: i
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const t = this._lexer.token, r = this.parseOperationType();
    this.expectToken(_.COLON);
    const n = this.parseNamedType();
    return this.node(t, {
      kind: F.OPERATION_TYPE_DEFINITION,
      operation: r,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: F.SCALAR_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), i = this.parseImplementsInterfaces(), o = this.parseConstDirectives(), s = this.parseFieldsDefinition();
    return this.node(t, {
      kind: F.OBJECT_TYPE_DEFINITION,
      description: r,
      name: n,
      interfaces: i,
      directives: o,
      fields: s
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(_.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      _.BRACE_L,
      this.parseFieldDefinition,
      _.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const t = this._lexer.token, r = this.parseDescription(), n = this.parseName(), i = this.parseArgumentDefs();
    this.expectToken(_.COLON);
    const o = this.parseTypeReference(), s = this.parseConstDirectives();
    return this.node(t, {
      kind: F.FIELD_DEFINITION,
      description: r,
      name: n,
      arguments: i,
      type: o,
      directives: s
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      _.PAREN_L,
      this.parseInputValueDef,
      _.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const t = this._lexer.token, r = this.parseDescription(), n = this.parseName();
    this.expectToken(_.COLON);
    const i = this.parseTypeReference();
    let o;
    this.expectOptionalToken(_.EQUALS) && (o = this.parseConstValueLiteral());
    const s = this.parseConstDirectives();
    return this.node(t, {
      kind: F.INPUT_VALUE_DEFINITION,
      description: r,
      name: n,
      type: i,
      defaultValue: o,
      directives: s
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), i = this.parseImplementsInterfaces(), o = this.parseConstDirectives(), s = this.parseFieldsDefinition();
    return this.node(t, {
      kind: F.INTERFACE_TYPE_DEFINITION,
      description: r,
      name: n,
      interfaces: i,
      directives: o,
      fields: s
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), i = this.parseConstDirectives(), o = this.parseUnionMemberTypes();
    return this.node(t, {
      kind: F.UNION_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i,
      types: o
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(_.EQUALS) ? this.delimitedMany(_.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), i = this.parseConstDirectives(), o = this.parseEnumValuesDefinition();
    return this.node(t, {
      kind: F.ENUM_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i,
      values: o
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      _.BRACE_L,
      this.parseEnumValueDefinition,
      _.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const t = this._lexer.token, r = this.parseDescription(), n = this.parseEnumValueName(), i = this.parseConstDirectives();
    return this.node(t, {
      kind: F.ENUM_VALUE_DEFINITION,
      description: r,
      name: n,
      directives: i
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw he(
        this._lexer.source,
        this._lexer.token.start,
        `${wt(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), i = this.parseConstDirectives(), o = this.parseInputFieldsDefinition();
    return this.node(t, {
      kind: F.INPUT_OBJECT_TYPE_DEFINITION,
      description: r,
      name: n,
      directives: i,
      fields: o
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      _.BRACE_L,
      this.parseInputValueDef,
      _.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const t = this._lexer.lookahead();
    if (t.kind === _.NAME)
      switch (t.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(t);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const r = this.parseConstDirectives(), n = this.optionalMany(
      _.BRACE_L,
      this.parseOperationTypeDefinition,
      _.BRACE_R
    );
    if (r.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: F.SCHEMA_EXTENSION,
      directives: r,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const r = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: F.SCALAR_TYPE_EXTENSION,
      name: r,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const r = this.parseName(), n = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    if (n.length === 0 && i.length === 0 && o.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: F.OBJECT_TYPE_EXTENSION,
      name: r,
      interfaces: n,
      directives: i,
      fields: o
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const r = this.parseName(), n = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    if (n.length === 0 && i.length === 0 && o.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: F.INTERFACE_TYPE_EXTENSION,
      name: r,
      interfaces: n,
      directives: i,
      fields: o
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const r = this.parseName(), n = this.parseConstDirectives(), i = this.parseUnionMemberTypes();
    if (n.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: F.UNION_TYPE_EXTENSION,
      name: r,
      directives: n,
      types: i
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const r = this.parseName(), n = this.parseConstDirectives(), i = this.parseEnumValuesDefinition();
    if (n.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: F.ENUM_TYPE_EXTENSION,
      name: r,
      directives: n,
      values: i
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const r = this.parseName(), n = this.parseConstDirectives(), i = this.parseInputFieldsDefinition();
    if (n.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: F.INPUT_OBJECT_TYPE_EXTENSION,
      name: r,
      directives: n,
      fields: i
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const t = this._lexer.token, r = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(_.AT);
    const n = this.parseName(), i = this.parseArgumentDefs(), o = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const s = this.parseDirectiveLocations();
    return this.node(t, {
      kind: F.DIRECTIVE_DEFINITION,
      description: r,
      name: n,
      arguments: i,
      repeatable: o,
      locations: s
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(_.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const t = this._lexer.token, r = this.parseName();
    if (Object.prototype.hasOwnProperty.call(Dr, r.value))
      return r;
    throw this.unexpected(t);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(t, r) {
    return this._options.noLocation !== !0 && (r.loc = new Bu(
      t,
      this._lexer.lastToken,
      this._lexer.source
    )), r;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(t) {
    return this._lexer.token.kind === t;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(t) {
    const r = this._lexer.token;
    if (r.kind === t)
      return this.advanceLexer(), r;
    throw he(
      this._lexer.source,
      r.start,
      `Expected ${mo(t)}, found ${wt(r)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(t) {
    return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(t) {
    const r = this._lexer.token;
    if (r.kind === _.NAME && r.value === t)
      this.advanceLexer();
    else
      throw he(
        this._lexer.source,
        r.start,
        `Expected "${t}", found ${wt(r)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(t) {
    const r = this._lexer.token;
    return r.kind === _.NAME && r.value === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(t) {
    const r = t ?? this._lexer.token;
    return he(
      this._lexer.source,
      r.start,
      `Unexpected ${wt(r)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(t, r, n) {
    this.expectToken(t);
    const i = [];
    for (; !this.expectOptionalToken(n); )
      i.push(r.call(this));
    return i;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(t, r, n) {
    if (this.expectOptionalToken(t)) {
      const i = [];
      do
        i.push(r.call(this));
      while (!this.expectOptionalToken(n));
      return i;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(t, r, n) {
    this.expectToken(t);
    const i = [];
    do
      i.push(r.call(this));
    while (!this.expectOptionalToken(n));
    return i;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(t, r) {
    this.expectOptionalToken(t);
    const n = [];
    do
      n.push(r.call(this));
    while (this.expectOptionalToken(t));
    return n;
  }
  advanceLexer() {
    const { maxTokens: t } = this._options, r = this._lexer.advance();
    if (t !== void 0 && r.kind !== _.EOF && (++this._tokenCounter, this._tokenCounter > t))
      throw he(
        this._lexer.source,
        r.start,
        `Document contains more that ${t} tokens. Parsing aborted.`
      );
  }
}
function wt(e) {
  const t = e.value;
  return mo(e.kind) + (t != null ? ` "${t}"` : "");
}
function mo(e) {
  return Hu(e) ? `"${e}"` : e;
}
function vc(e) {
  return `"${e.replace(mc, gc)}"`;
}
const mc = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function gc(e) {
  return bc[e.charCodeAt(0)];
}
const bc = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], Ec = Object.freeze({});
function Sc(e, t, r = co) {
  const n = /* @__PURE__ */ new Map();
  for (const O of Object.values(F))
    n.set(O, Oc(t, O));
  let i, o = Array.isArray(e), s = [e], a = -1, u = [], c = e, l, f;
  const d = [], h = [];
  do {
    a++;
    const O = a === s.length, x = O && u.length !== 0;
    if (O) {
      if (l = h.length === 0 ? void 0 : d[d.length - 1], c = f, f = h.pop(), x)
        if (o) {
          c = c.slice();
          let m = 0;
          for (const [b, w] of u) {
            const R = b - m;
            w === null ? (c.splice(R, 1), m++) : c[R] = w;
          }
        } else {
          c = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(c)
          );
          for (const [m, b] of u)
            c[m] = b;
        }
      a = i.index, s = i.keys, u = i.edits, o = i.inArray, i = i.prev;
    } else if (f) {
      if (l = o ? a : s[a], c = f[l], c == null)
        continue;
      d.push(l);
    }
    let S;
    if (!Array.isArray(c)) {
      var y, E;
      ci(c) || xt(!1, `Invalid AST Node: ${Xr(c)}.`);
      const m = O ? (y = n.get(c.kind)) === null || y === void 0 ? void 0 : y.leave : (E = n.get(c.kind)) === null || E === void 0 ? void 0 : E.enter;
      if (S = m == null ? void 0 : m.call(t, c, l, f, d, h), S === Ec)
        break;
      if (S === !1) {
        if (!O) {
          d.pop();
          continue;
        }
      } else if (S !== void 0 && (u.push([l, S]), !O))
        if (ci(S))
          c = S;
        else {
          d.pop();
          continue;
        }
    }
    if (S === void 0 && x && u.push([l, c]), O)
      d.pop();
    else {
      var v;
      i = {
        inArray: o,
        index: a,
        keys: s,
        edits: u,
        prev: i
      }, o = Array.isArray(c), s = o ? c : (v = r[c.kind]) !== null && v !== void 0 ? v : [], a = -1, u = [], f && h.push(f), f = c;
    }
  } while (i !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : e;
}
function Oc(e, t) {
  const r = e[t];
  return typeof r == "object" ? r : typeof r == "function" ? {
    enter: r,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function wc(e) {
  return Sc(e, _c);
}
const Tc = 80, _c = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => P(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const t = Q("(", P(e.variableDefinitions, ", "), ")"), r = P(
        [
          e.operation,
          P([e.name, t]),
          P(e.directives, " ")
        ],
        " "
      );
      return (r === "query" ? "" : r + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: t, defaultValue: r, directives: n }) => e + ": " + t + Q(" = ", r) + Q(" ", P(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => _e(e)
  },
  Field: {
    leave({ alias: e, name: t, arguments: r, directives: n, selectionSet: i }) {
      const o = Q("", e, ": ") + t;
      let s = o + Q("(", P(r, ", "), ")");
      return s.length > Tc && (s = o + Q(`(
`, Ct(P(r, `
`)), `
)`)), P([s, P(n, " "), i], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: t }) => "..." + e + Q(" ", P(t, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: t, selectionSet: r }) => P(
      [
        "...",
        Q("on ", e),
        P(t, " "),
        r
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: e, typeCondition: t, variableDefinitions: r, directives: n, selectionSet: i }) => (
      // or removed in the future.
      `fragment ${e}${Q("(", P(r, ", "), ")")} on ${t} ${Q("", P(n, " "), " ")}` + i
    )
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: t }) => t ? Gu(e) : vc(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + P(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + P(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: t }) => "@" + e + Q("(", P(t, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: t, operationTypes: r }) => Q("", e, `
`) + P(["schema", P(t, " "), _e(r)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: t }) => e + ": " + t
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: t, directives: r }) => Q("", e, `
`) + P(["scalar", t, P(r, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: r, directives: n, fields: i }) => Q("", e, `
`) + P(
      [
        "type",
        t,
        Q("implements ", P(r, " & ")),
        P(n, " "),
        _e(i)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: t, arguments: r, type: n, directives: i }) => Q("", e, `
`) + t + (fi(r) ? Q(`(
`, Ct(P(r, `
`)), `
)`) : Q("(", P(r, ", "), ")")) + ": " + n + Q(" ", P(i, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: t, type: r, defaultValue: n, directives: i }) => Q("", e, `
`) + P(
      [t + ": " + r, Q("= ", n), P(i, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: r, directives: n, fields: i }) => Q("", e, `
`) + P(
      [
        "interface",
        t,
        Q("implements ", P(r, " & ")),
        P(n, " "),
        _e(i)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: t, directives: r, types: n }) => Q("", e, `
`) + P(
      ["union", t, P(r, " "), Q("= ", P(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: t, directives: r, values: n }) => Q("", e, `
`) + P(["enum", t, P(r, " "), _e(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: t, directives: r }) => Q("", e, `
`) + P([t, P(r, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: t, directives: r, fields: n }) => Q("", e, `
`) + P(["input", t, P(r, " "), _e(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: t, arguments: r, repeatable: n, locations: i }) => Q("", e, `
`) + "directive @" + t + (fi(r) ? Q(`(
`, Ct(P(r, `
`)), `
)`) : Q("(", P(r, ", "), ")")) + (n ? " repeatable" : "") + " on " + P(i, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: t }) => P(
      ["extend schema", P(e, " "), _e(t)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: t }) => P(["extend scalar", e, P(t, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: r, fields: n }) => P(
      [
        "extend type",
        e,
        Q("implements ", P(t, " & ")),
        P(r, " "),
        _e(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: r, fields: n }) => P(
      [
        "extend interface",
        e,
        Q("implements ", P(t, " & ")),
        P(r, " "),
        _e(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: t, types: r }) => P(
      [
        "extend union",
        e,
        P(t, " "),
        Q("= ", P(r, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: t, values: r }) => P(["extend enum", e, P(t, " "), _e(r)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: t, fields: r }) => P(["extend input", e, P(t, " "), _e(r)], " ")
  }
};
function P(e, t = "") {
  var r;
  return (r = e == null ? void 0 : e.filter((n) => n).join(t)) !== null && r !== void 0 ? r : "";
}
function _e(e) {
  return Q(`{
`, Ct(P(e, `
`)), `
}`);
}
function Q(e, t, r = "") {
  return t != null && t !== "" ? e + t + r : "";
}
function Ct(e) {
  return Q("  ", e.replace(/\n/g, `
  `));
}
function fi(e) {
  var t;
  return (t = e == null ? void 0 : e.some((r) => r.includes(`
`))) !== null && t !== void 0 ? t : !1;
}
const di = (e) => {
  var n, i;
  let t;
  const r = e.definitions.filter((o) => o.kind === "OperationDefinition");
  return r.length === 1 && (t = (i = (n = r[0]) == null ? void 0 : n.name) == null ? void 0 : i.value), t;
}, hr = (e) => {
  if (typeof e == "string") {
    let r;
    try {
      const n = pc(e);
      r = di(n);
    } catch {
    }
    return { query: e, operationName: r };
  }
  const t = di(e);
  return { query: wc(e), operationName: t };
};
class vt extends Error {
  constructor(t, r) {
    const n = `${vt.extractMessage(t)}: ${JSON.stringify({
      response: t,
      request: r
    })}`;
    super(n), Object.setPrototypeOf(this, vt.prototype), this.response = t, this.request = r, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, vt);
  }
  static extractMessage(t) {
    var r, n;
    return ((n = (r = t.errors) == null ? void 0 : r[0]) == null ? void 0 : n.message) ?? `GraphQL Error (Code: ${t.status})`;
  }
}
var Lr = { exports: {} };
(function(e, t) {
  var r = typeof self < "u" ? self : Yo, n = function() {
    function o() {
      this.fetch = !1, this.DOMException = r.DOMException;
    }
    return o.prototype = r, new o();
  }();
  (function(o) {
    (function(s) {
      var a = {
        searchParams: "URLSearchParams" in o,
        iterable: "Symbol" in o && "iterator" in Symbol,
        blob: "FileReader" in o && "Blob" in o && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in o,
        arrayBuffer: "ArrayBuffer" in o
      };
      function u(g) {
        return g && DataView.prototype.isPrototypeOf(g);
      }
      if (a.arrayBuffer)
        var c = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], l = ArrayBuffer.isView || function(g) {
          return g && c.indexOf(Object.prototype.toString.call(g)) > -1;
        };
      function f(g) {
        if (typeof g != "string" && (g = String(g)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(g))
          throw new TypeError("Invalid character in header field name");
        return g.toLowerCase();
      }
      function d(g) {
        return typeof g != "string" && (g = String(g)), g;
      }
      function h(g) {
        var T = {
          next: function() {
            var N = g.shift();
            return { done: N === void 0, value: N };
          }
        };
        return a.iterable && (T[Symbol.iterator] = function() {
          return T;
        }), T;
      }
      function y(g) {
        this.map = {}, g instanceof y ? g.forEach(function(T, N) {
          this.append(N, T);
        }, this) : Array.isArray(g) ? g.forEach(function(T) {
          this.append(T[0], T[1]);
        }, this) : g && Object.getOwnPropertyNames(g).forEach(function(T) {
          this.append(T, g[T]);
        }, this);
      }
      y.prototype.append = function(g, T) {
        g = f(g), T = d(T);
        var N = this.map[g];
        this.map[g] = N ? N + ", " + T : T;
      }, y.prototype.delete = function(g) {
        delete this.map[f(g)];
      }, y.prototype.get = function(g) {
        return g = f(g), this.has(g) ? this.map[g] : null;
      }, y.prototype.has = function(g) {
        return this.map.hasOwnProperty(f(g));
      }, y.prototype.set = function(g, T) {
        this.map[f(g)] = d(T);
      }, y.prototype.forEach = function(g, T) {
        for (var N in this.map)
          this.map.hasOwnProperty(N) && g.call(T, this.map[N], N, this);
      }, y.prototype.keys = function() {
        var g = [];
        return this.forEach(function(T, N) {
          g.push(N);
        }), h(g);
      }, y.prototype.values = function() {
        var g = [];
        return this.forEach(function(T) {
          g.push(T);
        }), h(g);
      }, y.prototype.entries = function() {
        var g = [];
        return this.forEach(function(T, N) {
          g.push([N, T]);
        }), h(g);
      }, a.iterable && (y.prototype[Symbol.iterator] = y.prototype.entries);
      function E(g) {
        if (g.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        g.bodyUsed = !0;
      }
      function v(g) {
        return new Promise(function(T, N) {
          g.onload = function() {
            T(g.result);
          }, g.onerror = function() {
            N(g.error);
          };
        });
      }
      function O(g) {
        var T = new FileReader(), N = v(T);
        return T.readAsArrayBuffer(g), N;
      }
      function x(g) {
        var T = new FileReader(), N = v(T);
        return T.readAsText(g), N;
      }
      function S(g) {
        for (var T = new Uint8Array(g), N = new Array(T.length), D = 0; D < T.length; D++)
          N[D] = String.fromCharCode(T[D]);
        return N.join("");
      }
      function m(g) {
        if (g.slice)
          return g.slice(0);
        var T = new Uint8Array(g.byteLength);
        return T.set(new Uint8Array(g)), T.buffer;
      }
      function b() {
        return this.bodyUsed = !1, this._initBody = function(g) {
          this._bodyInit = g, g ? typeof g == "string" ? this._bodyText = g : a.blob && Blob.prototype.isPrototypeOf(g) ? this._bodyBlob = g : a.formData && FormData.prototype.isPrototypeOf(g) ? this._bodyFormData = g : a.searchParams && URLSearchParams.prototype.isPrototypeOf(g) ? this._bodyText = g.toString() : a.arrayBuffer && a.blob && u(g) ? (this._bodyArrayBuffer = m(g.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(g) || l(g)) ? this._bodyArrayBuffer = m(g) : this._bodyText = g = Object.prototype.toString.call(g) : this._bodyText = "", this.headers.get("content-type") || (typeof g == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(g) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, a.blob && (this.blob = function() {
          var g = E(this);
          if (g)
            return g;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? E(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(O);
        }), this.text = function() {
          var g = E(this);
          if (g)
            return g;
          if (this._bodyBlob)
            return x(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(S(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, a.formData && (this.formData = function() {
          return this.text().then(M);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var w = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function R(g) {
        var T = g.toUpperCase();
        return w.indexOf(T) > -1 ? T : g;
      }
      function C(g, T) {
        T = T || {};
        var N = T.body;
        if (g instanceof C) {
          if (g.bodyUsed)
            throw new TypeError("Already read");
          this.url = g.url, this.credentials = g.credentials, T.headers || (this.headers = new y(g.headers)), this.method = g.method, this.mode = g.mode, this.signal = g.signal, !N && g._bodyInit != null && (N = g._bodyInit, g.bodyUsed = !0);
        } else
          this.url = String(g);
        if (this.credentials = T.credentials || this.credentials || "same-origin", (T.headers || !this.headers) && (this.headers = new y(T.headers)), this.method = R(T.method || this.method || "GET"), this.mode = T.mode || this.mode || null, this.signal = T.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && N)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(N);
      }
      C.prototype.clone = function() {
        return new C(this, { body: this._bodyInit });
      };
      function M(g) {
        var T = new FormData();
        return g.trim().split("&").forEach(function(N) {
          if (N) {
            var D = N.split("="), j = D.shift().replace(/\+/g, " "), V = D.join("=").replace(/\+/g, " ");
            T.append(decodeURIComponent(j), decodeURIComponent(V));
          }
        }), T;
      }
      function $(g) {
        var T = new y(), N = g.replace(/\r?\n[\t ]+/g, " ");
        return N.split(/\r?\n/).forEach(function(D) {
          var j = D.split(":"), V = j.shift().trim();
          if (V) {
            var B = j.join(":").trim();
            T.append(V, B);
          }
        }), T;
      }
      b.call(C.prototype);
      function U(g, T) {
        T || (T = {}), this.type = "default", this.status = T.status === void 0 ? 200 : T.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in T ? T.statusText : "OK", this.headers = new y(T.headers), this.url = T.url || "", this._initBody(g);
      }
      b.call(U.prototype), U.prototype.clone = function() {
        return new U(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new y(this.headers),
          url: this.url
        });
      }, U.error = function() {
        var g = new U(null, { status: 0, statusText: "" });
        return g.type = "error", g;
      };
      var z = [301, 302, 303, 307, 308];
      U.redirect = function(g, T) {
        if (z.indexOf(T) === -1)
          throw new RangeError("Invalid status code");
        return new U(null, { status: T, headers: { location: g } });
      }, s.DOMException = o.DOMException;
      try {
        new s.DOMException();
      } catch {
        s.DOMException = function(T, N) {
          this.message = T, this.name = N;
          var D = Error(T);
          this.stack = D.stack;
        }, s.DOMException.prototype = Object.create(Error.prototype), s.DOMException.prototype.constructor = s.DOMException;
      }
      function te(g, T) {
        return new Promise(function(N, D) {
          var j = new C(g, T);
          if (j.signal && j.signal.aborted)
            return D(new s.DOMException("Aborted", "AbortError"));
          var V = new XMLHttpRequest();
          function B() {
            V.abort();
          }
          V.onload = function() {
            var le = {
              status: V.status,
              statusText: V.statusText,
              headers: $(V.getAllResponseHeaders() || "")
            };
            le.url = "responseURL" in V ? V.responseURL : le.headers.get("X-Request-URL");
            var pe = "response" in V ? V.response : V.responseText;
            N(new U(pe, le));
          }, V.onerror = function() {
            D(new TypeError("Network request failed"));
          }, V.ontimeout = function() {
            D(new TypeError("Network request failed"));
          }, V.onabort = function() {
            D(new s.DOMException("Aborted", "AbortError"));
          }, V.open(j.method, j.url, !0), j.credentials === "include" ? V.withCredentials = !0 : j.credentials === "omit" && (V.withCredentials = !1), "responseType" in V && a.blob && (V.responseType = "blob"), j.headers.forEach(function(le, pe) {
            V.setRequestHeader(pe, le);
          }), j.signal && (j.signal.addEventListener("abort", B), V.onreadystatechange = function() {
            V.readyState === 4 && j.signal.removeEventListener("abort", B);
          }), V.send(typeof j._bodyInit > "u" ? null : j._bodyInit);
        });
      }
      return te.polyfill = !0, o.fetch || (o.fetch = te, o.Headers = y, o.Request = C, o.Response = U), s.Headers = y, s.Request = C, s.Response = U, s.fetch = te, Object.defineProperty(s, "__esModule", { value: !0 }), s;
    })({});
  })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
  var i = n;
  t = i.fetch, t.default = i.fetch, t.fetch = i.fetch, t.Headers = i.Headers, t.Request = i.Request, t.Response = i.Response, e.exports = t;
})(Lr, Lr.exports);
var Lt = Lr.exports;
const Rt = /* @__PURE__ */ vi(Lt), xc = /* @__PURE__ */ Qo({
  __proto__: null,
  default: Rt
}, [Lt]), Xe = (e) => {
  let t = {};
  return e && (typeof Headers < "u" && e instanceof Headers || xc && Lt.Headers && e instanceof Lt.Headers ? t = ku(e) : Array.isArray(e) ? e.forEach(([r, n]) => {
    r && n !== void 0 && (t[r] = n);
  }) : t = e), t;
}, hi = (e) => e.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), Cc = (e) => {
  if (!Array.isArray(e.query)) {
    const n = e, i = [`query=${encodeURIComponent(hi(n.query))}`];
    return e.variables && i.push(`variables=${encodeURIComponent(n.jsonSerializer.stringify(n.variables))}`), n.operationName && i.push(`operationName=${encodeURIComponent(n.operationName)}`), i.join("&");
  }
  if (typeof e.variables < "u" && !Array.isArray(e.variables))
    throw new Error("Cannot create query with given variable type, array expected");
  const t = e, r = e.query.reduce((n, i, o) => (n.push({
    query: hi(i),
    variables: t.variables ? t.jsonSerializer.stringify(t.variables[o]) : void 0
  }), n), []);
  return `query=${encodeURIComponent(t.jsonSerializer.stringify(r))}`;
}, Rc = (e) => async (t) => {
  const { url: r, query: n, variables: i, operationName: o, fetch: s, fetchOptions: a, middleware: u } = t, c = { ...t.headers };
  let l = "", f;
  e === "POST" ? (f = Ac(n, i, o, a.jsonSerializer), typeof f == "string" && (c["Content-Type"] = "application/json")) : l = Cc({
    query: n,
    variables: i,
    operationName: o,
    jsonSerializer: a.jsonSerializer ?? Hr
  });
  const d = {
    method: e,
    headers: c,
    body: f,
    ...a
  };
  let h = r, y = d;
  if (u) {
    const E = await Promise.resolve(u({ ...d, url: r, operationName: o, variables: i })), { url: v, ...O } = E;
    h = v, y = O;
  }
  return l && (h = `${h}?${l}`), await s(h, y);
};
class go {
  constructor(t, r = {}) {
    this.url = t, this.requestConfig = r, this.rawRequest = async (...n) => {
      const [i, o, s] = n, a = Mu(i, o, s), { headers: u, fetch: c = Rt, method: l = "POST", requestMiddleware: f, responseMiddleware: d, ...h } = this.requestConfig, { url: y } = this;
      a.signal !== void 0 && (h.signal = a.signal);
      const { operationName: E } = hr(a.query);
      return pr({
        url: y,
        query: a.query,
        variables: a.variables,
        headers: {
          ...Xe(yr(u)),
          ...Xe(a.requestHeaders)
        },
        operationName: E,
        fetch: c,
        method: l,
        fetchOptions: h,
        middleware: f
      }).then((v) => (d && d(v), v)).catch((v) => {
        throw d && d(v), v;
      });
    };
  }
  async request(t, ...r) {
    const [n, i] = r, o = Lu(t, n, i), { headers: s, fetch: a = Rt, method: u = "POST", requestMiddleware: c, responseMiddleware: l, ...f } = this.requestConfig, { url: d } = this;
    o.signal !== void 0 && (f.signal = o.signal);
    const { query: h, operationName: y } = hr(o.document);
    return pr({
      url: d,
      query: h,
      variables: o.variables,
      headers: {
        ...Xe(yr(s)),
        ...Xe(o.requestHeaders)
      },
      operationName: y,
      fetch: a,
      method: u,
      fetchOptions: f,
      middleware: c
    }).then((E) => (l && l(E), E.data)).catch((E) => {
      throw l && l(E), E;
    });
  }
  // prettier-ignore
  batchRequests(t, r) {
    const n = Fu(t, r), { headers: i, ...o } = this.requestConfig;
    n.signal !== void 0 && (o.signal = n.signal);
    const s = n.documents.map(({ document: u }) => hr(u).query), a = n.documents.map(({ variables: u }) => u);
    return pr({
      url: this.url,
      query: s,
      // @ts-expect-error TODO reconcile batch variables into system.
      variables: a,
      headers: {
        ...Xe(yr(i)),
        ...Xe(n.requestHeaders)
      },
      operationName: void 0,
      fetch: this.requestConfig.fetch ?? Rt,
      method: this.requestConfig.method || "POST",
      fetchOptions: o,
      middleware: this.requestConfig.requestMiddleware
    }).then((u) => (this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u.data)).catch((u) => {
      throw this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u;
    });
  }
  setHeaders(t) {
    return this.requestConfig.headers = t, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(t, r) {
    const { headers: n } = this.requestConfig;
    return n ? n[t] = r : this.requestConfig.headers = { [t]: r }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(t) {
    return this.url = t, this;
  }
}
const pr = async (e) => {
  const { query: t, variables: r, fetchOptions: n } = e, i = Rc(Du(e.method ?? "post")), o = Array.isArray(e.query), s = await i(e), a = await Nc(s, n.jsonSerializer ?? Hr), u = Array.isArray(a) ? !a.some(({ data: l }) => !l) : !!a.data, c = Array.isArray(a) || !a.errors || Array.isArray(a.errors) && !a.errors.length || n.errorPolicy === "all" || n.errorPolicy === "ignore";
  if (s.ok && c && u) {
    const { errors: l, ...f } = (Array.isArray(a), a), d = n.errorPolicy === "ignore" ? f : a;
    return {
      ...o ? { data: d } : d,
      headers: s.headers,
      status: s.status
    };
  } else {
    const l = typeof a == "string" ? {
      error: a
    } : a;
    throw new vt(
      // @ts-expect-error TODO
      { ...l, status: s.status, headers: s.headers },
      { query: t, variables: r }
    );
  }
}, Ac = (e, t, r, n) => {
  const i = n ?? Hr;
  if (!Array.isArray(e))
    return i.stringify({ query: e, variables: t, operationName: r });
  if (typeof t < "u" && !Array.isArray(t))
    throw new Error("Cannot create request body with given variable type, array expected");
  const o = e.reduce((s, a, u) => (s.push({ query: a, variables: t ? t[u] : void 0 }), s), []);
  return i.stringify(o);
}, Nc = async (e, t) => {
  let r;
  return e.headers.forEach((n, i) => {
    i.toLowerCase() === "content-type" && (r = n);
  }), r && (r.toLowerCase().startsWith("application/json") || r.toLowerCase().startsWith("application/graphql+json") || r.toLowerCase().startsWith("application/graphql-response+json")) ? t.parse(await e.text()) : e.text();
}, yr = (e) => typeof e == "function" ? e() : e;
function me(e) {
  return e === null ? "null" : Array.isArray(e) ? "array" : typeof e;
}
function Qe(e) {
  return me(e) === "object";
}
function Ic(e) {
  return Array.isArray(e) && // must be at least one error
  e.length > 0 && // error has at least a message
  e.every((t) => "message" in t);
}
function pi(e, t) {
  return e.length < 124 ? e : t;
}
const Pc = "graphql-transport-ws";
var be;
(function(e) {
  e[e.InternalServerError = 4500] = "InternalServerError", e[e.InternalClientError = 4005] = "InternalClientError", e[e.BadRequest = 4400] = "BadRequest", e[e.BadResponse = 4004] = "BadResponse", e[e.Unauthorized = 4401] = "Unauthorized", e[e.Forbidden = 4403] = "Forbidden", e[e.SubprotocolNotAcceptable = 4406] = "SubprotocolNotAcceptable", e[e.ConnectionInitialisationTimeout = 4408] = "ConnectionInitialisationTimeout", e[e.ConnectionAcknowledgementTimeout = 4504] = "ConnectionAcknowledgementTimeout", e[e.SubscriberAlreadyExists = 4409] = "SubscriberAlreadyExists", e[e.TooManyInitialisationRequests = 4429] = "TooManyInitialisationRequests";
})(be || (be = {}));
var se;
(function(e) {
  e.ConnectionInit = "connection_init", e.ConnectionAck = "connection_ack", e.Ping = "ping", e.Pong = "pong", e.Subscribe = "subscribe", e.Next = "next", e.Error = "error", e.Complete = "complete";
})(se || (se = {}));
function bo(e) {
  if (!Qe(e))
    throw new Error(`Message is expected to be an object, but got ${me(e)}`);
  if (!e.type)
    throw new Error("Message is missing the 'type' property");
  if (typeof e.type != "string")
    throw new Error(`Message is expects the 'type' property to be a string, but got ${me(e.type)}`);
  switch (e.type) {
    case se.ConnectionInit:
    case se.ConnectionAck:
    case se.Ping:
    case se.Pong: {
      if (e.payload != null && !Qe(e.payload))
        throw new Error(`"${e.type}" message expects the 'payload' property to be an object or nullish or missing, but got "${e.payload}"`);
      break;
    }
    case se.Subscribe: {
      if (typeof e.id != "string")
        throw new Error(`"${e.type}" message expects the 'id' property to be a string, but got ${me(e.id)}`);
      if (!e.id)
        throw new Error(`"${e.type}" message requires a non-empty 'id' property`);
      if (!Qe(e.payload))
        throw new Error(`"${e.type}" message expects the 'payload' property to be an object, but got ${me(e.payload)}`);
      if (typeof e.payload.query != "string")
        throw new Error(`"${e.type}" message payload expects the 'query' property to be a string, but got ${me(e.payload.query)}`);
      if (e.payload.variables != null && !Qe(e.payload.variables))
        throw new Error(`"${e.type}" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${me(e.payload.variables)}`);
      if (e.payload.operationName != null && me(e.payload.operationName) !== "string")
        throw new Error(`"${e.type}" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${me(e.payload.operationName)}`);
      if (e.payload.extensions != null && !Qe(e.payload.extensions))
        throw new Error(`"${e.type}" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${me(e.payload.extensions)}`);
      break;
    }
    case se.Next: {
      if (typeof e.id != "string")
        throw new Error(`"${e.type}" message expects the 'id' property to be a string, but got ${me(e.id)}`);
      if (!e.id)
        throw new Error(`"${e.type}" message requires a non-empty 'id' property`);
      if (!Qe(e.payload))
        throw new Error(`"${e.type}" message expects the 'payload' property to be an object, but got ${me(e.payload)}`);
      break;
    }
    case se.Error: {
      if (typeof e.id != "string")
        throw new Error(`"${e.type}" message expects the 'id' property to be a string, but got ${me(e.id)}`);
      if (!e.id)
        throw new Error(`"${e.type}" message requires a non-empty 'id' property`);
      if (!Ic(e.payload))
        throw new Error(`"${e.type}" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(e.payload)}`);
      break;
    }
    case se.Complete: {
      if (typeof e.id != "string")
        throw new Error(`"${e.type}" message expects the 'id' property to be a string, but got ${me(e.id)}`);
      if (!e.id)
        throw new Error(`"${e.type}" message requires a non-empty 'id' property`);
      break;
    }
    default:
      throw new Error(`Invalid message 'type' property "${e.type}"`);
  }
  return e;
}
function Dc(e, t) {
  return bo(typeof e == "string" ? JSON.parse(e, t) : e);
}
function ft(e, t) {
  return bo(e), JSON.stringify(e, t);
}
function kc(e) {
  const {
    url: t,
    connectionParams: r,
    lazy: n = !0,
    onNonLazyError: i = console.error,
    lazyCloseTimeout: o = 0,
    keepAlive: s = 0,
    disablePong: a,
    connectionAckWaitTimeout: u = 0,
    retryAttempts: c = 5,
    retryWait: l = async function(T) {
      let N = 1e3;
      for (let D = 0; D < T; D++)
        N *= 2;
      await new Promise((D) => setTimeout(D, N + // add random timeout from 300ms to 3s
      Math.floor(Math.random() * (3e3 - 300) + 300)));
    },
    shouldRetry: f = Tt,
    isFatalConnectionProblem: d,
    on: h,
    webSocketImpl: y,
    /**
     * Generates a v4 UUID to be used as the ID using `Math`
     * as the random number generator. Supply your own generator
     * in case you need more uniqueness.
     *
     * Reference: https://gist.github.com/jed/982883
     */
    generateID: E = function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (T) => {
        const N = Math.random() * 16 | 0;
        return (T == "x" ? N : N & 3 | 8).toString(16);
      });
    },
    jsonMessageReplacer: v,
    jsonMessageReviver: O
  } = e;
  let x;
  if (y) {
    if (!Mc(y))
      throw new Error("Invalid WebSocket implementation provided");
    x = y;
  } else
    typeof WebSocket < "u" ? x = WebSocket : typeof global < "u" ? x = global.WebSocket || // @ts-expect-error: Support more browsers
    global.MozWebSocket : typeof window < "u" && (x = window.WebSocket || // @ts-expect-error: Support more browsers
    window.MozWebSocket);
  if (!x)
    throw new Error("WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`");
  const S = x, m = (() => {
    const g = (() => {
      const N = {};
      return {
        on(D, j) {
          return N[D] = j, () => {
            delete N[D];
          };
        },
        emit(D) {
          var j;
          "id" in D && ((j = N[D.id]) === null || j === void 0 || j.call(N, D));
        }
      };
    })(), T = {
      connecting: h != null && h.connecting ? [h.connecting] : [],
      opened: h != null && h.opened ? [h.opened] : [],
      connected: h != null && h.connected ? [h.connected] : [],
      ping: h != null && h.ping ? [h.ping] : [],
      pong: h != null && h.pong ? [h.pong] : [],
      message: h != null && h.message ? [g.emit, h.message] : [g.emit],
      closed: h != null && h.closed ? [h.closed] : [],
      error: h != null && h.error ? [h.error] : []
    };
    return {
      onMessage: g.on,
      on(N, D) {
        const j = T[N];
        return j.push(D), () => {
          j.splice(j.indexOf(D), 1);
        };
      },
      emit(N, ...D) {
        for (const j of [...T[N]])
          j(...D);
      }
    };
  })();
  function b(g) {
    const T = [
      // errors are fatal and more critical than close events, throw them first
      m.on("error", (N) => {
        T.forEach((D) => D()), g(N);
      }),
      // closes can be graceful and not fatal, throw them second (if error didnt throw)
      m.on("closed", (N) => {
        T.forEach((D) => D()), g(N);
      })
    ];
  }
  let w, R = 0, C, M = !1, $ = 0, U = !1;
  async function z() {
    clearTimeout(C);
    const [g, T] = await (w ?? (w = new Promise((j, V) => (async () => {
      if (M) {
        if (await l($), !R)
          return w = void 0, V({ code: 1e3, reason: "All Subscriptions Gone" });
        $++;
      }
      m.emit("connecting");
      const B = new S(typeof t == "function" ? await t() : t, Pc);
      let le, pe;
      function we() {
        isFinite(s) && s > 0 && (clearTimeout(pe), pe = setTimeout(() => {
          B.readyState === S.OPEN && (B.send(ft({ type: se.Ping })), m.emit("ping", !1, void 0));
        }, s));
      }
      b((ne) => {
        w = void 0, clearTimeout(le), clearTimeout(pe), V(ne), Tt(ne) && ne.code === 4499 && (B.close(4499, "Terminated"), B.onerror = null, B.onclose = null);
      }), B.onerror = (ne) => m.emit("error", ne), B.onclose = (ne) => m.emit("closed", ne), B.onopen = async () => {
        try {
          m.emit("opened", B);
          const ne = typeof r == "function" ? await r() : r;
          if (B.readyState !== S.OPEN)
            return;
          B.send(ft(ne ? {
            type: se.ConnectionInit,
            payload: ne
          } : {
            type: se.ConnectionInit
            // payload is completely absent if not provided
          }, v)), isFinite(u) && u > 0 && (le = setTimeout(() => {
            B.close(be.ConnectionAcknowledgementTimeout, "Connection acknowledgement timeout");
          }, u)), we();
        } catch (ne) {
          m.emit("error", ne), B.close(be.InternalClientError, pi(ne instanceof Error ? ne.message : new Error(ne).message, "Internal client error"));
        }
      };
      let Se = !1;
      B.onmessage = ({ data: ne }) => {
        try {
          const ee = Dc(ne, O);
          if (m.emit("message", ee), ee.type === "ping" || ee.type === "pong") {
            m.emit(ee.type, !0, ee.payload), ee.type === "pong" ? we() : a || (B.send(ft(ee.payload ? {
              type: se.Pong,
              payload: ee.payload
            } : {
              type: se.Pong
              // payload is completely absent if not provided
            })), m.emit("pong", !1, ee.payload));
            return;
          }
          if (Se)
            return;
          if (ee.type !== se.ConnectionAck)
            throw new Error(`First message cannot be of type ${ee.type}`);
          clearTimeout(le), Se = !0, m.emit("connected", B, ee.payload), M = !1, $ = 0, j([
            B,
            new Promise((Pe, xe) => b(xe))
          ]);
        } catch (ee) {
          B.onmessage = null, m.emit("error", ee), B.close(be.BadResponse, pi(ee instanceof Error ? ee.message : new Error(ee).message, "Bad response"));
        }
      };
    })())));
    g.readyState === S.CLOSING && await T;
    let N = () => {
    };
    const D = new Promise((j) => N = j);
    return [
      g,
      N,
      Promise.race([
        // wait for
        D.then(() => {
          if (!R) {
            const j = () => g.close(1e3, "Normal Closure");
            isFinite(o) && o > 0 ? C = setTimeout(() => {
              g.readyState === S.OPEN && j();
            }, o) : j();
          }
        }),
        // or
        T
      ])
    ];
  }
  function te(g) {
    if (Tt(g) && (Lc(g.code) || [
      be.InternalServerError,
      be.InternalClientError,
      be.BadRequest,
      be.BadResponse,
      be.Unauthorized,
      // CloseCode.Forbidden, might grant access out after retry
      be.SubprotocolNotAcceptable,
      // CloseCode.ConnectionInitialisationTimeout, might not time out after retry
      // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry
      be.SubscriberAlreadyExists,
      be.TooManyInitialisationRequests
      // 4499, // Terminated, probably because the socket froze, we want to retry
    ].includes(g.code)))
      throw g;
    if (U)
      return !1;
    if (Tt(g) && g.code === 1e3)
      return R > 0;
    if (!c || $ >= c || !f(g) || d != null && d(g))
      throw g;
    return M = !0;
  }
  return n || (async () => {
    for (R++; ; )
      try {
        const [, , g] = await z();
        await g;
      } catch (g) {
        try {
          if (!te(g))
            return;
        } catch (T) {
          return i == null ? void 0 : i(T);
        }
      }
  })(), {
    on: m.on,
    subscribe(g, T) {
      const N = E(g);
      let D = !1, j = !1, V = () => {
        R--, D = !0;
      };
      return (async () => {
        for (R++; ; )
          try {
            const [B, le, pe] = await z();
            if (D)
              return le();
            const we = m.onMessage(N, (Se) => {
              switch (Se.type) {
                case se.Next: {
                  T.next(Se.payload);
                  return;
                }
                case se.Error: {
                  j = !0, D = !0, T.error(Se.payload), V();
                  return;
                }
                case se.Complete: {
                  D = !0, V();
                  return;
                }
              }
            });
            B.send(ft({
              id: N,
              type: se.Subscribe,
              payload: g
            }, v)), V = () => {
              !D && B.readyState === S.OPEN && B.send(ft({
                id: N,
                type: se.Complete
              }, v)), R--, D = !0, le();
            }, await pe.finally(we);
            return;
          } catch (B) {
            if (!te(B))
              return;
          }
      })().then(() => {
        j || T.complete();
      }).catch((B) => {
        T.error(B);
      }), () => {
        D || V();
      };
    },
    async dispose() {
      if (U = !0, w) {
        const [g] = await w;
        g.close(1e3, "Normal Closure");
      }
    },
    terminate() {
      w && m.emit("closed", {
        code: 4499,
        reason: "Terminated",
        wasClean: !1
      });
    }
  };
}
function Tt(e) {
  return Qe(e) && "code" in e && "reason" in e;
}
function Lc(e) {
  return [
    1e3,
    1001,
    1006,
    1005,
    1012,
    1013,
    1013
    // Bad Gateway
  ].includes(e) ? !1 : e >= 1e3 && e <= 1999;
}
function Mc(e) {
  return typeof e == "function" && "constructor" in e && "CLOSED" in e && "CLOSING" in e && "CONNECTING" in e && "OPEN" in e;
}
const Eo = async (e, t, r) => {
  const { accessToken: n, accessTokenExpiry: i, refreshToken: o, refreshTokenExpiry: s } = ae.getState().conversation;
  r || (r = ae.getState().conversation.userData), e || (e = ae.getState().conversation.graphqlUrl), t || (t = ae.getState().conversation.workspaceId);
  const a = new go(e);
  t && a.setHeader("X-Workspace-Id", t);
  const u = Date.now();
  if (!n || !o || s && u > s)
    try {
      const c = await a.request(
        Cu,
        {
          email: r == null ? void 0 : r.email,
          name: r == null ? void 0 : r.name,
          hash: r == null ? void 0 : r.hash,
          externalId: r == null ? void 0 : r.userId
        }
      ), { accessToken: l, refreshToken: f } = c.login;
      ae.dispatch(Kn(l.token)), ae.dispatch(Hn(l.expAt * 1e3)), ae.dispatch(Va(f.token)), ae.dispatch($a(f.expAt * 1e3));
    } catch (c) {
      console.error(c);
    }
  else if (i && u > i)
    try {
      const c = await a.request(Ru, {
        refreshToken: o
      }), { accessToken: l } = c.refreshAuth;
      ae.dispatch(Kn(l.token)), ae.dispatch(Hn(l.expAt * 1e3));
    } catch (c) {
      console.error(c);
    }
}, Fc = () => {
  const e = async (n) => {
    let i = ae.getState().conversation.accessToken;
    const o = ae.getState().conversation.accessTokenExpiry, s = Date.now();
    (!i || o && s + 6e4 > o) && Eo().then(() => {
      i = ae.getState().conversation.accessToken;
    });
    const a = ae.getState().conversation.workspaceId, u = {
      Authorization: `Bearer ${i}`
    };
    return a && (u["X-Workspace-Id"] = a), {
      ...n,
      headers: { ...n.headers, ...u }
    };
  }, t = ae.getState().conversation.graphqlUrl;
  return new go(t, { requestMiddleware: e });
}, jc = () => {
  const e = ae.getState().conversation.websocketUrl, t = ae.getState().conversation.workspaceId;
  return kc({
    url: e,
    connectionParams: async () => {
      let n = ae.getState().conversation.accessToken;
      const i = ae.getState().conversation.accessTokenExpiry, o = Date.now();
      (!n || i && o + 6e4 > i) && Eo().then(() => {
        n = ae.getState().conversation.accessToken;
      });
      const s = {
        Authorization: `Bearer ${n}`
      };
      return t && (s["X-Workspace-Id"] = t), s;
    }
  });
}, So = {}, qc = (e, t) => {
  So[e] = t;
}, yi = (e) => So[e], Xc = () => {
  const e = Vs(), {
    graphqlUrl: t,
    isWidgetWindowVisible: r,
    defaultAgent: n,
    context: i,
    activeConversationId: o,
    isConversationListVisible: s,
    isEmbedConversationListVisible: a,
    data: u,
    embedData: c,
    embedDefaultAgent: l,
    embedActiveConversationId: f
  } = Is((O) => O.conversation), d = (O) => {
    o && !r ? h(o) : e(ar(O));
  }, h = async (O, x, S, m) => {
    m ? (e(fr({ embedId: m, value: null })), e(
      lr({ embedId: m, value: !1 })
    ), e(Jn(!0))) : (e(cr(null)), e(ur(!1)), e(ar(!0)));
    const b = yi(m || "widget");
    for (b && b(); t === ""; )
      await new Promise((C) => setTimeout(C, 100));
    const w = jc();
    w.on("closed", (C) => {
      C.wasClean || (e(m ? fr({ embedId: m, value: null }) : cr(null)), O === null && (w.dispose(), e(
        m ? lr({
          embedId: m,
          value: !0
        }) : ur(!0)
      )));
    });
    const R = new Promise((C, M) => {
      const $ = x || (m && l[m] ? l[m] : n), U = w.subscribe(
        {
          query: Pu,
          variables: {
            conversationId: O,
            agent: $,
            context: S
          }
        },
        {
          next: (z) => {
            var te, g;
            if (((te = z.data) == null ? void 0 : te.subscribeConversationEvents.kind) === "conversation_metadata") {
              const T = (g = z.data) == null ? void 0 : g.subscribeConversationEvents.payload.id;
              e(
                m ? Wa({
                  embedId: m,
                  value: T
                }) : Ba(T)
              ), C(T);
            }
            e(m ? fr({ embedId: m, value: z }) : cr(z));
          },
          error: (z) => M(z),
          complete: () => console.log("Subscription completed")
        }
      );
      qc(m || "widget", U);
    });
    return e(Jn(!0)), R;
  };
  return {
    context: i,
    data: u,
    embedData: c,
    isWidgetWindowVisible: r,
    isConversationListVisible: s,
    isEmbedConversationListVisible: a,
    activeConversationId: o,
    embedActiveConversationId: f,
    toggleWidgetWindow: d,
    openConversation: h,
    openConversationList: (O) => {
      O ? e(
        lr({ embedId: O, value: !0 })
      ) : (e(ur(!0)), e(ar(!0)));
    },
    updateContext: async (O, x) => {
      for (; t === ""; )
        await new Promise((S) => setTimeout(S, 200));
      await Fc().request(Nu, {
        conversationId: O,
        context: x
      }), e(Qa(x));
    },
    dropSubscription: (O) => {
      const x = yi(O || "widget");
      x && x();
    }
  };
}, Zc = Mt(() => import("./ConvoStackWidget-5e5c335c.js")), el = Mt(() => import("./ConvoStackEmbed-a887c306.js")), tl = Mt(() => import("./Message-9e7c431a.js"));
export {
  Zc as C,
  tl as M,
  Is as a,
  Hc as b,
  Fc as c,
  Jc as d,
  Vs as e,
  Eo as f,
  Wa as g,
  fr as h,
  Gc as i,
  Sn as j,
  ur as k,
  Yo as l,
  vi as m,
  Bc as n,
  $c as o,
  Qc as p,
  Wc as q,
  Yc as r,
  lr as s,
  zc as t,
  Xc as u,
  wi as v,
  mi as w,
  el as x,
  Kc as y
};
//# sourceMappingURL=index-90257461.js.map
