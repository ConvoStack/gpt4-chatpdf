interface IUser {
    id: string;
    externalId?: string;
    anonymousId?: string;
    email?: string;
    name?: string;
    createdAt: Date;
    updatedAt: Date;
}
interface IConversation {
    id: string;
    title: string;
    agent: string;
    primer?: string;
    context: string;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
}
interface IMessage {
    id: string;
    content: string;
    turn: number;
    role: string;
    pending: boolean;
    conversationId: string;
    userId?: string;
    createdAt: Date;
    updatedAt: Date;
}
interface IUserFilter {
    id?: string;
    externalId?: string;
    anonymousId?: string;
    email?: string;
}
interface IConversationFilter {
    id?: string;
    title?: string;
    agent?: string;
    primer?: string;
    userId?: string;
}
interface IMessageFilter {
    id?: string;
    content?: string;
    turn?: number;
    role?: string;
    pending?: boolean;
    conversationId?: string;
    userId?: string;
}
type IConversationOrderBy = Partial<Record<keyof IConversation, "asc" | "desc">>;
type IMessageOrderBy = Partial<Record<keyof IMessage, "asc" | "desc">>;
interface IStorageEngine {
    createUser(user: Partial<IUser>): Promise<IUser>;
    updateUser(id: string, data: Partial<IUser>): Promise<IUser>;
    findUser(filter: IUserFilter): Promise<IUser | null>;
    deleteUser(id: string): Promise<void>;
    createConversation(conversation: Partial<IConversation>): Promise<IConversation>;
    updateConversation(id: string, data: Partial<IConversation>): Promise<IConversation>;
    findConversation(filter: IConversationFilter): Promise<IConversation | null>;
    findConversations(filter?: IConversationFilter, orderBy?: IConversationOrderBy, skip?: number, take?: number): Promise<IConversation[]>;
    deleteConversation(id: string): Promise<void>;
    createMessage(message: Partial<IMessage>): Promise<IMessage>;
    updateMessage(id: string, data: Partial<IMessage>): Promise<IMessage>;
    findMessage(filter: IMessageFilter): Promise<IMessage | null>;
    findMessages(filter?: IMessageFilter, orderBy?: IMessageOrderBy, skip?: number, take?: number): Promise<IMessage[]>;
    deleteMessage(id: string): Promise<void>;
}

interface IGQLAuthContext {
    user: IUser | null;
}

interface IConversationEventServiceOptions {
    pubSubEngine?: IConversationEventServicePubSubEngine;
    pubSubChannelPrefix?: string;
    cache?: IConversationEventServiceCache;
    cachePrefix?: string;
}
interface IConversationEventServiceCache {
    get(key: string): Promise<string>;
    set(key: string, value: string): Promise<any>;
}
interface IConversationEventServicePubSubEngine {
    publish(triggerName: string, payload: any): Promise<void>;
    subscribe(triggerName: string, onMessage: Function, options: Object): Promise<number>;
    unsubscribe(subId: number): any;
    asyncIterator<T>(triggers: string | string[]): AsyncIterator<T>;
}

export { IConversation, IConversationEventServiceCache, IConversationEventServiceOptions, IConversationEventServicePubSubEngine, IConversationFilter, IConversationOrderBy, IGQLAuthContext, IMessage, IMessageFilter, IMessageOrderBy, IStorageEngine, IUser, IUserFilter };
